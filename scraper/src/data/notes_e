{"allTables":[{"tableRows":[{"text":"Storage Management"}]},{"tableRows":[{"text":"Storage Management2/143"}]},{"tableRows":[{"text":"Disks3/143"}]},{"tableRows":[{"text":"... Disks4/143"}]},{"tableRows":[{"text":"... Disks5/143"}]},{"tableRows":[{"text":"... Disks6/143"}]},{"tableRows":[{"text":"SSDs7/143"}]},{"tableRows":[{"text":"... SSDs8/143"}]},{"tableRows":[{"text":"Operating Systems and Storage9/143"}]},{"tableRows":[{"text":"File Systems"}]},{"tableRows":[{"text":"File Systems11/143"}]},{"tableRows":[{"text":"Unix/Linux File System12/143"}]},{"tableRows":[{"text":"... Unix/Linux File System13/143"}]},{"tableRows":[{"text":"... Unix/Linux File System14/143"}]},{"tableRows":[{"text":"... Unix/Linux File System15/143"}]},{"tableRows":[{"text":"... Unix/Linux File System16/143"}]},{"tableRows":[{"text":"File System Operations17/143"}]},{"tableRows":[{"text":"open() / close()18/143"}]},{"tableRows":[{"text":"... open() / close()19/143"}]},{"tableRows":[{"text":"... open() / close()20/143"}]},{"tableRows":[{"text":" read() / write()21/143"}]},{"tableRows":[{"text":"... read() / write()22/143"}]},{"tableRows":[{"text":"... read() / write()23/143"}]},{"tableRows":[{"text":"... read() / write()24/143"}]},{"tableRows":[{"text":"... read() / write()25/143"}]},{"tableRows":[{"text":" seek()26/143"}]},{"tableRows":[{"text":"... seek()27/143"}]},{"tableRows":[{"text":" stat()28/143"}]},{"tableRows":[{"text":"Links29/143"}]},{"tableRows":[{"text":"... Links30/143"}]},{"tableRows":[{"text":"... Links31/143"}]},{"tableRows":[{"text":"... Links32/143"}]},{"tableRows":[{"text":"... Links33/143"}]},{"tableRows":[{"text":"... Links34/143"}]},{"tableRows":[{"text":"File System Summary35/143"}]},{"tableRows":[{"text":"Memory Management"}]},{"tableRows":[{"text":"Memory37/143"}]},{"tableRows":[{"text":"Processes38/143"}]},{"tableRows":[{"text":"Memory Management39/143"}]},{"tableRows":[{"text":"... Memory Management40/143"}]},{"tableRows":[{"text":"... Memory Management41/143"}]},{"tableRows":[{"text":"... Memory Management42/143"}]},{"tableRows":[{"text":"... Memory Management43/143"}]},{"tableRows":[{"text":"... Memory Management44/143"}]},{"tableRows":[{"text":"... Memory Management45/143"}]},{"tableRows":[{"text":"... Memory Management46/143"}]},{"tableRows":[{"text":"... Memory Management47/143"}]},{"tableRows":[{"text":"... Memory Management48/143"}]},{"tableRows":[{"text":"... Memory Management49/143"}]},{"tableRows":[{"text":"... Memory Management50/143"}]},{"tableRows":[{"text":"Memory Management Review51/143"}]},{"tableRows":[{"text":"Address Mapping52/143"}]},{"tableRows":[{"text":"... Address Mapping53/143"}]},{"tableRows":[{"text":"Virtual Memory54/143"}]},{"tableRows":[{"text":"... Virtual Memory55/143"}]},{"tableRows":[{"text":"... Virtual Memory56/143"}]},{"tableRows":[{"text":"... Virtual Memory57/143"}]},{"tableRows":[{"text":"... Virtual Memory58/143"}]},{"tableRows":[{"text":"An Aside: Working Sets59/143"}]},{"tableRows":[{"text":"... An Aside: Working Sets60/143"}]},{"tableRows":[{"text":"Virtual Memory61/143"}]},{"tableRows":[{"text":"... Virtual Memory62/143"}]},{"tableRows":[{"text":"... Virtual Memory63/143"}]},{"tableRows":[{"text":"... Virtual Memory64/143"}]},{"tableRows":[{"text":"Page Faults65/143"}]},{"tableRows":[{"text":"... Page Faults66/143"}]},{"tableRows":[{"text":"Page Replacement67/143"}]},{"tableRows":[{"text":"... Page Replacement68/143"}]},{"tableRows":[{"text":"... Page Replacement69/143"}]},{"tableRows":[{"text":"... Page Replacement70/143"}]},{"tableRows":[{"text":"Virtual Memory 71/143"}]},{"tableRows":[{"text":"... Virtual Memory 72/143"}]},{"tableRows":[{"text":"... Virtual Memory 73/143"}]},{"tableRows":[{"text":"Cache Memory74/143"}]},{"tableRows":[{"text":"... Cache Memory75/143"}]},{"tableRows":[{"text":"Memory Management Hardware76/143"}]},{"tableRows":[{"text":"... Memory Management Hardware77/143"}]},{"tableRows":[{"text":"Process Management"}]},{"tableRows":[{"text":"Processes79/143"}]},{"tableRows":[{"text":"... Processes80/143"}]},{"tableRows":[{"text":"... Processes81/143"}]},{"tableRows":[{"text":"Process Management82/143"}]},{"tableRows":[{"text":"... Process Management83/143"}]},{"tableRows":[{"text":"Unix/Linux Processes84/143"}]},{"tableRows":[{"text":"... Unix/Linux Processes85/143"}]},{"tableRows":[{"text":"... Unix/Linux Processes86/143"}]},{"tableRows":[{"text":"... Unix/Linux Processes87/143"}]},{"tableRows":[{"text":"Process-related System Calls88/143"}]},{"tableRows":[{"text":"... Process-related System Calls89/143"}]},{"tableRows":[{"text":"... Process-related System Calls90/143"}]},{"tableRows":[{"text":"... Process-related System Calls91/143"}]},{"tableRows":[{"text":"... Process-related System Calls92/143"}]},{"tableRows":[{"text":"... Process-related System Calls93/143"}]},{"tableRows":[{"text":"... Process-related System Calls94/143"}]},{"tableRows":[{"text":"... Process-related System Calls95/143"}]},{"tableRows":[{"text":"... Process-related System Calls96/143"}]},{"tableRows":[{"text":"... Process-related System Calls97/143"}]},{"tableRows":[{"text":"... Process-related System Calls98/143"}]},{"tableRows":[{"text":"... Process-related System Calls99/143"}]},{"tableRows":[{"text":"... Process-related System Calls100/143"}]},{"tableRows":[{"text":"... Process-related System Calls101/143"}]},{"tableRows":[{"text":"... Process-related System Calls102/143"}]},{"tableRows":[{"text":"... Process-related System Calls103/143"}]},{"tableRows":[{"text":"... Process-related System Calls104/143"}]},{"tableRows":[{"text":"Process Control Flow105/143"}]},{"tableRows":[{"text":"... Process Control Flow106/143"}]},{"tableRows":[{"text":"... Process Control Flow107/143"}]},{"tableRows":[{"text":"... Process Control Flow108/143"}]},{"tableRows":[{"text":"Signals109/143"}]},{"tableRows":[{"text":"... Signals110/143"}]},{"tableRows":[{"text":"... Signals111/143"}]},{"tableRows":[{"text":"Signal Handlers112/143"}]},{"tableRows":[{"text":"... Signal Handlers113/143"}]},{"tableRows":[{"text":"... Signal Handlers114/143"}]},{"tableRows":[{"text":"... Signal Handlers115/143"}]},{"tableRows":[{"text":"... Signal Handlers116/143"}]},{"tableRows":[{"text":"... Signal Handlers117/143"}]},{"tableRows":[{"text":"Interrupts118/143"}]},{"tableRows":[{"text":"... Interrupts119/143"}]},{"tableRows":[{"text":"... Interrupts120/143"}]},{"tableRows":[{"text":"Exceptions121/143"}]},{"tableRows":[{"text":"... Exceptions122/143"}]},{"tableRows":[{"text":"Multi-tasking123/143"}]},{"tableRows":[{"text":"Process States124/143"}]},{"tableRows":[{"text":"Scheduling125/143"}]},{"tableRows":[{"text":"... Scheduling126/143"}]},{"tableRows":[{"text":"... Scheduling127/143"}]},{"tableRows":[{"text":"Device Management"}]},{"tableRows":[{"text":"Device Management129/143"}]},{"tableRows":[{"text":"I/O Devices130/143"}]},{"tableRows":[{"text":"... I/O Devices131/143"}]},{"tableRows":[{"text":"... I/O Devices132/143"}]},{"tableRows":[{"text":"... I/O Devices133/143"}]},{"tableRows":[{"text":"... I/O Devices134/143"}]},{"tableRows":[{"text":"Device Drivers135/143"}]},{"tableRows":[{"text":"Memory-mapped I/O136/143"}]},{"tableRows":[{"text":"... Memory-mapped I/O137/143"}]},{"tableRows":[{"text":"Devices on Unix/Linux138/143"}]},{"tableRows":[{"text":"... Devices on Unix/Linux139/143"}]},{"tableRows":[{"text":"... Devices on Unix/Linux140/143"}]},{"tableRows":[{"text":"... Devices on Unix/Linux141/143"}]},{"tableRows":[{"text":"Buffered I/O142/143"}]},{"tableRows":[{"text":"... Buffered I/O143/143"}]}],"allParagraphs":[{"text":"E: Operating System Components"},{"text":" "},{"text":""},{"text":" Storage Management "},{"text":" "},{"text":""},{"text":" Storage Management2/143 "},{"text":" Computer systems have bulk, persistent storage devices "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" Disks3/143 "},{"text":" HDD = Hard Disk Drive "},{"text":" HDDs have the following characteristics: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Disks4/143 "},{"text":" To access data on disk (one sector at-a-time) "},{"text":""},{"text":" ... Disks5/143 "},{"text":" Typical (and historical) measures of HDDs: "},{"text":""},{"text":" ... Disks6/143 "},{"text":" Disks are block-oriented devices "},{"text":""},{"text":" SSDs7/143 "},{"text":" SSD = solid-state drive "},{"text":" SSDs are fully-electronic devices that can store data persistenly "},{"text":""},{"text":" ... SSDs8/143 "},{"text":" OSs can view SSDs like HDDs "},{"text":""},{"text":" Operating Systems and Storage9/143 "},{"text":" Operating System manages data stored on bulk storage devices "},{"text":""},{"text":" File Systems "},{"text":" "},{"text":""},{"text":" File Systems11/143 "},{"text":" File systems provide a mechanism for managing stored data: "},{"text":""},{"text":" Unix/Linux File System12/143 "},{"text":" Unix/Linux file system is tree-structured "},{"text":""},{"text":" (We say it's \"tree structured\", but symlinks actually make it into a graph) "},{"text":" Processes have a notion of their location within the file system "},{"text":""},{"text":" ... Unix/Linux File System13/143 "},{"text":" The file system is used to access various types of objects: "},{"text":" Paths can be "},{"text":" e.g. /usr/include/stdio.h, /home/jas/cs1521/ "},{"text":" e.g. ../../another/path/prog.c, ./a.out, a.out "},{"text":""},{"text":" ... Unix/Linux File System14/143 "},{"text":" Unix defines a range of file-system-related types: "},{"text":""},{"text":" ... Unix/Linux File System15/143 "},{"text":" Metadata for file system objects is stored in inodes "},{"text":" Note: an inode does not contain the name of the file "},{"text":" Access to a file by name requires a directory "},{"text":""},{"text":" ... Unix/Linux File System16/143 "},{"text":" Access to files by name proceeds as ... "},{"text":""},{"text":" File System Operations17/143 "},{"text":" Unix presents a uniform interface to file system objects "},{"text":""},{"text":" open() / close()18/143 "},{"text":" int open(char *Path, int Flags) "},{"text":""},{"text":" ... open() / close()19/143 "},{"text":" int close(int FileDesc) "},{"text":" An aside: removing an object e.g. via rm "},{"text":""},{"text":" ... open() / close()20/143 "},{"text":" Example using open() and close() "},{"text":""},{"text":" "},{"text":""},{"text":" read() / write()21/143 "},{"text":" ssize_t read(int FileDesc, void *Buffer, size_t Count) "},{"text":" "},{"text":" Once a file is open()'d ... "},{"text":""},{"text":" ... read() / write()22/143 "},{"text":" ssize_t write(int FileDesc, void *Buffer, size_t Count) "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... read() / write()23/143 "},{"text":" Functions from stdio.h tend to be char-oriented "},{"text":" File-descriptor-based system calls deal with byte sequences "},{"text":" ** you cannot save/restore pointer values using write()/read() "},{"text":""},{"text":" ... read() / write()24/143 "},{"text":" Files of records can be produced by "},{"text":" For the write() approach: "},{"text":""},{"text":" ... read() / write()25/143 "},{"text":" Example of write()ing records vs printf()ing records "},{"text":""},{"text":" "},{"text":""},{"text":" seek()26/143 "},{"text":" off_t lseek(int FileDesc, off_t Offset, int Whence) "},{"text":" "},{"text":""},{"text":" ... seek()27/143 "},{"text":" Example: "},{"text":""},{"text":" "},{"text":""},{"text":" stat()28/143 "},{"text":" int stat(char *FileName, struct stat *StatBuf) "},{"text":""},{"text":" Links29/143 "},{"text":" File system links allow multiple paths to access the same data "},{"text":" Hard links "},{"text":""},{"text":" "},{"text":""},{"text":" ... Links30/143 "},{"text":" File stat structure: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Links31/143 "},{"text":" The st_mode is a bit-string containing some of: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Links32/143 "},{"text":" int mkdir(char *PathName, mode_t Mode) "},{"text":""},{"text":" ... Links33/143 "},{"text":" int fsync(int FileDesc) "},{"text":""},{"text":" ... Links34/143 "},{"text":" int mount(char *Source, char *Target, char *FileSysType, unsigned long Flags, void *data) "},{"text":" (use disk5 to hold the /usr file system as read-only ext3-type) "},{"text":""},{"text":" File System Summary35/143 "},{"text":" Operating systems provide a file system "},{"text":""},{"text":" Memory Management "},{"text":" "},{"text":""},{"text":" Memory37/143 "},{"text":" Systems typically contain 4-16GB of volatile RAM "},{"text":""},{"text":" Plus other smaller faster cache memory "},{"text":""},{"text":" Processes38/143 "},{"text":" A process is an active computation, consisting of "},{"text":""},{"text":" Memory Management39/143 "},{"text":" Operating system provides a view of memory for individual processes "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management40/143 "},{"text":" On a system with e.g. 1 CPU, 1 memory and 100's of processes "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management41/143 "},{"text":" The good-old-days ... one process/computation at a time "},{"text":""},{"text":" Or, if the process did not need the entire memory "},{"text":""},{"text":" Easy to implement by initialising $sp to psize-4 "},{"text":""},{"text":" ... Memory Management42/143 "},{"text":" Two processes loaded into memory at once "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management43/143 "},{"text":" When proc1 is loaded ... "},{"text":""},{"text":" ... Memory Management44/143 "},{"text":" Consider a scenario with multiple processes loaded in memory: "},{"text":""},{"text":" If we do on-the-fly address mapping, we need to ... "},{"text":""},{"text":" ... Memory Management45/143 "},{"text":" Consider the same scenario, but now we want to add a new process "},{"text":""},{"text":" The new process doesn't fit in any of the unused slots "},{"text":" Could move some process to make a single large slot "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management46/143 "},{"text":" Alternative strategy: split new process memory over two regions "},{"text":" "},{"text":""},{"text":" "},{"text":" becomes "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management47/143 "},{"text":" Implications for splitting process memory across physical memory "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management48/143 "},{"text":" Under this scheme, address mapping calculation is complicated "},{"text":""},{"text":" The above mapping must be done in hardware to be efficient. "},{"text":""},{"text":" ... Memory Management49/143 "},{"text":" Address mapping would be simpler if all chunks were same size "},{"text":""},{"text":" ... Memory Management50/143 "},{"text":" Example of simple mapping table: "},{"text":""},{"text":" "},{"text":""},{"text":" Memory Management Review51/143 "},{"text":" Reminder: process addresses ↔ physical addresses "},{"text":""},{"text":" Address Mapping52/143 "},{"text":" Mapping from process address to physical address: "},{"text":""},{"text":" Computation of pageno,offset is efficient if Pagesize == 2n "},{"text":" Note that we assume PageInfo entries with more information .... "},{"text":""},{"text":" ... Address Mapping53/143 "},{"text":" Page table entries typically do not store physical address "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" Virtual Memory54/143 "},{"text":" A side-effect of this type of virtual→physical address mapping "},{"text":""},{"text":" ... Virtual Memory55/143 "},{"text":" Pages/frames are typically 512B .. 8KB in size "},{"text":" In a 4GB memory, would have ≅4 million × 1KB frames "},{"text":" Each frame can hold one page of process address space "},{"text":" Leads to a memory layout like this (with L total pages of physical memory): "},{"text":" "},{"text":""},{"text":" When a process completes, all of its frames are released for re-use "},{"text":""},{"text":" ... Virtual Memory56/143 "},{"text":" How to arrange mapping process address → physical address? "},{"text":" Consider a per-process page table, e.g. "},{"text":""},{"text":" ... Virtual Memory57/143 "},{"text":" Example of page table for one process: "},{"text":""},{"text":" Timestamps show when page was loaded. "},{"text":""},{"text":" ... Virtual Memory58/143 "},{"text":" Virtual address to physical address mapping (more detail): "},{"text":""},{"text":" "},{"text":""},{"text":" An Aside: Working Sets59/143 "},{"text":" Consider a new process commencing execution ... "},{"text":""},{"text":" ... An Aside: Working Sets60/143 "},{"text":" From observations of running programs ... "},{"text":" Only need to hold, at a given time, the process's working set of pages "},{"text":" Implications: "},{"text":""},{"text":" Virtual Memory61/143 "},{"text":" We say that we \"load\" pages into physical memory "},{"text":" But where are they loaded from? "},{"text":" The pages of dynamic data not currently in use "},{"text":""},{"text":" ... Virtual Memory62/143 "},{"text":" We can imagine that a process's address space ... "},{"text":""},{"text":" "},{"text":" Transferring pages between disk↔memory is very expensive "},{"text":""},{"text":" ... Virtual Memory63/143 "},{"text":" Per-process page table, allowing for some pages to be not loaded "},{"text":""},{"text":" "},{"text":""},{"text":" ... Virtual Memory64/143 "},{"text":" Recall the address mapping process with per-process page tables "},{"text":""},{"text":" What to do if the page is not loaded? "},{"text":""},{"text":" Page Faults65/143 "},{"text":" Requesting a non-loaded page generates a page fault. "},{"text":" One approach to handling a page fault ... "},{"text":""},{"text":" Assumes that we have a way of quickly identifying free frames "},{"text":" Commonly handled via a free list "},{"text":" Reminder: frames allocated to a process become free when process exits "},{"text":""},{"text":" ... Page Faults66/143 "},{"text":" What happens if there are currently no free page frames "},{"text":" What does getFreeFrame() do? "},{"text":" Possibilities: "},{"text":""},{"text":" Page Replacement67/143 "},{"text":" What happens when a page is replaced? "},{"text":""},{"text":" "},{"text":""},{"text":" ... Page Replacement68/143 "},{"text":" Factors to consider in deciding which page to replace "},{"text":" But we do know whether it has been used recently (if we record this) "},{"text":" Useful heuristic: LRU replacement "},{"text":""},{"text":" ... Page Replacement69/143 "},{"text":" Factors for choosing best page to replace are heuristic "},{"text":" What happens if ... "},{"text":" The working set model plus LRU helps avoid thrashing "},{"text":""},{"text":" ... Page Replacement70/143 "},{"text":" LRU is one replacement strategy. Others include: "},{"text":" First-in-first-out (FIFO) "},{"text":""},{"text":" Virtual Memory 71/143 "},{"text":" Page tables (PTs) revisited ... "},{"text":""},{"text":" "},{"text":""},{"text":" ... Virtual Memory 72/143 "},{"text":" Alternative strategy: multi-level page tables "},{"text":""},{"text":" Effective because not all pages in virtual address space are required (e.g. the pages between the top of the heap and the bottom of the stack) "},{"text":""},{"text":" ... Virtual Memory 73/143 "},{"text":" Virtual memory allows sharing of read-only pages (e.g. library code) "},{"text":""},{"text":" "},{"text":""},{"text":" Cache Memory74/143 "},{"text":" Cache memory = small*, fast memory* close to CPU "},{"text":" "},{"text":""},{"text":" "},{"text":" Small = MB, Fast = 5 × RAM "},{"text":""},{"text":" ... Cache Memory75/143 "},{"text":" Cache memory "},{"text":""},{"text":" Memory Management Hardware76/143 "},{"text":" Address translation is very important/frequent "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory Management Hardware77/143 "},{"text":" TLB = translation lookaside buffer "},{"text":""},{"text":" "},{"text":""},{"text":" Process Management "},{"text":" "},{"text":""},{"text":" Processes79/143 "},{"text":" A process is an instance of an executing program "},{"text":" Multiple processes are \"active\" simultaneously "},{"text":""},{"text":" ... Processes80/143 "},{"text":" Control-flow independence (\"I am the only process, and I run until I finish\") "},{"text":" In reality, there are multiple processes running on the machine "},{"text":""},{"text":" Overall impression: three programs running simultaneously "},{"text":""},{"text":" ... Processes81/143 "},{"text":" What can cause a process to be pre-empted? "},{"text":" Overall impression: I ran until I finished all my computation "},{"text":""},{"text":" Process Management82/143 "},{"text":" How does the OS manage multiple simultaneous processes? "},{"text":" Context = collection of information for one process "},{"text":""},{"text":" ... Process Management83/143 "},{"text":" Process control block = where OS records info about each process "},{"text":""},{"text":" Unix/Linux Processes84/143 "},{"text":" Environment for processes running on Unix/Linux systems "},{"text":""},{"text":" "},{"text":""},{"text":" ... Unix/Linux Processes85/143 "},{"text":" Unix provides a range of tools for manipulating processes "},{"text":" Commands: "},{"text":""},{"text":" ... Unix/Linux Processes86/143 "},{"text":" Information associated with processes (PCB): "},{"text":""},{"text":" ... Unix/Linux Processes87/143 "},{"text":" Process info is split across process table entry and user structure "},{"text":" Process table = kernel data structure describing all processes "},{"text":""},{"text":" Process-related System Calls88/143 "},{"text":" pid_t fork(void) "},{"text":""},{"text":" ... Process-related System Calls89/143 "},{"text":" Minimal example for fork(): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Process-related System Calls90/143 "},{"text":" Every process in Unix/Linux is allocated a process ID "},{"text":""},{"text":" ... Process-related System Calls91/143 "},{"text":" Getting information about a process ... "},{"text":" pid_t getpid() "},{"text":""},{"text":" ... Process-related System Calls92/143 "},{"text":" Processes belong to process groups "},{"text":" For more details: man 2 getpgid "},{"text":""},{"text":" ... Process-related System Calls93/143 "},{"text":" Minimal example for getpid(): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Process-related System Calls94/143 "},{"text":" pid_t waitpid(pid_t pid, int *status, int options) "},{"text":""},{"text":" ... Process-related System Calls95/143 "},{"text":" More on waitpid(pid, &status, options) "},{"text":""},{"text":" ... Process-related System Calls96/143 "},{"text":" Minimal example for wait(): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Process-related System Calls97/143 "},{"text":" int kill(pid_t ProcID, int SigID) "},{"text":""},{"text":" ... Process-related System Calls98/143 "},{"text":" Minimal example for kill(): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Process-related System Calls99/143 "},{"text":" void _exit(int status) "},{"text":""},{"text":" ... Process-related System Calls100/143 "},{"text":" void exit(int status) "},{"text":""},{"text":" ... Process-related System Calls101/143 "},{"text":" "},{"text":""},{"text":" "},{"text":" "},{"text":""},{"text":" ... Process-related System Calls102/143 "},{"text":" When a process finishes, sends SIGCHLD signal to parent "},{"text":" Zombie process = a process which has exited but signal not handled "},{"text":""},{"text":" ... Process-related System Calls103/143 "},{"text":" int execve(char *Path, char *Argv[], char *Envp[]) "},{"text":""},{"text":" ... Process-related System Calls104/143 "},{"text":" On Unix, processes create new different processes via: "},{"text":""},{"text":" "},{"text":""},{"text":" Process Control Flow105/143 "},{"text":" When a process is executing ... "},{"text":" Regular control flow can be interrupted ⇒ exceptional control flow "},{"text":""},{"text":" ... Process Control Flow106/143 "},{"text":" Exceptional events are "},{"text":" Two types of exceptional events "},{"text":""},{"text":" ... Process Control Flow107/143 "},{"text":" Effect of exceptions/interrupts on control flow "},{"text":""},{"text":" "},{"text":""},{"text":" ... Process Control Flow108/143 "},{"text":" System calls typically operate via exceptions (traps) "},{"text":" Critical difference is transfer to system space (privileged mode) "},{"text":""},{"text":" Signals109/143 "},{"text":" Signals can be generated from a variety of sources "},{"text":""},{"text":" ... Signals110/143 "},{"text":" Signals from internal process activity, e.g. "},{"text":" Signals from external process events, e.g. "},{"text":""},{"text":" ... Signals111/143 "},{"text":" Processes can choose to ignore most signals. "},{"text":" If not ignored, signals can be handled in several default ways "},{"text":" See man 7 signal for details of signals and default handling. "},{"text":""},{"text":" Signal Handlers112/143 "},{"text":" Signal Handler = a function invoked in response to a signal "},{"text":""},{"text":" "},{"text":""},{"text":" ... Signal Handlers113/143 "},{"text":" SigHnd signal(int SigID, SigHnd Handler) "},{"text":""},{"text":" ... Signal Handlers114/143 "},{"text":" How to define and install a signal handler function: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Signal Handlers115/143 "},{"text":" int sigaction(int sigID, struct sigaction *newAct, struct sigaction *oldAct) "},{"text":""},{"text":" ... Signal Handlers116/143 "},{"text":" Details on struct sigaction ... "},{"text":""},{"text":" ... Signal Handlers117/143 "},{"text":" Details on siginfo_t ... "},{"text":""},{"text":" Interrupts118/143 "},{"text":" Interrupts are signals which "},{"text":""},{"text":" ... Interrupts119/143 "},{"text":" Example (process pre-emption): "},{"text":""},{"text":" ... Interrupts120/143 "},{"text":" Interrupts are frequently associated with input/output "},{"text":""},{"text":" Exceptions121/143 "},{"text":" Above exceptions are low-level, system ones. "},{"text":" Alternative notion of exceptions: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Exceptions122/143 "},{"text":" Such exceptions require handling in context of computation "},{"text":" Example: "},{"text":""},{"text":" C does not have generic exception handling; roll your own. "},{"text":""},{"text":" Multi-tasking123/143 "},{"text":" Multi-tasking = multiple processes are \"active\" at the same time "},{"text":""},{"text":" Process States124/143 "},{"text":" How process state changes during execution ... "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" Scheduling125/143 "},{"text":" Scheduling = selecting which process should run next "},{"text":""},{"text":" ... Scheduling126/143 "},{"text":" Linux process scheduler ... "},{"text":""},{"text":" ... Scheduling127/143 "},{"text":" Abstract view of the OS scheduler "},{"text":""},{"text":" "},{"text":""},{"text":" Device Management "},{"text":" "},{"text":""},{"text":" Device Management129/143 "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" I/O Devices130/143 "},{"text":" Input/Output (I/O) devices "},{"text":""},{"text":" ... I/O Devices131/143 "},{"text":" Hard Disk characteristics: "},{"text":""},{"text":" Typical cost: 10ms seek + 5ms latency + 0.1ms transfer "},{"text":""},{"text":" ... I/O Devices132/143 "},{"text":" Solid State Disk (SSD) characteristics: "},{"text":""},{"text":" "},{"text":""},{"text":" ... I/O Devices133/143 "},{"text":" Example: network transfer "},{"text":" Can check transmission times using the ping command "},{"text":""},{"text":" ... I/O Devices134/143 "},{"text":" Other types of devices ... "},{"text":""},{"text":" Device Drivers135/143 "},{"text":" Each type of device has its own unique access protocol "},{"text":""},{"text":" Memory-mapped I/O136/143 "},{"text":" Memory-mapped input/output "},{"text":" (cf. having limited set of special instructions to manipulate i/o devices) "},{"text":""},{"text":" ... Memory-mapped I/O137/143 "},{"text":" Example of using memory-mapped I/O. "},{"text":" Assume memory address of disk device is 0x80000200 "},{"text":""},{"text":" Transfers data from memory onto the disk at specified block. "},{"text":" Disclaimer: Above code is not real MIPS/SPIM code. Illustrative only. "},{"text":""},{"text":" Devices on Unix/Linux138/143 "},{"text":" Unix treats devices uniformly as byte-streams (like files). "},{"text":" Devices can be accessed via the file system under /dev, e.g. "},{"text":""},{"text":" ... Devices on Unix/Linux139/143 "},{"text":" Two standard types of \"device files\" ... "},{"text":" Character devices (aka character special files) "},{"text":""},{"text":" ... Devices on Unix/Linux140/143 "},{"text":" int ioctl(int FileDesc, int Request, void *Arg) "},{"text":""},{"text":" ... Devices on Unix/Linux141/143 "},{"text":" Devices can be manipulated by open(), read(), write() ... "},{"text":" int open(char *PathName, int Flags) "},{"text":""},{"text":" Buffered I/O142/143 "},{"text":" Devices are typically very slow compared to CPU speed "},{"text":" Using a read() from a device for each byte is inefficient "},{"text":" Note that read() accesses data via the OS buffers "},{"text":""},{"text":" ... Buffered I/O143/143 "},{"text":" The standard i/o library (stdio.h) provides buffered i/o "},{"text":""},{"text":" Produced: 29 Apr 2018 "}],"allLists":[{"type":"list"}," magnetic medium, arranged in concentric tracks ",{"type":"list"}," usually multiple surfaces for storing data ",{"type":"list"}," rotates at very high speed (e.g. 7200rpm) ",{"type":"list"}," each track divided into fixed size sectors outer tracks have more sectors than inner tracks ",{"type":"list"}," outer tracks have more sectors than inner tracks ",{"type":"list"}," read/write head which can read/write one sector at-a-time ",{"type":"list"}," head moves to track (mechanical motion) ",{"type":"list"}," head waits for sector to rotate under head (mechanical) ",{"type":"list"}," read/write data from/to disk surface (electronic) ",{"type":"list"}," seek time (move to track) in range 0ms .. 12ms ",{"type":"list"}," rotational latency (wait for sector) in range 2ms .. 4ms ",{"type":"list"}," data transfer ... typically 200 MB/s (relatively small) ",{"type":"list"}," Overall: tens of milliseconds for a single access ",{"type":"list"}," capacity ... 4TB ... available storage 3.5TB ",{"type":"list"}," size ... 2.5/3cm, volume ... 34cm3, weight ... 60g ",{"type":"list"}," speed ... ~20ms to find sector, < 1ms to read sector ",{"type":"list"}," capacity ... 3MB ... available storage 2.5MB ",{"type":"list"}," size ... 1.5m, volume ... 2m3, weight ... 900kg ",{"type":"list"}," speed ... ~600ms to find sector, 5ms to read sector ",{"type":"list"}," all data transfers read/write fixed number of bytes ",{"type":"list"}," even if only one byte is required ",{"type":"list"}," typical transfer size 512 bytes .. 4096 bytes ",{"type":"list"}," each block comprised of one or more sectors ",{"type":"list"}," sectors for block arranged to minimse head movement/latency ",{"type":"list"}," don't have mechanical delays that HDDs do (R/W much faster) ",{"type":"list"}," better thermal performance that HDDs (e.g. no fans needed) ",{"type":"list"}," controller more complex/spohisticated than HDD controller ",{"type":"list"}," relatively expensive per byte of storage (compared to HDDs) ",{"type":"list"}," limited number of read/writes on each block before failure ",{"type":"list"}," data \"leaks\" over time (over years ... but worse than HDDs) ",{"type":"list"}," writing requires erase-then-overwrite ",{"type":"list"}," susceptible to elector-magnetic fluctations (e.g. power-outs) ",{"type":"list"}," block-oriented devices but much faster than HDDs (e.g. 0.1ms) ",{"type":"list"}," but limited number (105) of erases on each block before failure ",{"type":"list"}," easier to access logical blocks (access to multiple SSD blocks) ",{"type":"list"}," less fragmentation problems than HDDs ",{"type":"list"}," drop-in, high-speed replacement for HDD ",{"type":"list"}," provides an abstract view of devices ",{"type":"list"}," hiding details of device control and data transfer ",{"type":"list"}," typically on a disk device (or, nowadays, on SSD) ",{"type":"list"}," allocating chunks of space on the device to files where a file is viewed as a sequence of bytes ",{"type":"list"}," where a file is viewed as a sequence of bytes ",{"type":"list"}," allowing access to files by name and with access rights ",{"type":"list"}," arranging access to files via directories (folders) ",{"type":"list"}," maintaining information about files/directories (meta-data) ",{"type":"list"}," dealing with damage on the storage device (\"bad blocks\") ",{"type":"list"}," current working directory (CWD) ",{"type":"list"}," files, directories (folders), devices, processes, sockets, ... ",{"type":"list"}," absolute (full path from root) e.g. /usr/include/stdio.h, /home/jas/cs1521/ ",{"type":"list"}," relative (path starts from CWD) e.g. ../../another/path/prog.c, ./a.out, a.out ",{"type":"list"}," off_t ... offsets within files typically, long and signed to allow backward refs ",{"type":"list"}," typically, long and signed to allow backward refs ",{"type":"list"}," size_t ... number of bytes in some object unsigned, since objects can't have negative size ",{"type":"list"}," unsigned, since objects can't have negative size ",{"type":"list"}," ssize_t ... sizes of read/written blocks like size_t, but signed to allow for error values ",{"type":"list"}," like size_t, but signed to allow for error values ",{"type":"list"}," struct stat ... file system object metadata stores information about file, but stores no content requires ino_t, dev_t, time_t, uid_t, ... ",{"type":"list"}," stores information about file, but stores no content ",{"type":"list"}," requires ino_t, dev_t, time_t, uid_t, ... ",{"type":"list"}," physical location on storage device of file data ",{"type":"list"}," file type (regular file, directory, ...), file size (bytes/blocks) ",{"type":"list"}," ownership, access permissions, timestamps (create/access/update) ",{"type":"list"}," where a directory is effectively a list of (name,inode) pairs ",{"type":"list"}," open directory and scan for name ",{"type":"list"}," if not found, \"No such file or directory\" ",{"type":"list"}," if found as (name,ino), access inode table inodes[ino] ",{"type":"list"}," collect file metadata and ... check file access permissions given current user/group if don't have required access, \"Permission denied\" collect information about file's location and size update access timestamp ",{"type":"list"}," check file access permissions given current user/group if don't have required access, \"Permission denied\" ",{"type":"list"}," if don't have required access, \"Permission denied\" ",{"type":"list"}," collect information about file's location and size ",{"type":"list"}," update access timestamp ",{"type":"list"}," use physical location to access device and read/write file's data ",{"type":"list"}," functions/syscalls manipulate objects as a stream of bytes ",{"type":"list"}," accessed via a file descriptor (index into a system table) ",{"type":"list"}," open() ... open a file system object, returning a file descriptor ",{"type":"list"}," close() ... stop using a file descriptor ",{"type":"list"}," read() ... read some bytes into a buffer from a file descriptor ",{"type":"list"}," write() ... write some bytes from a buffer to a file descriptor ",{"type":"list"}," lseek() ... move to a specified offset within a file ",{"type":"list"}," stat() ... get meta-data about a file system object ",{"type":"list"}," mount() ... place a filesystem on a device ",{"type":"list"}," attempt to open an object at Path, according to Flags ",{"type":"list"}," flags (defined in <fcntl.h>) O_RDONLY ... open object for reading O_WRONLY ... open object for writing O_APPEND ... open object for writing at end O_RDWR ... open object for reading and writing O_CREAT ... create object if doesn't exist ",{"type":"list"}," O_RDONLY ... open object for reading ",{"type":"list"}," O_WRONLY ... open object for writing ",{"type":"list"}," O_APPEND ... open object for writing at end ",{"type":"list"}," O_RDWR ... open object for reading and writing ",{"type":"list"}," O_CREAT ... create object if doesn't exist ",{"type":"list"}," flags can be combined e.g. (O_WRONLY|O_CREAT) ",{"type":"list"}," if successful, return file descriptor (small +ve int) ",{"type":"list"}," if unsuccessful, return -1 and set errno ",{"type":"list"}," attempt to release an open file descriptor ",{"type":"list"}," if this is the last reference to object, release its resources ",{"type":"list"}," if successful, return 0 ",{"type":"list"}," if unsuccessful, return -1 and set errno ",{"type":"list"}," removes the object's entry from a directory ",{"type":"list"}," but the inode and data persist until all processes accessing the object close() their handle all references to the inode from other directories are removed ",{"type":"list"}," all processes accessing the object close() their handle ",{"type":"list"}," all references to the inode from other directories are removed ",{"type":"list"}," after this, the inode and the blocks on storage device are recycled ",{"type":"list"}," attempt to read Count bytes from FileDesc into Buffer ",{"type":"list"}," if \"successful\", return number of bytes actually read (NRead) ",{"type":"list"}," if currently positioned at end of file, return 0 ",{"type":"list"}," if unsuccessful, return -1 and set errno ",{"type":"list"}," does not check whether Buffer contains enough space ",{"type":"list"}," advances the file offset by NRead ",{"type":"list"}," does not treat '\\n' as special ",{"type":"list"}," the \"current position\" in the file is maintained as part of the fd entry ",{"type":"list"}," the \"current position\" is modified by read(), write() and lseek() ",{"type":"list"}," attempt to write Count bytes from Buffer onto FileDesc ",{"type":"list"}," if \"successful\", return number of bytes actually written (NWritten) ",{"type":"list"}," if unsuccessful, return -1 and set errno ",{"type":"list"}," does not check whether Buffer has Count bytes of data ",{"type":"list"}," advances the file offset by NWritten bytes ",{"type":"list"}," bytes can be interpreted as char, int, struct, etc ",{"type":"list"}," so, many kinds of objects can be read() or write() ** ",{"type":"list"}," list of double values read from sensor device ",{"type":"list"}," collection of Student records ",{"type":"list"}," because they refer to memory addresses within a process instance ",{"type":"list"}," and a different process instance might already have used those addresses ",{"type":"list"}," either, write()ing chunks of bytes from struct objects ",{"type":"list"}," or, printing formatted text representation of struct data ",{"type":"list"}," no need to worry about formatting issues ",{"type":"list"}," writes entire structure, even if string buffers half empty ",{"type":"list"}," can lseek() to ith struct via i*sizeof(StructType) ",{"type":"list"}," produces files that are human-readable ",{"type":"list"}," only uses as many bytes as required from string buffers ",{"type":"list"}," can access structures only sequentially (unless using padding) ",{"type":"list"}," set the \"current position\" of the FileDesc ",{"type":"list"}," Offset is in units of bytes, and can be negative ",{"type":"list"}," Whence can be one of ... SEEK_SET ... set file position to Offset from start of file SEEK_CUR ... set file position to Offset from current position SEEK_END ... set file position to Offset from end of file ",{"type":"list"}," SEEK_SET ... set file position to Offset from start of file ",{"type":"list"}," SEEK_CUR ... set file position to Offset from current position ",{"type":"list"}," SEEK_END ... set file position to Offset from end of file ",{"type":"list"}," seeking beyond end of file leaves a gap which reads as 0's ",{"type":"list"}," seeking back beyond start of file sets position to start of file ",{"type":"list"}," stores meta-data associated with FileName into StatBuf ",{"type":"list"}," information includes inode number, file type + access mode, owner, group size in bytes, storage block size, allocated blocks time of last access/modification/status-change ",{"type":"list"}," inode number, file type + access mode, owner, group ",{"type":"list"}," size in bytes, storage block size, allocated blocks ",{"type":"list"}," time of last access/modification/status-change ",{"type":"list"}," returns -1 and sets errno if meta-data not accessible ",{"type":"list"}," if FileName is a symbolic link, returns info on referenced file ",{"type":"list"}," same as stat() but gets data via an open file descriptor ",{"type":"list"}," same as stat() but doesn't follow symbolic links ",{"type":"list"}," multiple directory entries referencing the same inode ",{"type":"list"}," the two entries must be on the same filesystem ",{"type":"list"}," a file containing the path name of another file ",{"type":"list"}," opening the symlink opens the file being referenced ",{"type":"list"}," create a new directory called PathName with mode Mode ",{"type":"list"}," if PathName is e.g. a/b/c/d all of the directories a, b and c must exist directory c must be writeable to the caller directory d must not already exist ",{"type":"list"}," all of the directories a, b and c must exist ",{"type":"list"}," directory c must be writeable to the caller ",{"type":"list"}," directory d must not already exist ",{"type":"list"}," the new directory contains two initial entries . is a reference to itself .. is a reference to its parent directory ",{"type":"list"}," . is a reference to itself ",{"type":"list"}," .. is a reference to its parent directory ",{"type":"list"}," returns 0 if successful, returns -1 and sets errno otherwise ",{"type":"list"}," ensure that data associated with FileDesc is written to storage ",{"type":"list"}," data \"written\" to a file is initially stored in memory buffers ",{"type":"list"}," eventually, it makes its way onto permanent storage device ",{"type":"list"}," fsync() forces this to happen now ",{"type":"list"}," fsync() is normally called just once at process exit ",{"type":"list"}," file systems normally exist on permanent storage devices ",{"type":"list"}," mount attaches a file system to a specific location in the file hierarchy ",{"type":"list"}," Source is often a storage device (e.g. /dev/disk) ",{"type":"list"}," Source contains a file system (inode table, data chunks) ",{"type":"list"}," Target (aka mount point) is a path in the file hierarchy ",{"type":"list"}," FileSysType specifies a particular layout/drivers ",{"type":"list"}," Flags specify various properties of the filesys (e.g. read-only) ",{"type":"list"}," as an abstraction over physical storage devices (e.g. disks) ",{"type":"list"}," providing named access to chunks of related data (files) ",{"type":"list"}," providing access (sequential/random) to the contents of files ",{"type":"list"}," allowing files to be arranged in a hierarchy of directories ",{"type":"list"}," providing control over access to files and directories ",{"type":"list"}," managing other meta-data associated with files (size, location, ...) ",{"type":"list"}," memory, processes, processor time, i/o devices, networking, ... ",{"type":"list"}," RAM: code (read-only), data (read/write) ",{"type":"list"}," Registers: program counter (PC) and other registers ",{"type":"list"}," other management info, discussed later ",{"type":"list"}," typically not all loaded in RAM at once ",{"type":"list"}," processes can be suspended (waiting) ",{"type":"list"}," restoring a process: load code, data, registers ",{"type":"list"}," the process can use the entire memory ",{"type":"list"}," addresses within process code are absolute ",{"type":"list"}," addreses in proc1 are absolute ",{"type":"list"}," all addresses in proc2 need to be interpreted relative to p1size ",{"type":"list"}," copy code+data to memory, starting at address 0 ",{"type":"list"}," set stack pointer to p1size-4 ",{"type":"list"}," \"fix\" them when process code+data is loaded replace each address in code by addr+p1size ",{"type":"list"}," replace each address in code by addr+p1size ",{"type":"list"}," \"map\" addresses during execution after a memory address is computed in machine code incremement it by p1size before accessing memory requires extra hardware (holding proc2's start address) ",{"type":"list"}," after a memory address is computed in machine code ",{"type":"list"}," incremement it by p1size before accessing memory ",{"type":"list"}," requires extra hardware (holding proc2's start address) ",{"type":"list"}," remember base address for each process (process table) ",{"type":"list"}," when process (re)starts, load base into mapping hardware ",{"type":"list"}," interpret every address addr in program as base+addr ",{"type":"list"}," process can be loaded anywhere in memory without change ",{"type":"list"}," each chunk of process address space has its own base ",{"type":"list"}," each chunk of process address space has its own size ",{"type":"list"}," each chunk of process address space has its own memory location ",{"type":"list"}," call each chunk of address space a page ",{"type":"list"}," all pages are the same size P (PageSize ) ",{"type":"list"}," process memory is spread across ⌈ProcSize/P ⌉ pages ",{"type":"list"}," page i has addresses A in range i*P ≤ A < (i+1)*P ",{"type":"list"}," each process has an array of page entries ",{"type":"list"}," each page entry contains start address of one chunk ",{"type":"list"}," can compute index of relevant page entry by (A / P ) ",{"type":"list"}," can compute offset within page by (A % P ) ",{"type":"list"}," process has (virtual) address space 0..N-1 bytes ",{"type":"list"}," memory has (physical) address space 0..M-1 bytes ",{"type":"list"}," both address spaces partitioned in P byte pages ",{"type":"list"}," process address space contains K = ⌈N/P⌉ pages ",{"type":"list"}," memory address space has L = ⌈M/P⌉ frames ",{"type":"list"}," takes address (Vaddr) in process address space ",{"type":"list"}," returns address (Paddr) in memory address space ",{"type":"list"}," to save space, just store frame number F ",{"type":"list"}," compute physical address via (P * F + Offset) ",{"type":"list"}," don't need to load all of process's pages up-front ",{"type":"list"}," start with a small memory \"footprint\" (e.g. main + stack top) ",{"type":"list"}," load new process address pages into memory as needed ",{"type":"list"}," grow up to the size of the (available) physical memory ",{"type":"list"}," dividing process memory space into fixed-size pages ",{"type":"list"}," on-demand loading of process pages into physical memory ",{"type":"list"}," each page table entry (PTE) contains page status ... Loaded, IsModified, NotLoaded frame number of page (if Loaded) ... maybe others ... (e.g. last accessed time) ",{"type":"list"}," page status ... Loaded, IsModified, NotLoaded ",{"type":"list"}," frame number of page (if Loaded) ",{"type":"list"}," ... maybe others ... (e.g. last accessed time) ",{"type":"list"}," we need ⌈ProcSize /PageSize⌉ entries in this table ",{"type":"list"}," initially has zero pages loaded ",{"type":"list"}," load page containing code for main() ",{"type":"list"}," load page for main()'s stack frame ",{"type":"list"}," load other pages when process references address within page ",{"type":"list"}," in any given window of time, a process is likely to access only a small subset of its pages ",{"type":"list"}," if each process has a relatively small working set, can hold pages for many active processes in memory at same time ",{"type":"list"}," if only need to hold some of process's pages in memory, process address space can be larger than physical memory ",{"type":"list"}," code is loaded from the executable file stored on disk ",{"type":"list"}," global data is also initially loaded from here ",{"type":"list"}," dynamic (heap, stack) data is created in memory ",{"type":"list"}," may need to be removed temporarily from memory (see later) ",{"type":"list"}," thus would also be saved on disk and restored from disk ",{"type":"list"}," exists on disk for the duration of the process's execution ",{"type":"list"}," and only some parts of it are in memory at any given time ",{"type":"list"}," need to ensure minimal reading from / writing to disk ",{"type":"list"}," find a free (unused) page frame in memory and use that ",{"type":"list"}," suspend the requesting process until a page is freed ",{"type":"list"}," replace one of the currently loaded/used pages ",{"type":"list"}," maintain a (priority) queue of processes waiting for pages ",{"type":"list"}," dequeue and schedule the first process on queue when page freed ",{"type":"list"}," if it's been modified since loading, save to disk ** (in the disk-based virtual memory space of the running process) ",{"type":"list"}," grab its frame number and give it to the requestor ",{"type":"list"}," define a \"usefulness\" measure for each frame ",{"type":"list"}," grab the frame with lowest usefulness (e.g. priority queue?) ",{"type":"list"}," best page is one that won't be used again by its process ",{"type":"list"}," prefer pages that are read-only (no need to write to disk) ",{"type":"list"}," prefer pages that are unmodified (no need to write to disk) ",{"type":"list"}," prefer pages that are used by only one process (see later) ",{"type":"list"}," a page not used recently may not be needed again soon ",{"type":"list"}," we replace a page which is soon used again ",{"type":"list"}," this causes us to replace another page ",{"type":"list"}," and the second page is soon used again ...... ",{"type":"list"}," recently used page is likely to be used again soon ",{"type":"list"}," not recently used page is unlikely to be used again soon ",{"type":"list"}," page frames are entered into a queue when loaded ",{"type":"list"}," page replacement uses the frame from the front of the queue ",{"type":"list"}," uses a reference bit for each frame, updated when page is used ",{"type":"list"}," maintains a circular list of allocated frames ",{"type":"list"}," uses a \"clock hand\" which iterates over page frame list skipping and resetting reference bit in all referenced pages ",{"type":"list"}," skipping and resetting reference bit in all referenced pages ",{"type":"list"}," page replacement uses first-found unreferenced frame ",{"type":"list"}," a virtual address space with K pages needs K PT entries ",{"type":"list"}," since K may be large, do not want to store whole PT ",{"type":"list"}," especially since working set tells us n ≪ K needed at once ",{"type":"list"}," several processes include same frame in virtual address space ",{"type":"list"}," holds parts of RAM that are (hopefully) heavily used ",{"type":"list"}," transfers data to/from RAM in blocks (cache blocks) ",{"type":"list"}," memory reference hardware first looks in cache if required address is there, use its contents if not, get it from RAM and put in cache possibly replacing an existing cache block ",{"type":"list"}," if required address is there, use its contents ",{"type":"list"}," if not, get it from RAM and put in cache ",{"type":"list"}," possibly replacing an existing cache block ",{"type":"list"}," replacement strategies have similar issues to virtual memory ",{"type":"list"}," provide specialised hardware (MMU) to do it efficiently ",{"type":"list"}," sometimes located on CPU chip, sometimes separate ",{"type":"list"}," lookup table containing (virtual,physical) address pairs ",{"type":"list"}," multi-tasking provided by all modern operating systems ",{"type":"list"}," control-flow independence each process executes as if the only process running on the machine ",{"type":"list"}," each process executes as if the only process running on the machine ",{"type":"list"}," private address space each process has its own address space (M bytes, addressed 0..M-1) ",{"type":"list"}," each process has its own address space (M bytes, addressed 0..M-1) ",{"type":"list"}," each process uses the CPU until pre-empted or exits ",{"type":"list"}," then another process uses the CPU until it too is pre-empted ",{"type":"list"}," eventually, the first process will get another run on the CPU ",{"type":"list"}," it runs \"long enough\" and the OS replaces it by a waiting process ",{"type":"list"}," it attempts to perform a long-duration task, like i/o ",{"type":"list"}," the process's entire dynamic state must be saved (incl PC) ",{"type":"list"}," the process is flagged as temporarily suspended ",{"type":"list"}," it is placed on a process (priority) queue for re-start ",{"type":"list"}," static information: program code and data ",{"type":"list"}," dynamic state: heap, stack, registers, program counter ",{"type":"list"}," OS-supplied state: environment variables, stdin, stdout ",{"type":"list"}," save context for one process ",{"type":"list"}," restore context for another process ",{"type":"list"}," identifier: unique process ID ",{"type":"list"}," status: running, ready, suspended, dead ",{"type":"list"}," state: registers (including PC) ",{"type":"list"}," privileges: owner, group ",{"type":"list"}," if suspended, event being waited for ",{"type":"list"}," memory management info: (reference to) page table ",{"type":"list"}," accounting: CPU time used, amount of I/O done ",{"type":"list"}," I/O: open file descriptors ",{"type":"list"}," sh ... for creating processes via object-file name ",{"type":"list"}," ps, w, top ... show process information ",{"type":"list"}," kill ... send a signal to a process ",{"type":"list"}," fork() ... create a new child process (copy of current process) ",{"type":"list"}," execve() ... convert one process into another ",{"type":"list"}," wait() ... wait for state change in child process ",{"type":"list"}," kill() ... send a signal to a process ",{"type":"list"}," _exit() ... terminate an executing process (after clean up) ",{"type":"list"}," pid ...process id, unique among current processes ",{"type":"list"}," ruid, euid ... real and effective user id ",{"type":"list"}," rgid, egid ... real and effective group id ",{"type":"list"}," current working directory ",{"type":"list"}," accumulated execution time (user/kernel) ",{"type":"list"}," user file descriptor table ",{"type":"list"}," information on how to react to signals ",{"type":"list"}," pointer to process page table ",{"type":"list"}," process state ... running, suspended, asleep, etc. ",{"type":"list"}," memory-resident since very heavily used ",{"type":"list"}," contains info as described above for PCB ",{"type":"list"}," content of PCB entry critical for scheduler ",{"type":"list"}," holds info not needed when process swapped out ",{"type":"list"}," e.g. execution state (registers, signal handlers, file descriptors, ...) ",{"type":"list"}," requires #include <unistd.h> ",{"type":"list"}," creates new process by duplicating the calling process ",{"type":"list"}," new process is the child, calling process is the parent ",{"type":"list"}," child has a different process ID (pid) to the parent ",{"type":"list"}," in the child, fork() returns 0 ",{"type":"list"}," in the parent, fork() returns the pid of the child ",{"type":"list"}," if the system call fails, fork() returns -1 ",{"type":"list"}," child inherits copies of parent's address space and open fd's ",{"type":"list"}," a +ve integer, unique among currently executing processes ",{"type":"list"}," with type pid_t (defined in <unistd.h>) ",{"type":"list"}," process 0 is the scheduler (part of kernel) ",{"type":"list"}," process 1 is init (for starting/stopping the system) ",{"type":"list"}," low-numbered processes are typically system-related ",{"type":"list"}," regular processes have PID in the range 300 .. MaxPid (e.g. 216) ",{"type":"list"}," each group is associated with a unique PGID ",{"type":"list"}," groups allow distribution of signals to a set of related processes ",{"type":"list"}," one important application: job control (control-Z) ",{"type":"list"}," requires #include <sys/types.h> ",{"type":"list"}," returns the process ID of the current process ",{"type":"list"}," requires #include <sys/types.h> ",{"type":"list"}," returns the parent process ID of the current process ",{"type":"list"}," a signal can be sent to all processes in a process group ",{"type":"list"}," returns the process group ID of specified process ",{"type":"list"}," if pid is zero, use get PGID of current process ",{"type":"list"}," set the process group ID of specified process ",{"type":"list"}," pause current process until process pid changes state where state changes include finishing, stopping, re-starting, ... ",{"type":"list"}," where state changes include finishing, stopping, re-starting, ... ",{"type":"list"}," ensures that child resources are released on exit ",{"type":"list"}," special values for pid ... if pid = -1, wait on any child process if pid = 0, wait on any child in process group if pid > 0, wait on the specified process ",{"type":"list"}," if pid = -1, wait on any child process ",{"type":"list"}," if pid = 0, wait on any child in process group ",{"type":"list"}," if pid > 0, wait on the specified process ",{"type":"list"}," equivalent to waitpid(-1, &status, 0) ",{"type":"list"}," pauses until one of the child processes terminates ",{"type":"list"}," status is set to hold info about pid e.g. exit status if pid terminated macros allow precise determination of state change (e.g. WIFEXITED(status), WCOREDUMP(status)) ",{"type":"list"}," e.g. exit status if pid terminated ",{"type":"list"}," macros allow precise determination of state change (e.g. WIFEXITED(status), WCOREDUMP(status)) ",{"type":"list"}," options provide variations in waitpid() behaviour default: wait for child process to terminate WNOHANG: return immediately if no child has exited WCONTINUED: return if a stopped child has been restarted ",{"type":"list"}," default: wait for child process to terminate ",{"type":"list"}," WNOHANG: return immediately if no child has exited ",{"type":"list"}," WCONTINUED: return if a stopped child has been restarted ",{"type":"list"}," requires #include <signal.h> ",{"type":"list"}," send signal SigID to process ProcID ",{"type":"list"}," various signals (POSIX) e.g. SIGHUP ... hangup detected on controlling terminal/process SIGINT ... interrupt from keyboard (control-C) SIGKILL ... kill signal (e.g. kill -9) SIGILL ... illegal instruction SIGFPE ... floating point exception (e.g. divide by zero) SIGSEGV ... invalid memory reference SIGPIPE ... broken pipe (no processes reading from pipe) ",{"type":"list"}," SIGHUP ... hangup detected on controlling terminal/process ",{"type":"list"}," SIGINT ... interrupt from keyboard (control-C) ",{"type":"list"}," SIGKILL ... kill signal (e.g. kill -9) ",{"type":"list"}," SIGILL ... illegal instruction ",{"type":"list"}," SIGFPE ... floating point exception (e.g. divide by zero) ",{"type":"list"}," SIGSEGV ... invalid memory reference ",{"type":"list"}," SIGPIPE ... broken pipe (no processes reading from pipe) ",{"type":"list"}," if successful, return 0; on error, return -1 and set errno ",{"type":"list"}," terminates current process ",{"type":"list"}," closes any open file descriptors ",{"type":"list"}," a SIGCHLD signal is sent to parent ",{"type":"list"}," returns status to parent (via wait()) ",{"type":"list"}," any child processes are inherited by scheduler (pid=1) ",{"type":"list"}," termination may be delayed waiting for i/o to complete ",{"type":"list"}," terminates current process ",{"type":"list"}," triggers any functions registered as on_exit() ",{"type":"list"}," flushes stdio buffers; closes open FILE *'s ",{"type":"list"}," then behaves like _exit() ",{"type":"list"}," generates SIGABRT signal (normally terminates process) ",{"type":"list"}," closes and flushes stdio streams ",{"type":"list"}," used by the assert() macro ",{"type":"list"}," all processes become zombie until SIGCHLD handled ",{"type":"list"}," parent may be delayed e.g. slow i/o, but usually resolves quickly ",{"type":"list"}," bug in parent that ignores SIGCHLD creates long-term zombies ",{"type":"list"}," note that zombies occupy a slot in the process table ",{"type":"list"}," when parent exits, orphan is assigned pid=1 as its parent ",{"type":"list"}," pid=1 always handles SIGCHLD when process exits ",{"type":"list"}," replaces current process by executing Path object Path must be an executable, binary or script (starting with #!) ",{"type":"list"}," Path must be an executable, binary or script (starting with #!) ",{"type":"list"}," passes arrays of strings to new process both arrays terminated by a NULL pointer element envp[] contains strings of the form key=value ",{"type":"list"}," both arrays terminated by a NULL pointer element ",{"type":"list"}," envp[] contains strings of the form key=value ",{"type":"list"}," much of the state of the original process is lost, e.g. new virtual address space is created, signal handlers reset, ... ",{"type":"list"}," new virtual address space is created, signal handlers reset, ... ",{"type":"list"}," new process inherits open file descriptors from original process ",{"type":"list"}," on error, returns -1 and sets errno ",{"type":"list"}," if successful, does not return ",{"type":"list"}," fetch instruction from memory[PC]; PC++ ",{"type":"list"}," decode and execute instruction if jump-type instruction, PC = new address if regular instruction, carry out operation ",{"type":"list"}," if jump-type instruction, PC = new address ",{"type":"list"}," if regular instruction, carry out operation ",{"type":"list"}," repeat above ",{"type":"list"}," \"unexpected\" conditions occuring during program execution ",{"type":"list"}," which require some form of immediate action (maybe just quit) ",{"type":"list"}," exceptions ... from conditions within an executing program often, fatal to continued execution of program ",{"type":"list"}," often, fatal to continued execution of program ",{"type":"list"}," interrupts ... from events external to the program often, require some action and then execution can continue ",{"type":"list"}," often, require some action and then execution can continue ",{"type":"list"}," process makes system call (e.g. fork()) ",{"type":"list"}," generates an exception which transfers control to system call handler (in privileged mode) carries out system-level operations (e.g. modify process table) then returns control to the process (in user mode) ",{"type":"list"}," transfers control to system call handler (in privileged mode) ",{"type":"list"}," carries out system-level operations (e.g. modify process table) ",{"type":"list"}," then returns control to the process (in user mode) ",{"type":"list"}," from another process via kill() ",{"type":"list"}," from the operating system (e.g. timer) ",{"type":"list"}," from within the process (e.g. system call) ",{"type":"list"}," from a fault in the process (e.g. div-by-zero) ",{"type":"list"}," from a device (e.g. disk read completes) ",{"type":"list"}," using the signal() library function (simple) ",{"type":"list"}," using the sigaction() system call (powerful) ",{"type":"list"}," SIGILL ... illegal instruction (Term by default) ",{"type":"list"}," SIGABRT ... generated by abort() (Core by default) ",{"type":"list"}," SIGFPE ... floating point exception (Core by default) ",{"type":"list"}," SIGSEGV ... invalid memory reference (Core by default) ",{"type":"list"}," SIGINT ... interrupt from keyboard (Term by default) ",{"type":"list"}," SIGPIPE ... broken pipe (Term by default) ",{"type":"list"}," SIGCHLD ... child process stopped or died (Ignored by default) ",{"type":"list"}," SIGTSTP ... stop typed at tty (control-Z) (Stop by default) ",{"type":"list"}," Term ... terminate the process ",{"type":"list"}," Core ... terminate the process, dump core ",{"type":"list"}," Stop ... stop the process ",{"type":"list"}," Cont ... continue the process if currently stopped ",{"type":"list"}," knows which signal it was invoked by ",{"type":"list"}," needs to ensure that invoking signal (at least) is blocked ",{"type":"list"}," carries out appropriate action; may return ",{"type":"list"}," define how to handle a particular signal ",{"type":"list"}," requires <signal.h> (library function, not syscall) ",{"type":"list"}," SigID is one of the OS-defined signals e.g. SIGHUP, SIGCHLD, SIGSEGV, ... but not SIGKILL, SIGSTOP ",{"type":"list"}," e.g. SIGHUP, SIGCHLD, SIGSEGV, ... but not SIGKILL, SIGSTOP ",{"type":"list"}," Handler can be one of ... SIG_IGN ... ignore signals of type SigID SIG_DFL ... use default handler for SigID a user-defined function to handle SigID signals ",{"type":"list"}," SIG_IGN ... ignore signals of type SigID ",{"type":"list"}," SIG_DFL ... use default handler for SigID ",{"type":"list"}," a user-defined function to handle SigID signals ",{"type":"list"}," note: typedef void (*SigHnd)(int); ",{"type":"list"}," returns previous value of signal handler, or SIG_ERR ",{"type":"list"}," sigID is one of the OS-defined signals e.g. SIGHUP, SIGCHLD, SIGSEGV, ... but not SIGKILL, SIGSTOP ",{"type":"list"}," e.g. SIGHUP, SIGCHLD, SIGSEGV, ... but not SIGKILL, SIGSTOP ",{"type":"list"}," newAct defines how signal should be handled ",{"type":"list"}," oldAct saves a copy of how signal was handled ",{"type":"list"}," if newAct.sa_handler == SIG_IGN, signal is ignored ",{"type":"list"}," if newAct.sa_handler == SIG_DFL, default handler is used ",{"type":"list"}," on success, returns 0; on error, returns -1 and sets errno ",{"type":"list"}," void (*sa_handler)(int) pointer to a handler function, or SIG_IGN or SIG_DFL ",{"type":"list"}," pointer to a handler function, or SIG_IGN or SIG_DFL ",{"type":"list"}," void (*sa_sigaction)(int, siginfo_t *, void *) pointer to handler function; used if SA_SIGINFO flag is set allows more context info to be passed to handler ",{"type":"list"}," pointer to handler function; used if SA_SIGINFO flag is set ",{"type":"list"}," allows more context info to be passed to handler ",{"type":"list"}," sigset_t sa_mask a mask, where each bit specifies a signal to be blocked ",{"type":"list"}," a mask, where each bit specifies a signal to be blocked ",{"type":"list"}," int sa_flags flags to modify how signal is treated (e.g. don't block signal in its own handler) ",{"type":"list"}," flags to modify how signal is treated (e.g. don't block signal in its own handler) ",{"type":"list"}," si_signo ... signal being handled ",{"type":"list"}," si_errno ... any errno value associated with signal ",{"type":"list"}," si_pid ... process ID of sending process ",{"type":"list"}," si_uid ... user ID of owner of sending process ",{"type":"list"}," si_status ... exit value for process termination ",{"type":"list"}," etc. etc. etc. ",{"type":"list"}," cause normal process execution to be suspended ",{"type":"list"}," an interrupt handler then carries out tasks related to interrupt ",{"type":"list"}," control is then returned to the original process ",{"type":"list"}," process requests data from disk (will take 100ms) ",{"type":"list"}," if process can do other work not related to requested data keep executing ... ",{"type":"list"}," keep executing ... ",{"type":"list"}," when data fetched from disk, process is interrupted ",{"type":"list"}," handler places data in a buffer for access by process ",{"type":"list"}," in-memory computation resumes ",{"type":"list"}," process runs for a while (normal control flow) ",{"type":"list"}," receives a timer signal from the O/S ",{"type":"list"}," process is suspended and its state is saved ",{"type":"list"}," process is eventually added to runnable queue ",{"type":"list"}," removed from front of queue and state restored ",{"type":"list"}," process continues from where it was suspended ",{"type":"list"}," in-memory computations are very fast (ns) ",{"type":"list"}," input/output operations are very slow (ms) ",{"type":"list"}," suspend and place on \"waiting for i/o\" queue ",{"type":"list"}," when i/o complete, move process to \"runnable\" queue ",{"type":"list"}," eventually, process resumes, with new data available ",{"type":"list"}," unexpected conditions which arise during computation ",{"type":"list"}," unexpected but not unanticipated (robust code) ",{"type":"list"}," create() a data structure using multiple malloc()s ",{"type":"list"}," part-way through function, one malloc() fails ",{"type":"list"}," if abandoning create(), need to clean up previous malloc()s ",{"type":"list"}," if terminating the entire process, no need to clean up ",{"type":"list"}," processes are not necessarily executing simultaneously although this could happen if there are multiple CPUs ",{"type":"list"}," although this could happen if there are multiple CPUs ",{"type":"list"}," more likely, have a mixture of processes some are blocked waiting on a signal (e.g. i/o completion) some are runnable (ready to execute) one is running (on each CPU) ",{"type":"list"}," some are blocked waiting on a signal (e.g. i/o completion) ",{"type":"list"}," some are runnable (ready to execute) ",{"type":"list"}," one is running (on each CPU) ",{"type":"list"}," by switching process after one runs for a defined time slice ",{"type":"list"}," after timer counts down, current process is pre-empted ",{"type":"list"}," a new process is selected to run by the system scheduler ",{"type":"list"}," processes are organised into priority queue(s) where \"highest\" priority process is always at head of queue ",{"type":"list"}," where \"highest\" priority process is always at head of queue ",{"type":"list"}," priority determined by multiple factors, e.g. system processes have higher priority than user processes longer-running processes might have lower priority memory-intensive processes might have lower priority processes can also suggest their own priority ",{"type":"list"}," system processes have higher priority than user processes ",{"type":"list"}," longer-running processes might have lower priority ",{"type":"list"}," memory-intensive processes might have lower priority ",{"type":"list"}," processes can also suggest their own priority ",{"type":"list"}," is priority-based (priority queue of processes) ",{"type":"list"}," Linux process priorities are values in range -20..139 ",{"type":"list"}," lower values represent higher priority ",{"type":"list"}," factors in determining priority user processes have lower priority than system processes processes have niceness value -20 (highest) .. +20 (lowest) recent CPU time usage by the process ",{"type":"list"}," user processes have lower priority than system processes ",{"type":"list"}," processes have niceness value -20 (highest) .. +20 (lowest) ",{"type":"list"}," recent CPU time usage by the process ",{"type":"list"}," scheduler chooses highest priority process from runnable ",{"type":"list"}," allow programs to communicate with \"the outside\" world ",{"type":"list"}," have significantly different characteristics to memory-based data ",{"type":"list"}," fast (ns) random access via (virtual) address ",{"type":"list"}," transfer data in units of bytes, halfwords, words ",{"type":"list"}," much slower (ms) access, random or sequential ",{"type":"list"}," often, transfer data in blocks (e.g. 128B, 512B, 4KB, ...) ",{"type":"list"}," address specified by track and sector (s/t ≅ 200, s.size 512B) ",{"type":"list"}," access time (move to track + wait for sector + read block) ",{"type":"list"}," high capacity (GB), high cost, reading faster than writing ",{"type":"list"}," pages 512B..4KB, blocks 32..128 pages, R/W page-at-a-time ",{"type":"list"}," pages updated by erase then write, limit on #updates ",{"type":"list"}," avg read time 11×10-6 sec, avg write time 15×10-6 sec ",{"type":"list"}," destination specified by IP address, packet size < 1KB ",{"type":"list"}," transfer time includes dT transmission delay ... time to push data packet onto \"the wire\" dP propagation delay ... time for packet to travel along \"the wire\" dC processing delay ... time to check header, re-route to next node dQ queueing delay ... time waiting on node before transmission need to calculate for N hops, so ≅ N(dT + dP + dC + dQ) ",{"type":"list"}," dT transmission delay ... time to push data packet onto \"the wire\" ",{"type":"list"}," dP propagation delay ... time for packet to travel along \"the wire\" ",{"type":"list"}," dC processing delay ... time to check header, re-route to next node ",{"type":"list"}," dQ queueing delay ... time waiting on node before transmission ",{"type":"list"}," need to calculate for N hops, so ≅ N(dT + dP + dC + dQ) ",{"type":"list"}," keyboard ... byte-by-byte input, often line-buffered ",{"type":"list"}," screen ... pixel-array output, typically via GPU ",{"type":"list"}," mouse ... transmit X,Y movement and button presses ",{"type":"list"}," camera ... convert video signal, frame-by-frame, to digital stream ",{"type":"list"}," microphone ... convert analog audio signal to digital stream ",{"type":"list"}," special control and data registers ",{"type":"list"}," locations (buffers) for data to be read/written ",{"type":"list"}," often written in assembler ",{"type":"list"}," are core components of the operating system ",{"type":"list"}," send request for operation (e.g. read, write, get status) ",{"type":"list"}," receive interrupt when request is completed ",{"type":"list"}," operating system defines special memory address ",{"type":"list"}," user programs perform i/o by getting/putting data into memory ",{"type":"list"}," virtual memory addresses are associated with data buffers of i/o device control registers of i/o device ",{"type":"list"}," data buffers of i/o device ",{"type":"list"}," control registers of i/o device ",{"type":"list"}," uses existing memory access logic cirucits ⇒ less hardware ",{"type":"list"}," can use full range of CPU operations on device memory (cf. having limited set of special instructions to manipulate i/o devices) ",{"type":"list"}," /dev/diskN ... (part of) a hard drive ",{"type":"list"}," /dev/ttyN ... a terminal device ",{"type":"list"}," /dev/ptyN ... a pseudo-terminal device ",{"type":"list"}," /dev/mem ... the physical memory (mostly protected) ",{"type":"list"}," /dev/null ... data sink or empty source ",{"type":"list"}," /dev/random ... stream of pseudo-random numbers ",{"type":"list"}," provide unbuffered direct access to hardware devices ",{"type":"list"}," programmers interact with device by writing individual bytes ",{"type":"list"}," do not necessarily provide byte-by-byte hardware i/o (e.g. disks) ",{"type":"list"}," provide buffered access to hardware devices ",{"type":"list"}," programmers interact with device by writing chunks of bytes ",{"type":"list"}," data transferred to device via operating system buffers ",{"type":"list"}," manipulates parameters of special files (behind open FileDesc) ",{"type":"list"}," Request is a device-specific request code, ",{"type":"list"}," Arg is either an integer modifier or pointer to data block ",{"type":"list"}," requires #include <sys/ioctl.h>, returns 0 if ok, -1 if error ",{"type":"list"}," HDIO_GETGEO ... get disk info in (heads,sectors,cylinders,...) ",{"type":"list"}," BLKGETSIZE ... get device size in sectors ",{"type":"list"}," in both cases, Arg is a pointer to an appropriate object ",{"type":"list"}," attempts to open device PathName in mode Flags ",{"type":"list"}," Flags can specify caching, async i/o, close on exec(), etc. ",{"type":"list"}," returns file descriptor if ok, -1 (plus errno) if error ",{"type":"list"}," attempts to read Nbytes of data into Buf from FDesc ",{"type":"list"}," returns # bytes actually read, 0 at EOF, -1 (plus errno) if error ",{"type":"list"}," attempts to write Nbytes of data from Buf to FDesc ",{"type":"list"}," returns # bytes actually written, -1 (plus errno) if error ",{"type":"list"}," OS uses a collection of buffers to hold data from devices ",{"type":"list"}," data is supplied to user programs normally from buffer ",{"type":"list"}," sometimes (infrequently?) need to access device ",{"type":"list"}," it is slow because of the context switch each time it is called ",{"type":"list"}," from tty-like devices, generally line buffered ",{"type":"list"}," from disk-like devices (files), read/written in BUFSIZ chunks via OS buffers, so may not need disk access each time ",{"type":"list"}," via OS buffers, so may not need disk access each time ",{"type":"list"}," buffering hidden from user, who sees getchar(), fgets(), etc. ",{"type":"list"}," buffer is allocated by fopen(), removed by fclose() ",{"type":"list"}," contains the buffer, malloc'd on fopen() ",{"type":"list"}," contains current position within the buffer and file ",{"type":"list"}," etc. etc. "]}