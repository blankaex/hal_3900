{"allTables":[{"tableRows":[{"text":"Instruction Set Architectures"}]},{"tableRows":[{"text":"CPU Architecture2/114"}]},{"tableRows":[{"text":"Why Study Assembler?3/114"}]},{"tableRows":[{"text":"Instruction Sets4/114"}]},{"tableRows":[{"text":"... Instruction Sets5/114"}]},{"tableRows":[{"text":"... Instruction Sets6/114"}]},{"tableRows":[{"text":"... Instruction Sets7/114"}]},{"tableRows":[{"text":"... Instruction Sets8/114"}]},{"tableRows":[{"text":"Fetch-Execute Cycle9/114"}]},{"tableRows":[{"text":"... Fetch-Execute Cycle10/114"}]},{"tableRows":[{"text":"Assembly Language11/114"}]},{"tableRows":[{"text":"... Assembly Language12/114"}]},{"tableRows":[{"text":"MIPS Architecture13/114"}]},{"tableRows":[{"text":"MIPS vs SPIM14/114"}]},{"tableRows":[{"text":"Using SPIM15/114"}]},{"tableRows":[{"text":"... Using SPIM16/114"}]},{"tableRows":[{"text":"... Using SPIM17/114"}]},{"tableRows":[{"text":"MIPS Machine Archtecture18/114"}]},{"tableRows":[{"text":"... MIPS Machine Archtecture19/114"}]},{"tableRows":[{"text":"Reg Name Notes"},{"text":" $0 zero the value 0, not changeable "},{"text":" $1 $at assembler temporary; used to implement pseudo-ops "},{"text":" $2 $v0 value from expression evaluation or function return "},{"text":" $3 $v1 value from expression evaluation or function return "},{"text":" $4 $a0 first argument to a function/subroutine, if needed "},{"text":" $5 $a1 second argument to a function/subroutine, if needed "},{"text":" $6 $a2 third argument to a function/subroutine, if needed "},{"text":" $7 $a3 fourth argument to a function/subroutine, if needed "},{"text":" $8..$15 $t0..$t7 temporary; must be saved by caller to subroutine;subroutine can overwrite "}]},{"tableRows":[{"text":"... MIPS Machine Archtecture20/114"}]},{"tableRows":[{"text":"Reg Name Notes"},{"text":" $16..$23 $s0..$s7 safe function variable;must not be overwritten by called subroutine "},{"text":" $24..$25 $t8..$t9 temporary; must be saved by caller to subroutine;subroutine can overwrite "},{"text":" $26..$27 $k0..$k1 for kernel use; may change unexpectedly "},{"text":" $28 $gp global pointer "},{"text":" $29 $sp stack pointer "},{"text":" $30 $fp frame pointer "},{"text":" $31 $ra return address of most recent caller "}]},{"tableRows":[{"text":"... MIPS Machine Archtecture21/114"}]},{"tableRows":[{"text":"Reg Notes"},{"text":" "},{"text":" $f0..$f2 hold floating-point function results "},{"text":" $f4..$f10 temporary registers; not preserved across function calls "},{"text":" $f12..$f14 used for first two double-precision function arguments "},{"text":" $f16..$f18 temporary registers; used for expression evaluation "},{"text":" $f20..$f30 saved registers; value is preserved across function calls "}]},{"tableRows":[{"text":"MIPS Assembly Language22/114"}]},{"tableRows":[{"text":"... MIPS Assembly Language23/114"}]},{"tableRows":[{"text":"... MIPS Assembly Language24/114"}]},{"tableRows":[{"text":"... MIPS Assembly Language25/114"}]},{"tableRows":[{"text":"... MIPS Assembly Language26/114"}]},{"tableRows":[{"text":"Region Address Notes"},{"text":" text 0x00400000 contains only instructions; read-only; cannot expand "},{"text":" data 0x10000000 data objects; readable/writeable; can be expanded "},{"text":" stack 0x7fffefff grows down from that address; readable/writeable "},{"text":" k_text 0x80000000 kernel code; read-only; only accessible kernel mode "},{"text":" k_data 0x90000000 kernel data; read/write; only accessible kernel mode "}]},{"tableRows":[{"text":"MIPS Instructions27/114"}]},{"tableRows":[{"text":"... MIPS Instructions28/114"}]},{"tableRows":[{"text":"Addressing Modes29/114"}]},{"tableRows":[{"text":"... Addressing Modes30/114"}]},{"tableRows":[{"text":"Format Address computation"},{"text":" (register) address = *register = contents of register "},{"text":" k address = k "},{"text":" k(register) address = k + *register "},{"text":" symbol address = &symbol = address of symbol "},{"text":" symbol ± k address = &symbol ± k "},{"text":" symbol ± k(register) address = &symbol ± (k + *register) "}]},{"tableRows":[{"text":"... Addressing Modes31/114"}]},{"tableRows":[{"text":"Operand Sizes32/114"}]},{"tableRows":[{"text":"MIPS Instruction Set33/114"}]},{"tableRows":[{"text":"... MIPS Instruction Set34/114"}]},{"tableRows":[{"text":"SyntaxSemantics"},{"text":" $Reg as source, the content of the register, reg[Reg]"},{"text":" $Reg as destination, value is stored in register, reg[Reg] = value"},{"text":" Label references the associated address (in C terms, &Label) "},{"text":" Addr any expression that yields an address (e.g. Label($Reg)) "},{"text":" Addr as source, the content of memory cell memory[Addr]"},{"text":" Addr as destination, value is stored in memory[Addr] = value"}]},{"tableRows":[{"text":"... MIPS Instruction Set35/114"}]},{"tableRows":[{"text":"... MIPS Instruction Set36/114"}]},{"tableRows":[{"text":"... MIPS Instruction Set37/114"}]},{"tableRows":[{"text":"... MIPS Instruction Set38/114"}]},{"tableRows":[{"text":"... MIPS Instruction Set39/114"}]},{"tableRows":[{"text":"ServiceCodeArgumentsResult"},{"text":" print_int1$a0 = integer "},{"text":" print_float2$f12 = float "},{"text":" print_double3$f12 = double "},{"text":" print_string4$a0 = char * "},{"text":" read_int5 integer in $v0 "},{"text":" read_float6 float in $f0 "},{"text":" read_double7 double in $f0 "},{"text":" read_string8$a0 = buffer, $a1 = lengthstring in buffer (including \"\\n\\0\") "}]},{"tableRows":[{"text":"... MIPS Instruction Set40/114"}]},{"tableRows":[{"text":"MIPS Programming41/114"}]},{"tableRows":[{"text":"... MIPS Programming42/114"}]},{"tableRows":[{"text":"... MIPS Programming43/114"}]},{"tableRows":[{"text":"... MIPS Programming44/114"}]},{"tableRows":[{"text":"... MIPS Programming45/114"}]},{"tableRows":[{"text":"Rendering C in MIPS46/114"}]},{"tableRows":[{"text":"... Rendering C in MIPS47/114"}]},{"tableRows":[{"text":"Arithmetic Expressions48/114"}]},{"tableRows":[{"text":"Conditional Statements49/114"}]},{"tableRows":[{"text":"... Conditional Statements50/114"}]},{"tableRows":[{"text":"... Conditional Statements51/114"}]},{"tableRows":[{"text":"... Conditional Statements52/114"}]},{"tableRows":[{"text":"... Conditional Statements53/114"}]},{"tableRows":[{"text":"Boolean Expressions54/114"}]},{"tableRows":[{"text":"... Boolean Expressions55/114"}]},{"tableRows":[{"text":"Iteration Statements56/114"}]},{"tableRows":[{"text":"... Iteration Statements57/114"}]},{"tableRows":[{"text":"Functions58/114"}]},{"tableRows":[{"text":"... Functions59/114"}]},{"tableRows":[{"text":"... Functions60/114"}]},{"tableRows":[{"text":"... Functions61/114"}]},{"tableRows":[{"text":"... Functions62/114"}]},{"tableRows":[{"text":"... Functions63/114"}]},{"tableRows":[{"text":"Aside: MIPS Branch Delay Slots64/114"}]},{"tableRows":[{"text":"Aside: Why do we need both $fp and $sp?65/114"}]},{"tableRows":[{"text":"Function Calling Protocol66/114"}]},{"tableRows":[{"text":"... Function Calling Protocol67/114"}]},{"tableRows":[{"text":"... Function Calling Protocol68/114"}]},{"tableRows":[{"text":"... Function Calling Protocol69/114"}]},{"tableRows":[{"text":"... Function Calling Protocol70/114"}]},{"tableRows":[{"text":"... Function Calling Protocol71/114"}]},{"tableRows":[{"text":"... Function Calling Protocol72/114"}]},{"tableRows":[{"text":"Structure of Functions73/114"}]},{"tableRows":[{"text":"Function Prologue74/114"}]},{"tableRows":[{"text":"... Function Prologue75/114"}]},{"tableRows":[{"text":"... Function Prologue76/114"}]},{"tableRows":[{"text":"... Function Prologue77/114"}]},{"tableRows":[{"text":"Function Epilogue78/114"}]},{"tableRows":[{"text":"... Function Epilogue79/114"}]},{"tableRows":[{"text":"Data Structures and MIPS80/114"}]},{"tableRows":[{"text":"Static vs Dynamic Allocation81/114"}]},{"tableRows":[{"text":"... Static vs Dynamic Allocation82/114"}]},{"tableRows":[{"text":"... Static vs Dynamic Allocation83/114"}]},{"tableRows":[{"text":"... Static vs Dynamic Allocation84/114"}]},{"tableRows":[{"text":"... Static vs Dynamic Allocation85/114"}]},{"tableRows":[{"text":"... Static vs Dynamic Allocation86/114"}]},{"tableRows":[{"text":"1-d Arrays in MIPS87/114"}]},{"tableRows":[{"text":"... 1-d Arrays in MIPS88/114"}]},{"tableRows":[{"text":"... 1-d Arrays in MIPS89/114"}]},{"tableRows":[{"text":"... 1-d Arrays in MIPS90/114"}]},{"tableRows":[{"text":"2-d Arrays in MIPS91/114"}]},{"tableRows":[{"text":"... 2-d Arrays in MIPS92/114"}]},{"tableRows":[{"text":"... 2-d Arrays in MIPS93/114"}]},{"tableRows":[{"text":"... 2-d Arrays in MIPS94/114"}]},{"tableRows":[{"text":"... 2-d Arrays in MIPS95/114"}]},{"tableRows":[{"text":"Structs in MIPS96/114"}]},{"tableRows":[{"text":"... Structs in MIPS97/114"}]},{"tableRows":[{"text":"... Structs in MIPS98/114"}]},{"tableRows":[{"text":"... Structs in MIPS99/114"}]},{"tableRows":[{"text":"... Structs in MIPS100/114"}]},{"tableRows":[{"text":"... Structs in MIPS101/114"}]},{"tableRows":[{"text":"... Structs in MIPS102/114"}]},{"tableRows":[{"text":"Compiling C to MIPS103/114"}]},{"tableRows":[{"text":"C Pre-processor104/114"}]},{"tableRows":[{"text":"... C Pre-processor105/114"}]},{"tableRows":[{"text":"C Parser106/114"}]},{"tableRows":[{"text":"Symbol Table Management107/114"}]},{"tableRows":[{"text":"Local Variables108/114"}]},{"tableRows":[{"text":"Expression Evaluation109/114"}]},{"tableRows":[{"text":"Mapping Control Structures110/114"}]},{"tableRows":[{"text":"... Mapping Control Structures111/114"}]},{"tableRows":[{"text":" Argc and Argv112/114"}]},{"tableRows":[{"text":"... Argc and Argv113/114"}]},{"tableRows":[{"text":"... Argc and Argv114/114"}]}],"allParagraphs":[{"text":"C: Assembly Language (MIPS)"},{"text":" "},{"text":""},{"text":" Instruction Set Architectures "},{"text":" "},{"text":""},{"text":" CPU Architecture2/114 "},{"text":" A typical modern CPU has "},{"text":""},{"text":" Why Study Assembler?3/114 "},{"text":" Useful to know assembly language because ... "},{"text":""},{"text":" Instruction Sets4/114 "},{"text":" Two broad families of instruction set architectures ... "},{"text":" RISC (reduced instruction set computer) "},{"text":""},{"text":" ... Instruction Sets5/114 "},{"text":" Machine-level instructions ... "},{"text":""},{"text":" "},{"text":" Operands and destination are typically registers "},{"text":""},{"text":" ... Instruction Sets6/114 "},{"text":" Common kinds of instructions (not from any real machine) "},{"text":""},{"text":" ... Instruction Sets7/114 "},{"text":" Other common kinds of instructions (not from any real machine) "},{"text":""},{"text":" ... Instruction Sets8/114 "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" Fetch-Execute Cycle9/114 "},{"text":" All CPUs have program execution logic like: "},{"text":""},{"text":" PC = Program Counter, a CPU register which keeps track of execution "},{"text":" Note that some instructions may modify PC further (e.g. JUMP) "},{"text":""},{"text":" ... Fetch-Execute Cycle10/114 "},{"text":" Executing an instruction involves "},{"text":""},{"text":" "},{"text":""},{"text":" Assembly Language11/114 "},{"text":" Instructions are simply bit patterns within a 32-bit bit-string "},{"text":" Could describe machine programs as a sequence of hex digits, e.g. "},{"text":""},{"text":" "},{"text":" Often call \"assembly language\" as \"assembler\" "},{"text":" Slight notational abuse, because \"assembler\" also refers to a program that translates assembly language to machine code "},{"text":""},{"text":" ... Assembly Language12/114 "},{"text":" Assembler = symbolic language for writing machine code "},{"text":""},{"text":" MIPS Architecture13/114 "},{"text":" MIPS is a well-known and relatively simple architecture "},{"text":" Source code for browsing under /home/cs1521/spim/spim "},{"text":""},{"text":" MIPS vs SPIM14/114 "},{"text":" MIPS is a machine architecture, including instruction set "},{"text":" SPIM is an emulator for the MIPS instruction set "},{"text":""},{"text":" Using SPIM15/114 "},{"text":" Three ways to execute MIPS code with SPIM "},{"text":""},{"text":" ... Using SPIM16/114 "},{"text":" Command-line tool: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Using SPIM17/114 "},{"text":" GUI tool: "},{"text":""},{"text":" "},{"text":""},{"text":" MIPS Machine Archtecture18/114 "},{"text":" MIPS CPU has "},{"text":" Some registers have special uses e.g. "},{"text":""},{"text":" ... MIPS Machine Archtecture19/114 "},{"text":" Registers and their usage "},{"text":" Reg Name Notes $0 zero the value 0, not changeable $1 $at assembler temporary; used to implement pseudo-ops $2 $v0 value from expression evaluation or function return $3 $v1 value from expression evaluation or function return $4 $a0 first argument to a function/subroutine, if needed $5 $a1 second argument to a function/subroutine, if needed $6 $a2 third argument to a function/subroutine, if needed $7 $a3 fourth argument to a function/subroutine, if needed $8..$15 $t0..$t7 temporary; must be saved by caller to subroutine;subroutine can overwrite "},{"text":""},{"text":" ... MIPS Machine Archtecture20/114 "},{"text":" More register usage ... "},{"text":" Reg Name Notes $16..$23 $s0..$s7 safe function variable;must not be overwritten by called subroutine $24..$25 $t8..$t9 temporary; must be saved by caller to subroutine;subroutine can overwrite $26..$27 $k0..$k1 for kernel use; may change unexpectedly $28 $gp global pointer $29 $sp stack pointer $30 $fp frame pointer $31 $ra return address of most recent caller "},{"text":""},{"text":" ... MIPS Machine Archtecture21/114 "},{"text":" Floating point register usage ... "},{"text":" Reg Notes $f0..$f2 hold floating-point function results $f4..$f10 temporary registers; not preserved across function calls $f12..$f14 used for first two double-precision function arguments $f16..$f18 temporary registers; used for expression evaluation $f20..$f30 saved registers; value is preserved across function calls "},{"text":" Notes: "},{"text":""},{"text":" MIPS Assembly Language22/114 "},{"text":" MIPS assembly language programs contain "},{"text":""},{"text":" ... MIPS Assembly Language23/114 "},{"text":" Example MIPS assembler program: "},{"text":""},{"text":" Color coding: label, directive, comment "},{"text":""},{"text":" ... MIPS Assembly Language24/114 "},{"text":" Generic structure of MIPS programs "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Assembly Language25/114 "},{"text":" Another example MIPS assembler program: "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Assembly Language26/114 "},{"text":" MIPS programs assume the following memory layout "},{"text":" Region Address Notes text 0x00400000 contains only instructions; read-only; cannot expand data 0x10000000 data objects; readable/writeable; can be expanded stack 0x7fffefff grows down from that address; readable/writeable k_text 0x80000000 kernel code; read-only; only accessible kernel mode k_data 0x90000000 kernel data; read/write; only accessible kernel mode "},{"text":""},{"text":" MIPS Instructions27/114 "},{"text":" MIPS has several classes of instructions: "},{"text":""},{"text":" ... MIPS Instructions28/114 "},{"text":" MIPS instructions are 32-bits long, and specify ... "},{"text":""},{"text":" "},{"text":""},{"text":" Addressing Modes29/114 "},{"text":" Memory addresses can be given by "},{"text":""},{"text":" If $s0 contains 0x10000000 and &var = 0x100000008 "},{"text":""},{"text":" ... Addressing Modes30/114 "},{"text":" Addressing modes in MIPS "},{"text":" Format Address computation (register) address = *register = contents of register k address = k k(register) address = k + *register symbol address = &symbol = address of symbol symbol ± k address = &symbol ± k symbol ± k(register) address = &symbol ± (k + *register) "},{"text":" where k is a literal constant value (e.g. 4 or 0x10000000) "},{"text":""},{"text":" ... Addressing Modes31/114 "},{"text":" Examples of load/store and addressing: "},{"text":""},{"text":" "},{"text":""},{"text":" Operand Sizes32/114 "},{"text":" MIPS instructions can manipulate different-sized operands "},{"text":" Leads to many opcodes for a (conceptually) single operation, e.g. "},{"text":""},{"text":" MIPS Instruction Set33/114 "},{"text":" The MIPS processor implements a base set of instructions, e.g. "},{"text":""},{"text":" Note: use of $at register for intermediate results "},{"text":""},{"text":" ... MIPS Instruction Set34/114 "},{"text":" In describing instructions: "},{"text":" SyntaxSemantics $Reg as source, the content of the register, reg[Reg] $Reg as destination, value is stored in register, reg[Reg] = value Label references the associated address (in C terms, &Label) Addr any expression that yields an address (e.g. Label($Reg)) Addr as source, the content of memory cell memory[Addr] Addr as destination, value is stored in memory[Addr] = value "},{"text":" Effectively ... "},{"text":""},{"text":" ... MIPS Instruction Set35/114 "},{"text":" Examples of data movement instructions: "},{"text":""},{"text":" Examples of bit manipulation instructions: "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Instruction Set36/114 "},{"text":" Examples of arithmetic instructions: "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Instruction Set37/114 "},{"text":" Examples of testing and branching instructions: "},{"text":""},{"text":" After each branch instruction, execution continues at new PC location "},{"text":""},{"text":" ... MIPS Instruction Set38/114 "},{"text":" Special jump instruction for invoking functions "},{"text":""},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Instruction Set39/114 "},{"text":" SPIM interacts with stdin/stdout via syscalls "},{"text":" ServiceCodeArgumentsResult print_int1$a0 = integer print_float2$f12 = float print_double3$f12 = double print_string4$a0 = char * read_int5 integer in $v0 read_float6 float in $f0 read_double7 double in $f0 read_string8$a0 = buffer, $a1 = lengthstring in buffer (including \"\\n\\0\") "},{"text":""},{"text":" ... MIPS Instruction Set40/114 "},{"text":" Directives (instructions to assembler, not MIPS instructions) "},{"text":""},{"text":" "},{"text":""},{"text":" MIPS Programming41/114 "},{"text":" Writing directly in MIPS assembler is difficult (impossible?) "},{"text":" Strategy for producing likely correct MIPS code "},{"text":""},{"text":" ... MIPS Programming42/114 "},{"text":" Example translating C to MIPS: "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Programming43/114 "},{"text":" Simplified C makes extensive use of "},{"text":""},{"text":" "},{"text":""},{"text":" ... MIPS Programming44/114 "},{"text":" Beware: registers are shared by all parts of the code. "},{"text":" One function can overwrite value set by another function "},{"text":""},{"text":" After the function, x == 6 and y == 120 "},{"text":" It is sheer coincidence that y has the correct value. "},{"text":""},{"text":" ... MIPS Programming45/114 "},{"text":" Need to be careful managing registers "},{"text":""},{"text":" Rendering C in MIPS46/114 "},{"text":" C provides expression evaluation and assignment, e.g. "},{"text":" Sequence is easy S1 ; S2 → mips(S1) mips(S2) "},{"text":""},{"text":" ... Rendering C in MIPS47/114 "},{"text":" Simple example of assignment and sequence: "},{"text":""},{"text":" "},{"text":""},{"text":" Arithmetic Expressions48/114 "},{"text":" Expression evaluation involves "},{"text":""},{"text":" It is useful to minimise the number of registers involved in the evaluation "},{"text":""},{"text":" Conditional Statements49/114 "},{"text":" Conditional statements (e.g. if) "},{"text":""},{"text":" "},{"text":""},{"text":" ... Conditional Statements50/114 "},{"text":" Conditional statements (e.g. if) "},{"text":""},{"text":" "},{"text":""},{"text":" ... Conditional Statements51/114 "},{"text":" Example of if-then-else: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Conditional Statements52/114 "},{"text":" Could make switch by first converting to if "},{"text":""},{"text":" "},{"text":""},{"text":" ... Conditional Statements53/114 "},{"text":" Jump table: an alternative implementation of switch "},{"text":""},{"text":" "},{"text":""},{"text":" Boolean Expressions54/114 "},{"text":" Boolean expressions in C are short circuit "},{"text":" "},{"text":""},{"text":" Evaluates by "},{"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"text":""},{"text":" ... Boolean Expressions55/114 "},{"text":" Similarly for disjunctions "},{"text":" "},{"text":""},{"text":" Evaluates by "},{"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"text":""},{"text":" Iteration Statements56/114 "},{"text":" Iteration (e.g. while) "},{"text":""},{"text":" Treat for as a special case of while "},{"text":""},{"text":" "},{"text":""},{"text":" ... Iteration Statements57/114 "},{"text":" Example of iteration over an array: "},{"text":""},{"text":" "},{"text":""},{"text":" Functions58/114 "},{"text":" When we call a function: "},{"text":""},{"text":" ... Functions59/114 "},{"text":" Data associated with function calls is placed on the MIPS stack. "},{"text":""},{"text":" "},{"text":""},{"text":" ... Functions60/114 "},{"text":" Each function allocates a small section of the stack (a frame) "},{"text":""},{"text":" ... Functions61/114 "},{"text":" How stack changes as functions are called and return: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Functions62/114 "},{"text":" Register usage conventions when f() calls g(): "},{"text":""},{"text":" ... Functions63/114 "},{"text":" Contents of a typical stack frame: "},{"text":""},{"text":" "},{"text":""},{"text":" Aside: MIPS Branch Delay Slots64/114 "},{"text":" The real MIPS architecture is \"pipelined\" to improve efficiency "},{"text":" A problem scenario, and its solution (branch delay slot): "},{"text":""},{"text":" Since SPIM is not pipelined, the nop is not required "},{"text":""},{"text":" Aside: Why do we need both $fp and $sp?65/114 "},{"text":" During execution of a function "},{"text":""},{"text":" "},{"text":""},{"text":" Function Calling Protocol66/114 "},{"text":" Before one function calls another, it needs to "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Calling Protocol67/114 "},{"text":" Example: simple function call "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Calling Protocol68/114 "},{"text":" Simple function call: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Calling Protocol69/114 "},{"text":" Execution of sum() function: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Calling Protocol70/114 "},{"text":" Example: function f() calls function g(a,b,c,d,e,f) "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Calling Protocol71/114 "},{"text":" Function call in MIPS: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Calling Protocol72/114 "},{"text":" Execution of g() function: "},{"text":""},{"text":" "},{"text":""},{"text":" Structure of Functions73/114 "},{"text":" Functions in MIPS have the following general structure: "},{"text":""},{"text":" Aim of prologue: create environment for function to execute in. "},{"text":""},{"text":" Function Prologue74/114 "},{"text":" Before a function starts working, it needs to ... "},{"text":""},{"text":" ... Function Prologue75/114 "},{"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Prologue76/114 "},{"text":" Alternatively ... (more explicit push) "},{"text":""},{"text":" "},{"text":""},{"text":" ... Function Prologue77/114 "},{"text":" Alternatively ... (relative to new $fp) "},{"text":""},{"text":" "},{"text":""},{"text":" Function Epilogue78/114 "},{"text":" Before a function returns, it needs to ... "},{"text":" Changing $fp and $sp ... "},{"text":""},{"text":" ... Function Epilogue79/114 "},{"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"text":""},{"text":" "},{"text":""},{"text":" Data Structures and MIPS80/114 "},{"text":" C data structures and their MIPS representations: "},{"text":""},{"text":" Static vs Dynamic Allocation81/114 "},{"text":" Static allocation: "},{"text":""},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Static vs Dynamic Allocation82/114 "},{"text":" Dynamic allocation (i): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Static vs Dynamic Allocation83/114 "},{"text":" Example of local variables on the stack: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Static vs Dynamic Allocation84/114 "},{"text":" Dynamic allocation (ii): "},{"text":""},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Static vs Dynamic Allocation85/114 "},{"text":" SPIM doesn't provide malloc()/free() functions "},{"text":""},{"text":" Cannot access allocated data by name; need to retain address. "},{"text":" No way to free allocated data, and no way to align data appropriately "},{"text":""},{"text":" ... Static vs Dynamic Allocation86/114 "},{"text":" Implementing C-like malloc() and free() in MIPS requires "},{"text":""},{"text":" "},{"text":""},{"text":" 1-d Arrays in MIPS87/114 "},{"text":" Can be named/initialised as noted above: "},{"text":""},{"text":" Can access elements via index or cursor (pointer) "},{"text":""},{"text":" ... 1-d Arrays in MIPS88/114 "},{"text":" Scanning across an array of N elements using index "},{"text":""},{"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"text":""},{"text":" ... 1-d Arrays in MIPS89/114 "},{"text":" Scanning across an array of N elements using cursor "},{"text":""},{"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"text":""},{"text":" ... 1-d Arrays in MIPS90/114 "},{"text":" Arrays that are local to functions are allocated space on the stack "},{"text":""},{"text":" "},{"text":""},{"text":" 2-d Arrays in MIPS91/114 "},{"text":" 2-d arrays could be represented two ways: "},{"text":""},{"text":" "},{"text":""},{"text":" ... 2-d Arrays in MIPS92/114 "},{"text":" Representations of int matrix[4][4] ... "},{"text":""},{"text":" Now consider summing all elements "},{"text":""},{"text":" "},{"text":""},{"text":" ... 2-d Arrays in MIPS93/114 "},{"text":" Accessing elements: "},{"text":""},{"text":" "},{"text":""},{"text":" ... 2-d Arrays in MIPS94/114 "},{"text":" Computing sum of all elements for strategy (a) int matrix[4][4] "},{"text":""},{"text":" "},{"text":""},{"text":" ... 2-d Arrays in MIPS95/114 "},{"text":" Computing sum of all elements for strategy (b) int matrix[4][4] "},{"text":""},{"text":" "},{"text":""},{"text":" Structs in MIPS96/114 "},{"text":" C structs hold a collection of values accessed by name "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs in MIPS97/114 "},{"text":" C struct definitions effectively define a new type. "},{"text":""},{"text":" Instances of structures can be created by allocating space: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs in MIPS98/114 "},{"text":" Accessing structure components is by offset, not name "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs in MIPS99/114 "},{"text":" Structs that are local to functions are allocated space on the stack "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs in MIPS100/114 "},{"text":" C can pass whole structures to functions, e.g. "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs in MIPS101/114 "},{"text":" Accessing struct within function ... "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs in MIPS102/114 "},{"text":" Can also pass a pointer to a struct "},{"text":""},{"text":" Clearly a more efficient way to pass a large struct "},{"text":" Also, required if the function needs to update the original struct "},{"text":""},{"text":" Compiling C to MIPS103/114 "},{"text":" Using simplified C as an intermediate language "},{"text":""},{"text":" C Pre-processor104/114 "},{"text":" Maps C→C, performing various substitutions "},{"text":""},{"text":" ... C Pre-processor105/114 "},{"text":" More C pre-processor substitions "},{"text":""},{"text":" "},{"text":""},{"text":" C Parser106/114 "},{"text":" Understands syntax of C language "},{"text":" Attempts to convert C program into parse tree "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" Symbol Table Management107/114 "},{"text":" Compiler keeps track of names "},{"text":""},{"text":" "},{"text":""},{"text":" Local Variables108/114 "},{"text":" Two choices for local variables "},{"text":""},{"text":" "},{"text":""},{"text":" Expression Evaluation109/114 "},{"text":" Uses temporary ($t?) registers "},{"text":""},{"text":" Complex boolean expressions handled by short-circuit evaluation. "},{"text":""},{"text":" Mapping Control Structures110/114 "},{"text":" Use templates, e.g. "},{"text":""},{"text":" "},{"text":""},{"text":" ... Mapping Control Structures111/114 "},{"text":" Template for if...else if... else "},{"text":""},{"text":" "},{"text":""},{"text":" Argc and Argv112/114 "},{"text":" The real MIPS machine has no idea about argc and argv "},{"text":" SPIM runs under Linux, and needs to interact with environment "},{"text":" So, the initialisation code (that invokes main) sets them up: "},{"text":""},{"text":" "},{"text":" Note: we are ignoring envp (environment pointer) "},{"text":""},{"text":" ... Argc and Argv113/114 "},{"text":" What the main program receives: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Argc and Argv114/114 "},{"text":" Code to print the program's name (argv[0]): "},{"text":""},{"text":" Code to print the first cmd-line arg (argv[1]) "},{"text":""},{"text":" "},{"text":""},{"text":" Produced: 2 Apr 2018 "}],"allLists":[{"type":"list"}," a set of data registers ",{"type":"list"}," a set of control registers (incl PC) ",{"type":"list"}," an arithmetic-logic unit (ALU) ",{"type":"list"}," access to random access memory (RAM) ",{"type":"list"}," a set of simple instructions transfer data between memory and registers push values through the ALU to compute results make tests and transfer control of execution ",{"type":"list"}," transfer data between memory and registers ",{"type":"list"}," push values through the ALU to compute results ",{"type":"list"}," make tests and transfer control of execution ",{"type":"list"}," e.g. different # registers, different sized registers, different instructions ",{"type":"list"}," sometimes you are required to use it (e.g. device handlers) ",{"type":"list"}," improves your understanding of how C programs execute very helpful when debugging able to avoid using known inefficient constructs ",{"type":"list"}," very helpful when debugging ",{"type":"list"}," able to avoid using known inefficient constructs ",{"type":"list"}," uber-nerdy performance tweaking (squeezing out last nano-s) re-write that critical (frequently-used) function in assembler ",{"type":"list"}," re-write that critical (frequently-used) function in assembler ",{"type":"list"}," small(ish) set of simple, general instructions ",{"type":"list"}," separate computation & data transfer instructions ",{"type":"list"}," leading to simpler processor hardware ",{"type":"list"}," e.g. MIPS, RISC, Alpha, SPARC, PowerPC, ARM, ... ",{"type":"list"}," large(r) set of powerful instructions ",{"type":"list"}," each instruction has multiple actions (comp+store) ",{"type":"list"}," more circuitry to decode/process instructions ",{"type":"list"}," e.g. PDP, VAX, Z80, Motorola 68xxx, Intel x86, ... ",{"type":"list"}," typically have 1-2 32-bit words per instruction ",{"type":"list"}," partition bits in each word into operator & operands ",{"type":"list"}," #bits for each depends on #instructions, #registers, ... ",{"type":"list"}," load Register, MemoryAddress copy value stored in memory at address into named register ",{"type":"list"}," copy value stored in memory at address into named register ",{"type":"list"}," loadc Register, ConstantValue copy value into named register ",{"type":"list"}," copy value into named register ",{"type":"list"}," store Register, MemoryAddress copy value stored in named register into memory at address ",{"type":"list"}," copy value stored in named register into memory at address ",{"type":"list"}," jump MemoryAddress transfer execution of program to instruction at address ",{"type":"list"}," transfer execution of program to instruction at address ",{"type":"list"}," jumpif Register, MemoryAddress transfer execution of program if e.g. register holds zero value ",{"type":"list"}," transfer execution of program if e.g. register holds zero value ",{"type":"list"}," add Register1, Register2, Register3 (similarly for sub, mul, div) Register3 = Register1 + Register2 ",{"type":"list"}," Register3 = Register1 + Register2 ",{"type":"list"}," and Register1, Register2, Register3 (similarly for or, xor) Register3 = Register1 & Register2 ",{"type":"list"}," Register3 = Register1 & Register2 ",{"type":"list"}," neg Register1, Register2 Register2 = ~ Register1 ",{"type":"list"}," Register2 = ~ Register1 ",{"type":"list"}," shiftl Register1, Value, Register2 (similarly for shiftr) Register2 = Register1 << Value ",{"type":"list"}," Register2 = Register1 << Value ",{"type":"list"}," syscall Value invoke a system service; which service determined by Value ",{"type":"list"}," invoke a system service; which service determined by Value ",{"type":"list"}," determine what the operator is ",{"type":"list"}," determine which registers, if any, are involved ",{"type":"list"}," determine which memory location, if any, is involved ",{"type":"list"}," carry out the operation with the relevant operands ",{"type":"list"}," store result, if any, in appropriate register ",{"type":"list"}," write instructions using mnemonics rather than hex codes ",{"type":"list"}," reference registers using either numbers or names ",{"type":"list"}," can associate names to memory addresses ",{"type":"list"}," need to use fine-grained control of memory usage ",{"type":"list"}," required to manipulate data in registers ",{"type":"list"}," control structures programmed via explicit jumps ",{"type":"list"}," very popular in a range of computing devices in the 1990's ",{"type":"list"}," e.g. Silicon Graphics, NEC, Nintendo64, Playstation, supercomputers ",{"type":"list"}," using two variants of the open-source SPIM emulator ",{"type":"list"}," qtspim ... provides a GUI front-end, useful for debugging ",{"type":"list"}," spim ... command-line based version, useful for testing ",{"type":"list"}," xspim ... GUI front-end, useful for debugging, only in CSE labs ",{"type":"list"}," reads text files containing instruction + directives ",{"type":"list"}," converts to machine code and loads into \"memory\" ",{"type":"list"}," provides debugging capabilities single-step, breakpoints, view registers/memory, ... ",{"type":"list"}," single-step, breakpoints, view registers/memory, ... ",{"type":"list"}," provides mechanism to interact with operating system (syscall) ",{"type":"list"}," provide convenient/mnemonic ways to do common operations ",{"type":"list"}," e.g. move $s0,$v0 rather than addu $s0,$0,$v0 ",{"type":"list"}," spim ... command line tool load programs using -file option interact using stdin/stdout via login terminal ",{"type":"list"}," load programs using -file option ",{"type":"list"}," interact using stdin/stdout via login terminal ",{"type":"list"}," qtspim ... GUI environment load programs via a load button interact via a pop-up stdin/stdout terminal ",{"type":"list"}," load programs via a load button ",{"type":"list"}," interact via a pop-up stdin/stdout terminal ",{"type":"list"}," xspim ... GUI environment similar to qtspim, but not as pretty requires X-windows server ",{"type":"list"}," similar to qtspim, but not as pretty ",{"type":"list"}," requires X-windows server ",{"type":"list"}," 32 × 32-bit general purpose registers ",{"type":"list"}," 16 × 64-bit double-precision registers ",{"type":"list"}," PC ... 32-bit register (always aligned on 4-byte boundary) ",{"type":"list"}," HI,LO ... for storing results of multiplication and division ",{"type":"list"}," register $0 always has value 0, cannot be written ",{"type":"list"}," registers $1, $26, $27 reserved for use by system ",{"type":"list"}," registers come in pairs of 2 × 32-bits ",{"type":"list"}," only even registers are addressed for double-precision ",{"type":"list"}," comments ... introduced by # ",{"type":"list"}," labels ... appended with : ",{"type":"list"}," directives ... symbol beginning with . ",{"type":"list"}," assembly language instructions ",{"type":"list"}," data objects that live in the data region ",{"type":"list"}," functions (instruction sequences) that live in the code/text region ",{"type":"list"}," load and store .. transfer data between registers and memory ",{"type":"list"}," computational ... perform arithmetic/logical operations ",{"type":"list"}," jump and branch ... transfer control of program execution ",{"type":"list"}," coprocessor ... standard interface to various co-processors ",{"type":"list"}," special ... miscellaneous tasks (e.g. syscall) ",{"type":"list"}," between memory and register (direct, indirect) ",{"type":"list"}," constant to register (immediate) ",{"type":"list"}," register + register + destination register ",{"type":"list"}," an operation (e.g. load, store, add, branch, ...) ",{"type":"list"}," one or more operands (e.g. registers, memory addresses, constants) ",{"type":"list"}," symbolic name (label) (effectively, a constant) ",{"type":"list"}," indirectly via a register (effectively, pointer dereferencing) ",{"type":"list"}," computed address for a: is 0x100000008 ",{"type":"list"}," computed address for b: is 0x100000000 ",{"type":"list"}," computed address for c: is 0x100000004 ",{"type":"list"}," single bytes, two bytes (\"halfword\"), four bytes (\"word\") ",{"type":"list"}," LB ... load one byte from specified address ",{"type":"list"}," LBU ... load unsigned byte from specified address ",{"type":"list"}," LH ... load two bytes from specified address ",{"type":"list"}," LHU ... load unsigned 2-bytes from specified address ",{"type":"list"}," LW ... load four bytes (one word) from specified address ",{"type":"list"}," LA ... load the specified address ",{"type":"list"}," lw, sw, add, sub, and, or, sll, slt, beq, j, jal, ... ",{"type":"list"}," move, rem, la, li, blt, ... ",{"type":"list"}," treat registers as unsigned int reg[32] ",{"type":"list"}," treat memory as unsigned char mem[232] ",{"type":"list"}," develop the solution in C ",{"type":"list"}," map to \"simplified\" C ",{"type":"list"}," translate each simplified C statement to MIPS instructions ",{"type":"list"}," does not have while, switch, complex expressions ",{"type":"list"}," does have simple if, goto, one-operator expressions ",{"type":"list"}," does not have function calls and auto local variables ",{"type":"list"}," does have jump-and-remember-where-you-came-from ",{"type":"list"}," labels ... symbolic name for C statement ",{"type":"list"}," goto ... transfer control to labelled statement ",{"type":"list"}," follow the conventions implied by register names ",{"type":"list"}," preserve values that need to be saved across function calls ",{"type":"list"}," you manage register usage as you like ",{"type":"list"}," typically making use of $t? registers ",{"type":"list"}," you transfer control to a separate piece of code ",{"type":"list"}," which may change the value of any non-preserved register ",{"type":"list"}," $s? registers must be preserved by function ",{"type":"list"}," $a?, $v?, $t? registers may be modified by function ",{"type":"list"}," x = (1 + y*y) / 2; z = 1.0 / 2; ... ",{"type":"list"}," move Rd,Rs, li Rd,Const, add, div, and, ... ",{"type":"list"}," sequence (;), if, while, for, break, continue, ... ",{"type":"list"}," seq, slti, sltu, ..., beq, bgtz, bgezal, ..., j, jr, jal, ... ",{"type":"list"}," describing the process as a sequence of binary operations ",{"type":"list"}," managing data flow between the operations ",{"type":"list"}," works best for small, dense range of case values (e.g. 1..10) ",{"type":"list"}," evaluate Cond1; if 0 then return 0 for whole expression ",{"type":"list"}," evaluate Cond2; if 0 then return 0 for whole expression ",{"type":"list"}," ... ",{"type":"list"}," evaluate Condn; if 0 then return 0 for whole expression ",{"type":"list"}," otherwise, return 1 ",{"type":"list"}," evaluate Cond1; if !0 then return 1 for whole expression ",{"type":"list"}," evaluate Cond2; if !0 then return 1 for whole expression ",{"type":"list"}," ... ",{"type":"list"}," evaluate Condn; if !0 then return 1 for whole expression ",{"type":"list"}," otherwise, return 1 ",{"type":"list"}," the arguments are evaluated and set up for function ",{"type":"list"}," control is transferred to the code for the function ",{"type":"list"}," local variables are created ",{"type":"list"}," the function code is executed in this environment ",{"type":"list"}," the return value is set up ",{"type":"list"}," control transfers back to where the function was called from ",{"type":"list"}," the caller receives the return value ",{"type":"list"}," used for: saved registers, local variables, parameters to callees ",{"type":"list"}," created in the function prologue (pushed) ",{"type":"list"}," removed in the function epilogue (popped) ",{"type":"list"}," function f() calls g() which calls h() ",{"type":"list"}," h() runs, then finishes and returns to g() ",{"type":"list"}," g() continues, then finishes and returns to f() ",{"type":"list"}," caller saved registers (saved by f()) f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" e.g. $t0 .. $t9, $a0 .. $a3, $ra ",{"type":"list"}," f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" ",{"type":"list"}," g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" ",{"type":"list"}," e.g. $t0 .. $t9, $a0 .. $a3, $ra ",{"type":"list"}," callee saved registers (saved by g()) f() tells g() \"I assume the values of these registers will be unchanged when you return\" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" e.g. $s0 .. $s7, $sp, $fp ",{"type":"list"}," f() tells g() \"I assume the values of these registers will be unchanged when you return\" ",{"type":"list"}," g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" ",{"type":"list"}," e.g. $s0 .. $s7, $sp, $fp ",{"type":"list"}," one instruction can start before the previous one finishes ",{"type":"list"}," instruction following branch is executed before branch completes ",{"type":"list"}," $sp can change (e.g. pushing params, adding local vars) ",{"type":"list"}," may need to reference local vars on the stack ",{"type":"list"}," useful if they can be defined by an offset relative to fixed point ",{"type":"list"}," $fp provides a fixed point during function code execution ",{"type":"list"}," place 64-bit double args in $f12 and $f14 ",{"type":"list"}," place 32-bit arguments in the $a0..$a3 ",{"type":"list"}," if more than 4 args, or args larger than 32-bits ... push value of all such args onto stack ",{"type":"list"}," push value of all such args onto stack ",{"type":"list"}," save any non-$s? registers that need to be preserved push value of all such registers onto stack ",{"type":"list"}," push value of all such registers onto stack ",{"type":"list"}," jal address of function (usually given by a label) ",{"type":"list"}," create a stack frame for itself (change $fp and $sp) ",{"type":"list"}," save the return address ($ra) in the stack frame ",{"type":"list"}," save any $s? registers that it plans to change ",{"type":"list"}," 4 bytes for saved $fp + 4 bytes for saved $ra ",{"type":"list"}," + 4 bytes for each saved $s? ",{"type":"list"}," new $fp = old $sp - 4 ",{"type":"list"}," new $sp = old $sp - size of frame (in bytes) ",{"type":"list"}," place the return value in $v0 (and maybe $v1) ",{"type":"list"}," pop any pushed arguments off the stack ",{"type":"list"}," restore the values of any saved $s? registers ",{"type":"list"}," restore the saved value of $ra (return address) ",{"type":"list"}," remove its stack frame (change $fp and $sp) ",{"type":"list"}," return to the calling function (jr $ra) ",{"type":"list"}," new $sp = old $fp + 4 ",{"type":"list"}," new $fp = memory[old $fp] ",{"type":"list"}," char ... as byte in memory, or low-order byte in register ",{"type":"list"}," int ... as word in memory, or whole register ",{"type":"list"}," double ... as two-words in memory, or $f? register ",{"type":"list"}," arrays ... sequence of memory bytes/words, accessed by index ",{"type":"list"}," structs ... chunk of memory, accessed by fields/offsets ",{"type":"list"}," linked structures ... struct containing address of another struct ",{"type":"list"}," could be implemented in register if used in small scope ",{"type":"list"}," could be implemented on stack if local to function ",{"type":"list"}," could be implemented in .data if need longer persistence ",{"type":"list"}," uninitialised memory allocated at compile/assemble-time, e.g. int val; val: .space 4 char str[20]; str: .space 20 int vec[20]; vec: .space 80 ",{"type":"list"}," initialised memory allocated at compile/assemble-time, e.g. int val = 5; val: .word 5 int arr[4] = {9,8,7,6}; arr: .word 9, 8, 7, 6 char *msg = \"Hello\\n\"; msg: .asciiz \"Hello\\n\" ",{"type":"list"}," variables local to a function ",{"type":"list"}," use space allocated on stack during function prologue ",{"type":"list"}," referenced during function relative to $fp ",{"type":"list"}," space reclaimed from stack in function epilogue ",{"type":"list"}," uninitialised block of memory allocated at run-time int *ptr = malloc(sizeof(int)); char *str = malloc(20*sizeof(char)); int *vec = malloc(20*sizeof(int)); *ptr = 5; strcpy(str, \"a string\"); vec[0] = 1; // or *vec = 1; vec[1] = 6; ",{"type":"list"}," initialised block of memory allocated at run-time int *vec = calloc(20, sizeof(int)); // vec[i] == 0, for i in 0..19 ",{"type":"list"}," but provides syscall 9 to extend .data ",{"type":"list"}," before syscall, set $a0 to the number of bytes requested ",{"type":"list"}," after syscall, $v0 holds start address of allocated chunk ",{"type":"list"}," a complete implementation of C's heap management, i.e. ",{"type":"list"}," a large region of memory to manage (syscall 9) ",{"type":"list"}," ability to mark chunks of this region as \"in use\" (with size) ",{"type":"list"}," ability to maintain list of free chunks ",{"type":"list"}," ability to merge free chunks to prevent fragmentation ",{"type":"list"}," either approach needs to account for size of elements ",{"type":"list"}," must also pass array size, since not available elsewhere ",{"type":"list"}," makes things easier for a human to prodcue MIPS code ",{"type":"list"}," does not provide an automatic way of translating ",{"type":"list"}," this is provided by a compiler (e.g. dcc) ",{"type":"list"}," convert #include and #define ",{"type":"list"}," parse code to check syntactically valid ",{"type":"list"}," manage a list of symbols used in program ",{"type":"list"}," decide how to represent data structures ",{"type":"list"}," allocate local variables to registers or stack ",{"type":"list"}," map control structures to MIPS instructions ",{"type":"list"}," #include File replace #include by contents of file \"name.h\" ... uses named File.h <name.h> ... uses File.h in /usr/include ",{"type":"list"}," replace #include by contents of file ",{"type":"list"}," \"name.h\" ... uses named File.h ",{"type":"list"}," <name.h> ... uses File.h in /usr/include ",{"type":"list"}," #define Name Constant replace all occurences of symbol Name by Constant e.g #define MAX 5 char array[MAX] → char array[5] ",{"type":"list"}," replace all occurences of symbol Name by Constant ",{"type":"list"}," e.g #define MAX 5 char array[MAX] → char array[5] ",{"type":"list"}," #define Name(Params) Expression replace Name(Params) by SubstitutedExpression e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) ",{"type":"list"}," replace Name(Params) by SubstitutedExpression ",{"type":"list"}," e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) ",{"type":"list"}," scope, lifetime, locally/externally defined ",{"type":"list"}," disambiguates e.g. x in main() vs x in fun() ",{"type":"list"}," resolves symbols to specific locations (data/stack/registers) ",{"type":"list"}," external symbols may remain unresolved until linking ",{"type":"list"}," however, need to have a type for each external symbol ",{"type":"list"}," on the stack ... +persist for whole function, -lw/sw needed in MIPS ",{"type":"list"}," in a register ... +efficient, -not many, useful if var used in small scope if need to persist across function calls, use $s? register if used in very localised scope, can use $t? register ",{"type":"list"}," if need to persist across function calls, use $s? register ",{"type":"list"}," if used in very localised scope, can use $t? register ",{"type":"list"}," even complex expressions don't generally need > 3-4 registers "]}