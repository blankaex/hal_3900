{"grouped":[{"tags":["table"],"items":[{"text":"The C View of Data1/56"}]},{"tags":["table"],"items":[{"text":"... The C View of Data2/56"}]},{"tags":["table"],"items":[{"text":"... The C View of Data3/56"}]},{"tags":["table"],"items":[{"text":"... The C View of Data4/56"}]},{"tags":["table"],"items":[{"text":"... The C View of Data5/56"}]},{"tags":["table"],"items":[{"text":"The Physical View of Data6/56"}]},{"tags":["table"],"items":[{"text":"Memory7/56"}]},{"tags":["table"],"items":[{"text":"... Memory8/56"}]},{"tags":["table"],"items":[{"text":"... Memory9/56"}]},{"tags":["table"],"items":[{"text":"Data Representation"}]},{"tags":["table"],"items":[{"text":"Data Representation11/56"}]},{"tags":["table"],"items":[{"text":"Character Data12/56"}]},{"tags":["table"],"items":[{"text":"ASCII Character Encoding13/56"}]},{"tags":["table"],"items":[{"text":"... ASCII Character Encoding14/56"}]},{"tags":["table"],"items":[{"text":"Unicode15/56"}]},{"tags":["table"],"items":[{"text":"UTF-8 Character Encoding16/56"}]},{"tags":["table"],"items":[{"text":" #bytes #bits Byte 1 Byte 2 Byte 3 Byte 4 "},{"text":" 170xxxxxxx--- "},{"text":" 211110xxxxx10xxxxxx-- "},{"text":" 3161110xxxx10xxxxxx10xxxxxx- "},{"text":" 42111110xxx10xxxxxx10xxxxxx10xxxxxx "}]},{"tags":["table"],"items":[{"text":"... UTF-8 Character Encoding17/56"}]},{"tags":["table"],"items":[{"text":" ch unicode bits simple binary UTF-8 binary "},{"text":" $ U+0024 7 010 0100 00100100 "},{"text":" ¬¢ U+00A2 11 000 1010 0010 11000010 10100010 "},{"text":" ‚Ç¨ U+20AC 16 0010 0000 1010 1100 11100010 10000010 10101100 "},{"text":" êçà U+10348 21 0 0001 0000 0011 0100 1000 11110000 10010000 10001101 10001000 "}]},{"tags":["table"],"items":[{"text":"... UTF-8 Character Encoding18/56"}]},{"tags":["table"],"items":[{"text":"Numeric Data19/56"}]},{"tags":["table"],"items":[{"text":"Integer Constants20/56"}]},{"tags":["table"],"items":[{"text":"Unsigned integers21/56"}]},{"tags":["table"],"items":[{"text":"... Unsigned integers22/56"}]},{"tags":["table"],"items":[{"text":"Signed integers23/56"}]},{"tags":["table"],"items":[{"text":"... Signed integers24/56"}]},{"tags":["table"],"items":[{"text":"... Signed integers25/56"}]},{"tags":["table"],"items":[{"text":"... Signed integers26/56"}]},{"tags":["table"],"items":[{"text":"... Signed integers27/56"}]},{"tags":["table"],"items":[{"text":"Pointers28/56"}]},{"tags":["table"],"items":[{"text":"... Pointers29/56"}]},{"tags":["table"],"items":[{"text":"Floating Point Numbers30/56"}]},{"tags":["table"],"items":[{"text":"... Floating Point Numbers31/56"}]},{"tags":["table"],"items":[{"text":"... Floating Point Numbers32/56"}]},{"tags":["table"],"items":[{"text":"... Floating Point Numbers33/56"}]},{"tags":["table"],"items":[{"text":"... Floating Point Numbers34/56"}]},{"tags":["table"],"items":[{"text":"ComponentMin ValueMax Value"},{"text":"exponent 00000000 = -127 11111111 = 128 "},{"text":"fraction 00...00 = 0 11...11 = 2-1+2-2+...+2-24 "}]},{"tags":["table"],"items":[{"text":"ComponentMin ValueMax Value"},{"text":"exponent 00000000000 = -2047 11111111111 = 2048 "},{"text":"fraction 00...00 = 0 11...11 = 2-1+2-2+...+2-51 "}]},{"tags":["table"],"items":[{"text":"... Floating Point Numbers35/56"}]},{"tags":["table"],"items":[{"text":"Arrays36/56"}]},{"tags":["table"],"items":[{"text":"... Arrays37/56"}]},{"tags":["table"],"items":[{"text":"... Arrays38/56"}]},{"tags":["table"],"items":[{"text":"... Arrays39/56"}]},{"tags":["table"],"items":[{"text":"Structs40/56"}]},{"tags":["table"],"items":[{"text":"... Structs41/56"}]},{"tags":["table"],"items":[{"text":"... Structs42/56"}]},{"tags":["table"],"items":[{"text":"Exercise 1: Struct Alternatives43/56"}]},{"tags":["table"],"items":[{"text":"Variable-length Structs44/56"}]},{"tags":["table"],"items":[{"text":"... Variable-length Structs45/56"}]},{"tags":["table"],"items":[{"text":"Bit-wise Structs46/56"}]},{"tags":["table"],"items":[{"text":"... Bit-wise Structs47/56"}]},{"tags":["table"],"items":[{"text":"... Bit-wise Structs48/56"}]},{"tags":["table"],"items":[{"text":"... Bit-wise Structs49/56"}]},{"tags":["table"],"items":[{"text":"... Bit-wise Structs50/56"}]},{"tags":["table"],"items":[{"text":"Unions51/56"}]},{"tags":["table"],"items":[{"text":"... Unions52/56"}]},{"tags":["table"],"items":[{"text":"... Unions53/56"}]},{"tags":["table"],"items":[{"text":"... Unions54/56"}]},{"tags":["table"],"items":[{"text":"... Unions55/56"}]},{"tags":["table"],"items":[{"text":"Enumerated Types56/56"}]},{"tags":["list"],"items":[{"text":" a location in memory "},{"text":" a value (ultimately just a bit-string) "},{"text":" a name (unless created by malloc()) "},{"text":" a type, which determines ... its size (in units of whole bytes, sizeof) how to interpret its value what operations apply to the value "},{"text":" its size (in units of whole bytes, sizeof) "},{"text":" how to interpret its value "},{"text":" what operations apply to the value "},{"text":" a scope (where it's visible within the program) "},{"text":" a lifetime (during which part of program execution it exists) "}]},{"tags":["list"],"items":[{"text":" its size (in units of whole bytes, sizeof) "},{"text":" how to interpret its value "},{"text":" what operations apply to the value "}]},{"tags":["list"],"items":[{"text":" global variables, static variables, string constants "},{"text":" objects persist for entire duration of program execution "}]},{"tags":["list"],"items":[{"text":" objects created by malloc, calloc, ... "},{"text":" objects persist in heap until explicitly free'd "}]},{"tags":["list"],"items":[{"text":" a small region (frame) for each active function "},{"text":" frames contain local variables and parameters "},{"text":" a frame is created when a function is called "},{"text":" the frame is removed when the function returns "}]},{"tags":["list"],"items":[{"text":" relatively large (e.g. 228 bytes) "},{"text":" any byte can be fetched with same cost "},{"text":" cost of fetching 1,2,4,8 bytes is small (ns) "}]},{"tags":["list"],"items":[{"text":" volatile (e.g. DRAM) ... data lost when powered off "},{"text":" non-volatile (e.g. EEPROM) ... data stays when powered off "}]},{"tags":["list"],"items":[{"text":" any byte address can be used to fetch 1-byte object "},{"text":" byte address for N-byte object must be divisible by N "}]},{"tags":["list"],"items":[{"text":" load bit-strings of sizes 1,2,4,8 bytes "},{"text":" from N-byte boundary addresses "},{"text":" into registers in the CPU "}]},{"tags":["list"],"items":[{"text":" ASCII (ISO 646) 7-bit values, using lower 7-bits of a byte (top bit always zero) can encode roman alphabet, digits, punctuation, control chars "},{"text":" 7-bit values, using lower 7-bits of a byte (top bit always zero) "},{"text":" can encode roman alphabet, digits, punctuation, control chars "},{"text":" UTF-8 (Unicode) 8-bit values, with ability to extend to multi-byte values can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "},{"text":" 8-bit values, with ability to extend to multi-byte values "},{"text":" can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "}]},{"tags":["list"],"items":[{"text":" 7-bit values, using lower 7-bits of a byte (top bit always zero) "},{"text":" can encode roman alphabet, digits, punctuation, control chars "}]},{"tags":["list"],"items":[{"text":" 8-bit values, with ability to extend to multi-byte values "},{"text":" can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "}]},{"tags":["list"],"items":[{"text":" control characters (0..31) ... e.g. '\\0', '\\n' "},{"text":" punctuation chars (32..47,91..96,123..126) "},{"text":" digits (48..57) ... '0'..'9' "},{"text":" upper case alphabetic (65..90) ... 'A'..'Z' "},{"text":" lower case alphabetic (97..122) ... 'a'..'z' "}]},{"tags":["list"],"items":[{"text":" not all writing systems use a small set of discrete symbols "}]},{"tags":["list"],"items":[{"text":" around 140K symbols, covering 140 different languages "}]},{"tags":["list"],"items":[{"text":" e.g. standard roman alphabet + punctuation needs only 7-bits "}]},{"tags":["list"],"items":[{"text":" \\uHexDigits ... insert Unicode code value "},{"text":" \\x2HexDigits ... insert individual bytes "}]},{"tags":["list"],"items":[{"text":" integer ... subset (range) of the mathematical integers "},{"text":" floating point ... subset of the mathematical real numbers "}]},{"tags":["list"],"items":[{"text":" 42 ... signed decimal (0..9) "},{"text":" 0x2A ... unsigned hexadecimal (0..F) "},{"text":" 052 ... signed octal (0 ..7) "}]},{"tags":["list"],"items":[{"text":" 123U ... unsigned int value (typically 32 bits) "},{"text":" 123L ... long int value (typically 64 bits) "},{"text":" 123S ... short int value (typically 16 bits) "}]},{"tags":["list"],"items":[{"text":" 4294967296, -1U, 666666S, 078 "}]},{"tags":["list"],"items":[{"text":" commonly 32 bits, storing values in the range 0 .. 232-1 "}]},{"tags":["list"],"items":[{"text":" commonly 32 bits, storing values in the range -231 .. 231-1 "}]},{"tags":["list"],"items":[{"text":" signed magnitude ... first bit is sign, rest are magnitude "},{"text":" ones complement ... form -N by inverting all bits in N "},{"text":" twos complement ... form -N by inverting N and adding 1 "}]},{"tags":["list"],"items":[{"text":" 10000101 ... signed magnitude "},{"text":" 11111010 ... ones complement "},{"text":" 11111011 ... twos complement "}]},{"tags":["list"],"items":[{"text":" what do these numbers represent? 00000000, 10000000 "}]},{"tags":["list"],"items":[{"text":" what do these numbers represent? 00000000, 11111111 "}]},{"tags":["list"],"items":[{"text":" -0 = ~00000000+1 = 11111111+1 = 00000000 "}]},{"tags":["list"],"items":[{"text":" number of bits depends on memory size, but typically 32-bits "},{"text":" data pointers reference addresses in data/heap/stack regions "},{"text":" function pointers reference addresses in code region "}]},{"tags":["list"],"items":[{"text":" sizeof(int *) = sizeof(char *) = sizeof(double *) = sizeof(struct X *) "}]},{"tags":["list"],"items":[{"text":" (char *) ... can reference any byte address "},{"text":" (int *) ... must have addr %4 == 0 "},{"text":" (double *) ... must have addr %8 == 0 "}]},{"tags":["list"],"items":[{"text":" many real values don't have exact representation (e.g. 1/3) "},{"text":" results of calculations may contain small inaccuracies "}]},{"tags":["list"],"items":[{"text":" numbers close to zero have higher precision (more accurate) "},{"text":" numbers further from zero have lower precision (less accurate) "}]},{"tags":["list"],"items":[{"text":" float ... typically 32-bit quantity (lower precision, narrower range) "},{"text":" double ... typically 64-bit quantity (higher precision, wider range) "}]},{"tags":["list"],"items":[{"text":" scientific notation with fraction F and exponent E "},{"text":" numbers have form F √ó 2E, where both F and E can be -ve "},{"text":" INFINITY = representation for ‚àû and -‚àû (e.g. 1.0/0) "},{"text":" NAN = representation for invalid value NaN (e.g. sqrt(-1.0)) "},{"text":" 32-bit single-precision, 64-bit double precision "}]},{"tags":["list"],"items":[{"text":" 1010.1011 is normalized as 1.0101011√ó2011 "},{"text":" 1010.1011 = 10 + 11/16 = 10.6875 "},{"text":" 1.0101011√ó2011 = (1 + 43/128) * 23 = 1.3359375 * 8 = 10.6875 "}]},{"tags":["list"],"items":[{"text":" fraction part is always 1.bbbbbbbb; don't store 1 "},{"text":" exponent is offset relative to a baseline -2b-1-1, b = #exponent bits "}]},{"tags":["list"],"items":[{"text":" the baseline (aka bias) is 127, the exponent is 27 "},{"text":" so, in the exponent, we store 127+7 = 134 = 10000110 "}]},{"tags":["list"],"items":[{"text":" individual array elements are accessed via indices 0..N-1 "},{"text":" total amount of space allocated to array N √ó sizeof(Type ) "}]},{"tags":["list"],"items":[{"text":" constant strings have '\\0' added automatically "},{"text":" string buffers must allow for element to hold '\\0' "}]},{"tags":["list"],"items":[{"text":" each component has a Name and a Type "}]},{"tags":["list"],"items":[{"text":" define the dynamic object as the last component "},{"text":" malloc() more space than the struct requires "},{"text":" to make the final component as large as required "}]},{"tags":["list"],"items":[{"text":" C allows programmers to specify structs bit-wise "}]},{"tags":["list"],"items":[{"text":" specify unnamed components using standard types "},{"text":" specify named individual bit fields in each component "}]}],"block":[{"tags":["paragraph"],"text":"Course Notes B: Memory and Data Representation"},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" The C View of Data1/56 "},{"tags":["paragraph"],"text":" A C program sees data as a collection of variables "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Each variable has a number of properties (e.g. name, type, size) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... The C View of Data2/56 "},{"tags":["paragraph"],"text":" Variables are examples of computational objects "},{"tags":["paragraph"],"text":" Each computational object has "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... The C View of Data3/56 "},{"tags":["paragraph"],"text":" C allocates data objects to various well-defined regions of memoryduring program execution "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... The C View of Data4/56 "},{"tags":["paragraph"],"text":" The global data area contains "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... The C View of Data5/56 "},{"tags":["paragraph"],"text":" Example of runtime stack during call to h() "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" The Physical View of Data6/56 "},{"tags":["paragraph"],"text":" Memory = indexed array of bytes "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Indexes are \"memory addresses\" (a.k.a. pointers) "},{"tags":["paragraph"],"text":" Data can be fetched in chunks of 1,2,4,8 bytes "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Memory7/56 "},{"tags":["paragraph"],"text":" Also called: RAM, main memory, primary storage, ... "},{"tags":["paragraph"],"text":" Technology: semiconductor-based "},{"tags":["paragraph"],"text":" Distinguishing features "},{"tags":["paragraph"],"text":" Two properties related to data persistence "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Memory8/56 "},{"tags":["paragraph"],"text":" When addressing objects in memory "},{"tags":["paragraph"],"text":" Data bytes in registers may be in different order to memory, e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Memory9/56 "},{"tags":["paragraph"],"text":" Memories can be categorised as big-endian or little-endian "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Data Representation "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Data Representation11/56 "},{"tags":["paragraph"],"text":" Ultimately, memory allows you to "},{"tags":["paragraph"],"text":" Need to interpret this bit-string as a meaningful value "},{"tags":["paragraph"],"text":" Data representations provide a way of assigning meaning to bit-strings "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Character Data12/56 "},{"tags":["paragraph"],"text":" Character data has several possible representations (encodings) "},{"tags":["paragraph"],"text":" The two most common: "},{"tags":["paragraph"],"text":" (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ASCII Character Encoding13/56 "},{"tags":["paragraph"],"text":" Uses values in the range 0x00 to 0x7F (0..127) "},{"tags":["paragraph"],"text":" Characters partitioned into sequential groups "},{"tags":["paragraph"],"text":" Sequential nature of groups allow for e.g. (ch - '0') "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... ASCII Character Encoding14/56 "},{"tags":["paragraph"],"text":" Hexademical ASCII char table (from man 7 ascii) "},{"tags":["paragraph"],"text":" 0x0a = '\\n', 0x20 = ' ', 0x09 = '\\t', but note no EOF "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Unicode15/56 "},{"tags":["paragraph"],"text":" Widely-used standard for expressing \"writing systems\" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" UTF-8 Character Encoding16/56 "},{"tags":["paragraph"],"text":" UTF-8 uses a variable-length encoding as follows "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" The 127 1-byte codes are compatible with ASCII "},{"tags":["paragraph"],"text":" The 2048 2-byte codes include most Latin-script alphabets "},{"tags":["paragraph"],"text":" The 65536 3-byte codes include most Asian languages "},{"tags":["paragraph"],"text":" The 2097152 4-byte codes include symbols and emojis and ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... UTF-8 Character Encoding17/56 "},{"tags":["paragraph"],"text":" UTF-8 examples "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Unicode strings can be manipulated in C (e.g. \"\") "},{"tags":["paragraph"],"text":" Like other C strings, they are terminated by a 0 byte (i.e. '\\0') "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... UTF-8 Character Encoding18/56 "},{"tags":["paragraph"],"text":" Unicode constants in C strings ... "},{"tags":["paragraph"],"text":" The following two notations work in some contexts "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" The red sequences produce 3 bytes and 1 Unicode symbol. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Numeric Data19/56 "},{"tags":["paragraph"],"text":" Numeric data comes in two major forms "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Integer Constants20/56 "},{"tags":["paragraph"],"text":" Three ways to write integer constants in C "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Unsigned integers21/56 "},{"tags":["paragraph"],"text":" The unsigned int data type "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Unsigned integers22/56 "},{"tags":["paragraph"],"text":" Value interpreted as binary number "},{"tags":["paragraph"],"text":" E.g. consider an 8-bit unsigned int "},{"tags":["paragraph"],"text":" 01001101 = 26 + 23 + 22 + 20 = 64 + 8 + 4 + 1 = 77 "},{"tags":["paragraph"],"text":" Addition is bitwise with carry "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Most machines will also flag the overflow in the fourth example "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Signed integers23/56 "},{"tags":["paragraph"],"text":" The int data type "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Signed integers24/56 "},{"tags":["paragraph"],"text":" Several possible representations for negative values "},{"tags":["paragraph"],"text":" Examples: representations of (8-bit) -5 (where 5 is 00000101) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Signed integers25/56 "},{"tags":["paragraph"],"text":" Signed magnitude: Easy to form -X from X ... OR in high-order bit "},{"tags":["paragraph"],"text":" A problem (using 8-bit ints) ... "},{"tags":["paragraph"],"text":" Another problem: x + -x ‚â† 0 (mostly) with simple addition "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" To fix requires extra hardware in ALU "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Signed integers26/56 "},{"tags":["paragraph"],"text":" Ones complement: Easy to form -X from X ... NEG all bits "},{"tags":["paragraph"],"text":" A problem (using 8-bit ints) ... "},{"tags":["paragraph"],"text":" At least x + -x is equal to one of the zeroes with simple addition "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Signed integers27/56 "},{"tags":["paragraph"],"text":" Twos complement: to form -X from X ... NEG all bits, then add 1 "},{"tags":["paragraph"],"text":" Now have only one representation for zero (00000000) "},{"tags":["paragraph"],"text":" Even better, x + -x = 0 in all cases with simple addition "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Always produces an \"overflow\" bit, but can ignore this "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Pointers28/56 "},{"tags":["paragraph"],"text":" Pointers represent memory addresses/locations "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Pointers29/56 "},{"tags":["paragraph"],"text":" Can \"move\" from object to object by pointer arithmetic "},{"tags":["paragraph"],"text":" For any pointer T *p;, p++ increases p by sizeof(T ) "},{"tags":["paragraph"],"text":" Examples (assuming 16-bit pointers): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" A common (efficient) paradigm for scanning a string "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Floating Point Numbers30/56 "},{"tags":["paragraph"],"text":" Floating point numbers model a (tiny) subset of ‚Ñù "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Floating Point Numbers31/56 "},{"tags":["paragraph"],"text":" C has two floating point types "},{"tags":["paragraph"],"text":" Display via printf "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" W gives total width (blank padded), P gives #digits after dec point "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Floating Point Numbers32/56 "},{"tags":["paragraph"],"text":" IEEE 754 standard ... "},{"tags":["paragraph"],"text":" Example of normalising in binary: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Floating Point Numbers33/56 "},{"tags":["paragraph"],"text":" Internal structure of floating point values "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" More complex than int because 1.dddd e dd "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Floating Point Numbers34/56 "},{"tags":["paragraph"],"text":" Details of internal structure "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" 00...00 = 24 zero bits, 11...11 = 24 one bits "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" 00...00 = 24 zero bits, 11...11 = 24 one bits "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Floating Point Numbers35/56 "},{"tags":["paragraph"],"text":" Example (single-precision): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" where red is sign bit, green is exponent, blue is fraction "},{"tags":["paragraph"],"text":" Note: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Arrays36/56 "},{"tags":["paragraph"],"text":" Arrays are defined to have N elements, each of type T "},{"tags":["paragraph"],"text":" Examples: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Elements are laid out adjacent in memory "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Arrays37/56 "},{"tags":["paragraph"],"text":" Assuming an array declaration like Type v[N ] ... "},{"tags":["paragraph"],"text":" Name of array can be treated as a pointer to element type Type "},{"tags":["paragraph"],"text":" Array indexing can be treated as v[i] ‚âÖ *(v+i) "},{"tags":["paragraph"],"text":" If have pointer to first element, can use it just like an array "},{"tags":["paragraph"],"text":" Strings are just arrays of char with a '\\0' terminator "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Arrays38/56 "},{"tags":["paragraph"],"text":" When arrays are \"passed\" to a function, actually pass &a[0] "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Arrays39/56 "},{"tags":["paragraph"],"text":" Arrays can be created automatically or via malloc() "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Two separate arrays (different &'s), but have same contents "},{"tags":["paragraph"],"text":" (except for the unitialised parts of the arrays) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Structs40/56 "},{"tags":["paragraph"],"text":" Structs are defined to have a number of components "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs41/56 "},{"tags":["paragraph"],"text":" Internal layout of struct components determined by compiler "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Each name maps to a byte offset within the struct "},{"tags":["paragraph"],"text":" E.g. in first example id = offset 0, given = offset 4, family = offset 54, etc. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs42/56 "},{"tags":["paragraph"],"text":" To ensure alignment, internal \"padding\" may be needed "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Padding wastes space; re-order fields to minimise waste. "},{"tags":["paragraph"],"text":" clang has -Wpadded to warn about padding in structs "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Exercise 1: Struct Alternatives43/56 "},{"tags":["paragraph"],"text":" Consider these two possible representations of Nodes in a linked list of strings: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Show how they would be (a) defined, (b) initialised. How large is each? "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Variable-length Structs44/56 "},{"tags":["paragraph"],"text":" Structs can contain pointers to dynamic objects "},{"tags":["paragraph"],"text":" But we can also \"embed\" one dynamic object in a malloc'd struct "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Variable-length Structs45/56 "},{"tags":["paragraph"],"text":" Amount of memory allocated to struct is determined dynamically: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Bit-wise Structs46/56 "},{"tags":["paragraph"],"text":" For fine-grained control over layout of fields in structs "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Has one component and three bit fields within that component. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Bit-wise Structs47/56 "},{"tags":["paragraph"],"text":" Two ways of declaring bit fields: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" In both cases, sizeof(struct _bit_fields) is 4 bytes. "},{"tags":["paragraph"],"text":" First way makes it clearer that a single unsigned int is used. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Bit-wise Structs48/56 "},{"tags":["paragraph"],"text":" Another example (graphics objects): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Bit-wise Structs49/56 "},{"tags":["paragraph"],"text":" The graphics object would be stored in memory as: "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Bit-wise Structs50/56 "},{"tags":["paragraph"],"text":" Bit-fields provide an alternative to bit operators and masks: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Unions51/56 "},{"tags":["paragraph"],"text":" Unions allow programmers to specify multiple interpretations for a single piece of memory. "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Unions52/56 "},{"tags":["paragraph"],"text":" Example of defining a union type (cf. struct): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" myUnion is a single 4-byte memory object "},{"tags":["paragraph"],"text":" Programmers can specify how to interpret bits using field names. "},{"tags":["paragraph"],"text":" In the example above, all components are coincidentally the same size (4 bytes) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Unions53/56 "},{"tags":["paragraph"],"text":" Difference between a struct and a union "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Unions54/56 "},{"tags":["paragraph"],"text":" General syntax for defining union types and variables: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Type can be any C type; Member names must be distinct "},{"tags":["paragraph"],"text":" sizeof(Union) is the size of the largest member "},{"tags":["paragraph"],"text":" &uvar.Member1 == &uvar.Member2 == &uvar.Member3 ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Unions55/56 "},{"tags":["paragraph"],"text":" Common use of union types: \"generic\" variables "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Enumerated Types56/56 "},{"tags":["paragraph"],"text":" Enumerated types allow programmers to define a set of distinct named values "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" The names are assigned consecutive int values, starting from 0 "},{"tags":["paragraph"],"text":" Above PrimaryColors type is equivalent to "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Variables of type enum... are effectively unsigned ints. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Produced: 1 Mar 2018 "}]}