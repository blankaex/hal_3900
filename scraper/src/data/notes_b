{"allTables":[{"tableRows":[{"text":"The C View of Data1/56"}]},{"tableRows":[{"text":"... The C View of Data2/56"}]},{"tableRows":[{"text":"... The C View of Data3/56"}]},{"tableRows":[{"text":"... The C View of Data4/56"}]},{"tableRows":[{"text":"... The C View of Data5/56"}]},{"tableRows":[{"text":"The Physical View of Data6/56"}]},{"tableRows":[{"text":"Memory7/56"}]},{"tableRows":[{"text":"... Memory8/56"}]},{"tableRows":[{"text":"... Memory9/56"}]},{"tableRows":[{"text":"Data Representation"}]},{"tableRows":[{"text":"Data Representation11/56"}]},{"tableRows":[{"text":"Character Data12/56"}]},{"tableRows":[{"text":"ASCII Character Encoding13/56"}]},{"tableRows":[{"text":"... ASCII Character Encoding14/56"}]},{"tableRows":[{"text":"Unicode15/56"}]},{"tableRows":[{"text":"UTF-8 Character Encoding16/56"}]},{"tableRows":[{"text":" #bytes #bits Byte 1 Byte 2 Byte 3 Byte 4 "},{"text":" 170xxxxxxx--- "},{"text":" 211110xxxxx10xxxxxx-- "},{"text":" 3161110xxxx10xxxxxx10xxxxxx- "},{"text":" 42111110xxx10xxxxxx10xxxxxx10xxxxxx "}]},{"tableRows":[{"text":"... UTF-8 Character Encoding17/56"}]},{"tableRows":[{"text":" ch unicode bits simple binary UTF-8 binary "},{"text":" $ U+0024 7 010 0100 00100100 "},{"text":" ¬¢ U+00A2 11 000 1010 0010 11000010 10100010 "},{"text":" ‚Ç¨ U+20AC 16 0010 0000 1010 1100 11100010 10000010 10101100 "},{"text":" êçà U+10348 21 0 0001 0000 0011 0100 1000 11110000 10010000 10001101 10001000 "}]},{"tableRows":[{"text":"... UTF-8 Character Encoding18/56"}]},{"tableRows":[{"text":"Numeric Data19/56"}]},{"tableRows":[{"text":"Integer Constants20/56"}]},{"tableRows":[{"text":"Unsigned integers21/56"}]},{"tableRows":[{"text":"... Unsigned integers22/56"}]},{"tableRows":[{"text":"Signed integers23/56"}]},{"tableRows":[{"text":"... Signed integers24/56"}]},{"tableRows":[{"text":"... Signed integers25/56"}]},{"tableRows":[{"text":"... Signed integers26/56"}]},{"tableRows":[{"text":"... Signed integers27/56"}]},{"tableRows":[{"text":"Pointers28/56"}]},{"tableRows":[{"text":"... Pointers29/56"}]},{"tableRows":[{"text":"Floating Point Numbers30/56"}]},{"tableRows":[{"text":"... Floating Point Numbers31/56"}]},{"tableRows":[{"text":"... Floating Point Numbers32/56"}]},{"tableRows":[{"text":"... Floating Point Numbers33/56"}]},{"tableRows":[{"text":"... Floating Point Numbers34/56"}]},{"tableRows":[{"text":"ComponentMin ValueMax Value"},{"text":"exponent 00000000 = -127 11111111 = 128 "},{"text":"fraction 00...00 = 0 11...11 = 2-1+2-2+...+2-24 "}]},{"tableRows":[{"text":"ComponentMin ValueMax Value"},{"text":"exponent 00000000000 = -2047 11111111111 = 2048 "},{"text":"fraction 00...00 = 0 11...11 = 2-1+2-2+...+2-51 "}]},{"tableRows":[{"text":"... Floating Point Numbers35/56"}]},{"tableRows":[{"text":"Arrays36/56"}]},{"tableRows":[{"text":"... Arrays37/56"}]},{"tableRows":[{"text":"... Arrays38/56"}]},{"tableRows":[{"text":"... Arrays39/56"}]},{"tableRows":[{"text":"Structs40/56"}]},{"tableRows":[{"text":"... Structs41/56"}]},{"tableRows":[{"text":"... Structs42/56"}]},{"tableRows":[{"text":"Exercise 1: Struct Alternatives43/56"}]},{"tableRows":[{"text":"Variable-length Structs44/56"}]},{"tableRows":[{"text":"... Variable-length Structs45/56"}]},{"tableRows":[{"text":"Bit-wise Structs46/56"}]},{"tableRows":[{"text":"... Bit-wise Structs47/56"}]},{"tableRows":[{"text":"... Bit-wise Structs48/56"}]},{"tableRows":[{"text":"... Bit-wise Structs49/56"}]},{"tableRows":[{"text":"... Bit-wise Structs50/56"}]},{"tableRows":[{"text":"Unions51/56"}]},{"tableRows":[{"text":"... Unions52/56"}]},{"tableRows":[{"text":"... Unions53/56"}]},{"tableRows":[{"text":"... Unions54/56"}]},{"tableRows":[{"text":"... Unions55/56"}]},{"tableRows":[{"text":"Enumerated Types56/56"}]}],"allParagraphs":[{"text":"Course Notes B: Memory and Data Representation"},{"text":" "},{"text":""},{"text":" The C View of Data1/56 "},{"text":" A C program sees data as a collection of variables "},{"text":""},{"text":" Each variable has a number of properties (e.g. name, type, size) "},{"text":""},{"text":" ... The C View of Data2/56 "},{"text":" Variables are examples of computational objects "},{"text":" Each computational object has "},{"text":""},{"text":" ... The C View of Data3/56 "},{"text":" C allocates data objects to various well-defined regions of memoryduring program execution "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... The C View of Data4/56 "},{"text":" The global data area contains "},{"text":""},{"text":" ... The C View of Data5/56 "},{"text":" Example of runtime stack during call to h() "},{"text":""},{"text":" "},{"text":""},{"text":" The Physical View of Data6/56 "},{"text":" Memory = indexed array of bytes "},{"text":" "},{"text":""},{"text":" "},{"text":" Indexes are \"memory addresses\" (a.k.a. pointers) "},{"text":" Data can be fetched in chunks of 1,2,4,8 bytes "},{"text":""},{"text":" Memory7/56 "},{"text":" Also called: RAM, main memory, primary storage, ... "},{"text":" Technology: semiconductor-based "},{"text":" Distinguishing features "},{"text":" Two properties related to data persistence "},{"text":""},{"text":" ... Memory8/56 "},{"text":" When addressing objects in memory "},{"text":" Data bytes in registers may be in different order to memory, e.g. "},{"text":""},{"text":" "},{"text":""},{"text":" ... Memory9/56 "},{"text":" Memories can be categorised as big-endian or little-endian "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" Data Representation "},{"text":" "},{"text":""},{"text":" Data Representation11/56 "},{"text":" Ultimately, memory allows you to "},{"text":" Need to interpret this bit-string as a meaningful value "},{"text":" Data representations provide a way of assigning meaning to bit-strings "},{"text":""},{"text":" Character Data12/56 "},{"text":" Character data has several possible representations (encodings) "},{"text":" The two most common: "},{"text":" (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "},{"text":""},{"text":" ASCII Character Encoding13/56 "},{"text":" Uses values in the range 0x00 to 0x7F (0..127) "},{"text":" Characters partitioned into sequential groups "},{"text":" Sequential nature of groups allow for e.g. (ch - '0') "},{"text":""},{"text":" ... ASCII Character Encoding14/56 "},{"text":" Hexademical ASCII char table (from man 7 ascii) "},{"text":" 0x0a = '\\n', 0x20 = ' ', 0x09 = '\\t', but note no EOF "},{"text":""},{"text":" Unicode15/56 "},{"text":" Widely-used standard for expressing \"writing systems\" "},{"text":""},{"text":" UTF-8 Character Encoding16/56 "},{"text":" UTF-8 uses a variable-length encoding as follows "},{"text":" "},{"text":" The 127 1-byte codes are compatible with ASCII "},{"text":" The 2048 2-byte codes include most Latin-script alphabets "},{"text":" The 65536 3-byte codes include most Asian languages "},{"text":" The 2097152 4-byte codes include symbols and emojis and ... "},{"text":""},{"text":" ... UTF-8 Character Encoding17/56 "},{"text":" UTF-8 examples "},{"text":" "},{"text":" Unicode strings can be manipulated in C (e.g. \"\") "},{"text":" Like other C strings, they are terminated by a 0 byte (i.e. '\\0') "},{"text":""},{"text":" ... UTF-8 Character Encoding18/56 "},{"text":" Unicode constants in C strings ... "},{"text":" The following two notations work in some contexts "},{"text":""},{"text":" The red sequences produce 3 bytes and 1 Unicode symbol. "},{"text":""},{"text":" Numeric Data19/56 "},{"text":" Numeric data comes in two major forms "},{"text":""},{"text":" "},{"text":""},{"text":" Integer Constants20/56 "},{"text":" Three ways to write integer constants in C "},{"text":""},{"text":" Unsigned integers21/56 "},{"text":" The unsigned int data type "},{"text":""},{"text":" "},{"text":""},{"text":" ... Unsigned integers22/56 "},{"text":" Value interpreted as binary number "},{"text":" E.g. consider an 8-bit unsigned int "},{"text":" 01001101 = 26 + 23 + 22 + 20 = 64 + 8 + 4 + 1 = 77 "},{"text":" Addition is bitwise with carry "},{"text":""},{"text":" Most machines will also flag the overflow in the fourth example "},{"text":""},{"text":" Signed integers23/56 "},{"text":" The int data type "},{"text":""},{"text":" "},{"text":""},{"text":" ... Signed integers24/56 "},{"text":" Several possible representations for negative values "},{"text":" Examples: representations of (8-bit) -5 (where 5 is 00000101) "},{"text":""},{"text":" ... Signed integers25/56 "},{"text":" Signed magnitude: Easy to form -X from X ... OR in high-order bit "},{"text":" A problem (using 8-bit ints) ... "},{"text":" Another problem: x + -x ‚â† 0 (mostly) with simple addition "},{"text":""},{"text":" To fix requires extra hardware in ALU "},{"text":""},{"text":" ... Signed integers26/56 "},{"text":" Ones complement: Easy to form -X from X ... NEG all bits "},{"text":" A problem (using 8-bit ints) ... "},{"text":" At least x + -x is equal to one of the zeroes with simple addition "},{"text":""},{"text":" "},{"text":""},{"text":" ... Signed integers27/56 "},{"text":" Twos complement: to form -X from X ... NEG all bits, then add 1 "},{"text":" Now have only one representation for zero (00000000) "},{"text":" Even better, x + -x = 0 in all cases with simple addition "},{"text":""},{"text":" Always produces an \"overflow\" bit, but can ignore this "},{"text":""},{"text":" Pointers28/56 "},{"text":" Pointers represent memory addresses/locations "},{"text":""},{"text":" ... Pointers29/56 "},{"text":" Can \"move\" from object to object by pointer arithmetic "},{"text":" For any pointer T *p;, p++ increases p by sizeof(T ) "},{"text":" Examples (assuming 16-bit pointers): "},{"text":""},{"text":" A common (efficient) paradigm for scanning a string "},{"text":""},{"text":" "},{"text":""},{"text":" Floating Point Numbers30/56 "},{"text":" Floating point numbers model a (tiny) subset of ‚Ñù "},{"text":""},{"text":" "},{"text":""},{"text":" ... Floating Point Numbers31/56 "},{"text":" C has two floating point types "},{"text":" Display via printf "},{"text":""},{"text":" W gives total width (blank padded), P gives #digits after dec point "},{"text":""},{"text":" "},{"text":""},{"text":" ... Floating Point Numbers32/56 "},{"text":" IEEE 754 standard ... "},{"text":" Example of normalising in binary: "},{"text":""},{"text":" ... Floating Point Numbers33/56 "},{"text":" Internal structure of floating point values "},{"text":" "},{"text":""},{"text":" "},{"text":" More complex than int because 1.dddd e dd "},{"text":""},{"text":" ... Floating Point Numbers34/56 "},{"text":" Details of internal structure "},{"text":" "},{"text":" 00...00 = 24 zero bits, 11...11 = 24 one bits "},{"text":" "},{"text":" 00...00 = 24 zero bits, 11...11 = 24 one bits "},{"text":""},{"text":" ... Floating Point Numbers35/56 "},{"text":" Example (single-precision): "},{"text":""},{"text":" where red is sign bit, green is exponent, blue is fraction "},{"text":" Note: "},{"text":""},{"text":" Arrays36/56 "},{"text":" Arrays are defined to have N elements, each of type T "},{"text":" Examples: "},{"text":""},{"text":" Elements are laid out adjacent in memory "},{"text":""},{"text":" "},{"text":""},{"text":" ... Arrays37/56 "},{"text":" Assuming an array declaration like Type v[N ] ... "},{"text":" Name of array can be treated as a pointer to element type Type "},{"text":" Array indexing can be treated as v[i] ‚âÖ *(v+i) "},{"text":" If have pointer to first element, can use it just like an array "},{"text":" Strings are just arrays of char with a '\\0' terminator "},{"text":""},{"text":" ... Arrays38/56 "},{"text":" When arrays are \"passed\" to a function, actually pass &a[0] "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Arrays39/56 "},{"text":" Arrays can be created automatically or via malloc() "},{"text":""},{"text":" Two separate arrays (different &'s), but have same contents "},{"text":" (except for the unitialised parts of the arrays) "},{"text":""},{"text":" Structs40/56 "},{"text":" Structs are defined to have a number of components "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Structs41/56 "},{"text":" Internal layout of struct components determined by compiler "},{"text":" "},{"text":""},{"text":" "},{"text":" Each name maps to a byte offset within the struct "},{"text":" E.g. in first example id = offset 0, given = offset 4, family = offset 54, etc. "},{"text":""},{"text":" ... Structs42/56 "},{"text":" To ensure alignment, internal \"padding\" may be needed "},{"text":" "},{"text":""},{"text":" "},{"text":" Padding wastes space; re-order fields to minimise waste. "},{"text":" clang has -Wpadded to warn about padding in structs "},{"text":""},{"text":" Exercise 1: Struct Alternatives43/56 "},{"text":" Consider these two possible representations of Nodes in a linked list of strings: "},{"text":""},{"text":" Show how they would be (a) defined, (b) initialised. How large is each? "},{"text":""},{"text":" Variable-length Structs44/56 "},{"text":" Structs can contain pointers to dynamic objects "},{"text":" But we can also \"embed\" one dynamic object in a malloc'd struct "},{"text":""},{"text":" "},{"text":""},{"text":" ... Variable-length Structs45/56 "},{"text":" Amount of memory allocated to struct is determined dynamically: "},{"text":""},{"text":" "},{"text":""},{"text":" Bit-wise Structs46/56 "},{"text":" For fine-grained control over layout of fields in structs "},{"text":""},{"text":" Has one component and three bit fields within that component. "},{"text":""},{"text":" ... Bit-wise Structs47/56 "},{"text":" Two ways of declaring bit fields: "},{"text":""},{"text":" In both cases, sizeof(struct _bit_fields) is 4 bytes. "},{"text":" First way makes it clearer that a single unsigned int is used. "},{"text":""},{"text":" ... Bit-wise Structs48/56 "},{"text":" Another example (graphics objects): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Bit-wise Structs49/56 "},{"text":" The graphics object would be stored in memory as: "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Bit-wise Structs50/56 "},{"text":" Bit-fields provide an alternative to bit operators and masks: "},{"text":""},{"text":" "},{"text":""},{"text":" Unions51/56 "},{"text":" Unions allow programmers to specify multiple interpretations for a single piece of memory. "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Unions52/56 "},{"text":" Example of defining a union type (cf. struct): "},{"text":""},{"text":" myUnion is a single 4-byte memory object "},{"text":" Programmers can specify how to interpret bits using field names. "},{"text":" In the example above, all components are coincidentally the same size (4 bytes) "},{"text":""},{"text":" ... Unions53/56 "},{"text":" Difference between a struct and a union "},{"text":""},{"text":" "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Unions54/56 "},{"text":" General syntax for defining union types and variables: "},{"text":""},{"text":" Type can be any C type; Member names must be distinct "},{"text":" sizeof(Union) is the size of the largest member "},{"text":" &uvar.Member1 == &uvar.Member2 == &uvar.Member3 ... "},{"text":""},{"text":" ... Unions55/56 "},{"text":" Common use of union types: \"generic\" variables "},{"text":""},{"text":" "},{"text":""},{"text":" Enumerated Types56/56 "},{"text":" Enumerated types allow programmers to define a set of distinct named values "},{"text":" "},{"text":""},{"text":" The names are assigned consecutive int values, starting from 0 "},{"text":" Above PrimaryColors type is equivalent to "},{"text":""},{"text":" Variables of type enum... are effectively unsigned ints. "},{"text":""},{"text":" Produced: 1 Mar 2018 "}],"allLists":[{"type":"list"}," a location in memory ",{"type":"list"}," a value (ultimately just a bit-string) ",{"type":"list"}," a name (unless created by malloc()) ",{"type":"list"}," a type, which determines ... its size (in units of whole bytes, sizeof) how to interpret its value what operations apply to the value ",{"type":"list"}," its size (in units of whole bytes, sizeof) ",{"type":"list"}," how to interpret its value ",{"type":"list"}," what operations apply to the value ",{"type":"list"}," a scope (where it's visible within the program) ",{"type":"list"}," a lifetime (during which part of program execution it exists) ",{"type":"list"}," global variables, static variables, string constants ",{"type":"list"}," objects persist for entire duration of program execution ",{"type":"list"}," objects created by malloc, calloc, ... ",{"type":"list"}," objects persist in heap until explicitly free'd ",{"type":"list"}," a small region (frame) for each active function ",{"type":"list"}," frames contain local variables and parameters ",{"type":"list"}," a frame is created when a function is called ",{"type":"list"}," the frame is removed when the function returns ",{"type":"list"}," relatively large (e.g. 228 bytes) ",{"type":"list"}," any byte can be fetched with same cost ",{"type":"list"}," cost of fetching 1,2,4,8 bytes is small (ns) ",{"type":"list"}," volatile (e.g. DRAM) ... data lost when powered off ",{"type":"list"}," non-volatile (e.g. EEPROM) ... data stays when powered off ",{"type":"list"}," any byte address can be used to fetch 1-byte object ",{"type":"list"}," byte address for N-byte object must be divisible by N ",{"type":"list"}," load bit-strings of sizes 1,2,4,8 bytes ",{"type":"list"}," from N-byte boundary addresses ",{"type":"list"}," into registers in the CPU ",{"type":"list"}," ASCII (ISO 646) 7-bit values, using lower 7-bits of a byte (top bit always zero) can encode roman alphabet, digits, punctuation, control chars ",{"type":"list"}," 7-bit values, using lower 7-bits of a byte (top bit always zero) ",{"type":"list"}," can encode roman alphabet, digits, punctuation, control chars ",{"type":"list"}," UTF-8 (Unicode) 8-bit values, with ability to extend to multi-byte values can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) ",{"type":"list"}," 8-bit values, with ability to extend to multi-byte values ",{"type":"list"}," can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) ",{"type":"list"}," control characters (0..31) ... e.g. '\\0', '\\n' ",{"type":"list"}," punctuation chars (32..47,91..96,123..126) ",{"type":"list"}," digits (48..57) ... '0'..'9' ",{"type":"list"}," upper case alphabetic (65..90) ... 'A'..'Z' ",{"type":"list"}," lower case alphabetic (97..122) ... 'a'..'z' ",{"type":"list"}," not all writing systems use a small set of discrete symbols ",{"type":"list"}," around 140K symbols, covering 140 different languages ",{"type":"list"}," e.g. standard roman alphabet + punctuation needs only 7-bits ",{"type":"list"}," \\uHexDigits ... insert Unicode code value ",{"type":"list"}," \\x2HexDigits ... insert individual bytes ",{"type":"list"}," integer ... subset (range) of the mathematical integers ",{"type":"list"}," floating point ... subset of the mathematical real numbers ",{"type":"list"}," 42 ... signed decimal (0..9) ",{"type":"list"}," 0x2A ... unsigned hexadecimal (0..F) ",{"type":"list"}," 052 ... signed octal (0 ..7) ",{"type":"list"}," 123U ... unsigned int value (typically 32 bits) ",{"type":"list"}," 123L ... long int value (typically 64 bits) ",{"type":"list"}," 123S ... short int value (typically 16 bits) ",{"type":"list"}," 4294967296, -1U, 666666S, 078 ",{"type":"list"}," commonly 32 bits, storing values in the range 0 .. 232-1 ",{"type":"list"}," commonly 32 bits, storing values in the range -231 .. 231-1 ",{"type":"list"}," signed magnitude ... first bit is sign, rest are magnitude ",{"type":"list"}," ones complement ... form -N by inverting all bits in N ",{"type":"list"}," twos complement ... form -N by inverting N and adding 1 ",{"type":"list"}," 10000101 ... signed magnitude ",{"type":"list"}," 11111010 ... ones complement ",{"type":"list"}," 11111011 ... twos complement ",{"type":"list"}," what do these numbers represent? 00000000, 10000000 ",{"type":"list"}," what do these numbers represent? 00000000, 11111111 ",{"type":"list"}," -0 = ~00000000+1 = 11111111+1 = 00000000 ",{"type":"list"}," number of bits depends on memory size, but typically 32-bits ",{"type":"list"}," data pointers reference addresses in data/heap/stack regions ",{"type":"list"}," function pointers reference addresses in code region ",{"type":"list"}," sizeof(int *) = sizeof(char *) = sizeof(double *) = sizeof(struct X *) ",{"type":"list"}," (char *) ... can reference any byte address ",{"type":"list"}," (int *) ... must have addr %4 == 0 ",{"type":"list"}," (double *) ... must have addr %8 == 0 ",{"type":"list"}," many real values don't have exact representation (e.g. 1/3) ",{"type":"list"}," results of calculations may contain small inaccuracies ",{"type":"list"}," numbers close to zero have higher precision (more accurate) ",{"type":"list"}," numbers further from zero have lower precision (less accurate) ",{"type":"list"}," float ... typically 32-bit quantity (lower precision, narrower range) ",{"type":"list"}," double ... typically 64-bit quantity (higher precision, wider range) ",{"type":"list"}," scientific notation with fraction F and exponent E ",{"type":"list"}," numbers have form F √ó 2E, where both F and E can be -ve ",{"type":"list"}," INFINITY = representation for ‚àû and -‚àû (e.g. 1.0/0) ",{"type":"list"}," NAN = representation for invalid value NaN (e.g. sqrt(-1.0)) ",{"type":"list"}," 32-bit single-precision, 64-bit double precision ",{"type":"list"}," 1010.1011 is normalized as 1.0101011√ó2011 ",{"type":"list"}," 1010.1011 = 10 + 11/16 = 10.6875 ",{"type":"list"}," 1.0101011√ó2011 = (1 + 43/128) * 23 = 1.3359375 * 8 = 10.6875 ",{"type":"list"}," fraction part is always 1.bbbbbbbb; don't store 1 ",{"type":"list"}," exponent is offset relative to a baseline -2b-1-1, b = #exponent bits ",{"type":"list"}," the baseline (aka bias) is 127, the exponent is 27 ",{"type":"list"}," so, in the exponent, we store 127+7 = 134 = 10000110 ",{"type":"list"}," individual array elements are accessed via indices 0..N-1 ",{"type":"list"}," total amount of space allocated to array N √ó sizeof(Type ) ",{"type":"list"}," constant strings have '\\0' added automatically ",{"type":"list"}," string buffers must allow for element to hold '\\0' ",{"type":"list"}," each component has a Name and a Type ",{"type":"list"}," define the dynamic object as the last component ",{"type":"list"}," malloc() more space than the struct requires ",{"type":"list"}," to make the final component as large as required ",{"type":"list"}," C allows programmers to specify structs bit-wise ",{"type":"list"}," specify unnamed components using standard types ",{"type":"list"}," specify named individual bit fields in each component "]}