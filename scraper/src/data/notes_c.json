{"grouped":[{"tags":["table"],"items":[{"text":"Instruction Set Architectures"}]},{"tags":["table"],"items":[{"text":"CPU Architecture2/114"}]},{"tags":["table"],"items":[{"text":"Why Study Assembler?3/114"}]},{"tags":["table"],"items":[{"text":"Instruction Sets4/114"}]},{"tags":["table"],"items":[{"text":"... Instruction Sets5/114"}]},{"tags":["table"],"items":[{"text":"... Instruction Sets6/114"}]},{"tags":["table"],"items":[{"text":"... Instruction Sets7/114"}]},{"tags":["table"],"items":[{"text":"... Instruction Sets8/114"}]},{"tags":["table"],"items":[{"text":"Fetch-Execute Cycle9/114"}]},{"tags":["table"],"items":[{"text":"... Fetch-Execute Cycle10/114"}]},{"tags":["table"],"items":[{"text":"Assembly Language11/114"}]},{"tags":["table"],"items":[{"text":"... Assembly Language12/114"}]},{"tags":["table"],"items":[{"text":"MIPS Architecture13/114"}]},{"tags":["table"],"items":[{"text":"MIPS vs SPIM14/114"}]},{"tags":["table"],"items":[{"text":"Using SPIM15/114"}]},{"tags":["table"],"items":[{"text":"... Using SPIM16/114"}]},{"tags":["table"],"items":[{"text":"... Using SPIM17/114"}]},{"tags":["table"],"items":[{"text":"MIPS Machine Archtecture18/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Machine Archtecture19/114"}]},{"tags":["table"],"items":[{"text":"Reg Name Notes"},{"text":" $0 zero the value 0, not changeable "},{"text":" $1 $at assembler temporary; used to implement pseudo-ops "},{"text":" $2 $v0 value from expression evaluation or function return "},{"text":" $3 $v1 value from expression evaluation or function return "},{"text":" $4 $a0 first argument to a function/subroutine, if needed "},{"text":" $5 $a1 second argument to a function/subroutine, if needed "},{"text":" $6 $a2 third argument to a function/subroutine, if needed "},{"text":" $7 $a3 fourth argument to a function/subroutine, if needed "},{"text":" $8..$15 $t0..$t7 temporary; must be saved by caller to subroutine;subroutine can overwrite "}]},{"tags":["table"],"items":[{"text":"... MIPS Machine Archtecture20/114"}]},{"tags":["table"],"items":[{"text":"Reg Name Notes"},{"text":" $16..$23 $s0..$s7 safe function variable;must not be overwritten by called subroutine "},{"text":" $24..$25 $t8..$t9 temporary; must be saved by caller to subroutine;subroutine can overwrite "},{"text":" $26..$27 $k0..$k1 for kernel use; may change unexpectedly "},{"text":" $28 $gp global pointer "},{"text":" $29 $sp stack pointer "},{"text":" $30 $fp frame pointer "},{"text":" $31 $ra return address of most recent caller "}]},{"tags":["table"],"items":[{"text":"... MIPS Machine Archtecture21/114"}]},{"tags":["table"],"items":[{"text":"Reg Notes"},{"text":" "},{"text":" $f0..$f2 hold floating-point function results "},{"text":" $f4..$f10 temporary registers; not preserved across function calls "},{"text":" $f12..$f14 used for first two double-precision function arguments "},{"text":" $f16..$f18 temporary registers; used for expression evaluation "},{"text":" $f20..$f30 saved registers; value is preserved across function calls "}]},{"tags":["table"],"items":[{"text":"MIPS Assembly Language22/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Assembly Language23/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Assembly Language24/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Assembly Language25/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Assembly Language26/114"}]},{"tags":["table"],"items":[{"text":"Region Address Notes"},{"text":" text 0x00400000 contains only instructions; read-only; cannot expand "},{"text":" data 0x10000000 data objects; readable/writeable; can be expanded "},{"text":" stack 0x7fffefff grows down from that address; readable/writeable "},{"text":" k_text 0x80000000 kernel code; read-only; only accessible kernel mode "},{"text":" k_data 0x90000000 kernel data; read/write; only accessible kernel mode "}]},{"tags":["table"],"items":[{"text":"MIPS Instructions27/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Instructions28/114"}]},{"tags":["table"],"items":[{"text":"Addressing Modes29/114"}]},{"tags":["table"],"items":[{"text":"... Addressing Modes30/114"}]},{"tags":["table"],"items":[{"text":"Format Address computation"},{"text":" (register) address = *register = contents of register "},{"text":" k address = k "},{"text":" k(register) address = k + *register "},{"text":" symbol address = &symbol = address of symbol "},{"text":" symbol ± k address = &symbol ± k "},{"text":" symbol ± k(register) address = &symbol ± (k + *register) "}]},{"tags":["table"],"items":[{"text":"... Addressing Modes31/114"}]},{"tags":["table"],"items":[{"text":"Operand Sizes32/114"}]},{"tags":["table"],"items":[{"text":"MIPS Instruction Set33/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set34/114"}]},{"tags":["table"],"items":[{"text":"SyntaxSemantics"},{"text":" $Reg as source, the content of the register, reg[Reg]"},{"text":" $Reg as destination, value is stored in register, reg[Reg] = value"},{"text":" Label references the associated address (in C terms, &Label) "},{"text":" Addr any expression that yields an address (e.g. Label($Reg)) "},{"text":" Addr as source, the content of memory cell memory[Addr]"},{"text":" Addr as destination, value is stored in memory[Addr] = value"}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set35/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set36/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set37/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set38/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set39/114"}]},{"tags":["table"],"items":[{"text":"ServiceCodeArgumentsResult"},{"text":" print_int1$a0 = integer "},{"text":" print_float2$f12 = float "},{"text":" print_double3$f12 = double "},{"text":" print_string4$a0 = char * "},{"text":" read_int5 integer in $v0 "},{"text":" read_float6 float in $f0 "},{"text":" read_double7 double in $f0 "},{"text":" read_string8$a0 = buffer, $a1 = lengthstring in buffer (including \"\\n\\0\") "}]},{"tags":["table"],"items":[{"text":"... MIPS Instruction Set40/114"}]},{"tags":["table"],"items":[{"text":"MIPS Programming41/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Programming42/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Programming43/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Programming44/114"}]},{"tags":["table"],"items":[{"text":"... MIPS Programming45/114"}]},{"tags":["table"],"items":[{"text":"Rendering C in MIPS46/114"}]},{"tags":["table"],"items":[{"text":"... Rendering C in MIPS47/114"}]},{"tags":["table"],"items":[{"text":"Arithmetic Expressions48/114"}]},{"tags":["table"],"items":[{"text":"Conditional Statements49/114"}]},{"tags":["table"],"items":[{"text":"... Conditional Statements50/114"}]},{"tags":["table"],"items":[{"text":"... Conditional Statements51/114"}]},{"tags":["table"],"items":[{"text":"... Conditional Statements52/114"}]},{"tags":["table"],"items":[{"text":"... Conditional Statements53/114"}]},{"tags":["table"],"items":[{"text":"Boolean Expressions54/114"}]},{"tags":["table"],"items":[{"text":"... Boolean Expressions55/114"}]},{"tags":["table"],"items":[{"text":"Iteration Statements56/114"}]},{"tags":["table"],"items":[{"text":"... Iteration Statements57/114"}]},{"tags":["table"],"items":[{"text":"Functions58/114"}]},{"tags":["table"],"items":[{"text":"... Functions59/114"}]},{"tags":["table"],"items":[{"text":"... Functions60/114"}]},{"tags":["table"],"items":[{"text":"... Functions61/114"}]},{"tags":["table"],"items":[{"text":"... Functions62/114"}]},{"tags":["table"],"items":[{"text":"... Functions63/114"}]},{"tags":["table"],"items":[{"text":"Aside: MIPS Branch Delay Slots64/114"}]},{"tags":["table"],"items":[{"text":"Aside: Why do we need both $fp and $sp?65/114"}]},{"tags":["table"],"items":[{"text":"Function Calling Protocol66/114"}]},{"tags":["table"],"items":[{"text":"... Function Calling Protocol67/114"}]},{"tags":["table"],"items":[{"text":"... Function Calling Protocol68/114"}]},{"tags":["table"],"items":[{"text":"... Function Calling Protocol69/114"}]},{"tags":["table"],"items":[{"text":"... Function Calling Protocol70/114"}]},{"tags":["table"],"items":[{"text":"... Function Calling Protocol71/114"}]},{"tags":["table"],"items":[{"text":"... Function Calling Protocol72/114"}]},{"tags":["table"],"items":[{"text":"Structure of Functions73/114"}]},{"tags":["table"],"items":[{"text":"Function Prologue74/114"}]},{"tags":["table"],"items":[{"text":"... Function Prologue75/114"}]},{"tags":["table"],"items":[{"text":"... Function Prologue76/114"}]},{"tags":["table"],"items":[{"text":"... Function Prologue77/114"}]},{"tags":["table"],"items":[{"text":"Function Epilogue78/114"}]},{"tags":["table"],"items":[{"text":"... Function Epilogue79/114"}]},{"tags":["table"],"items":[{"text":"Data Structures and MIPS80/114"}]},{"tags":["table"],"items":[{"text":"Static vs Dynamic Allocation81/114"}]},{"tags":["table"],"items":[{"text":"... Static vs Dynamic Allocation82/114"}]},{"tags":["table"],"items":[{"text":"... Static vs Dynamic Allocation83/114"}]},{"tags":["table"],"items":[{"text":"... Static vs Dynamic Allocation84/114"}]},{"tags":["table"],"items":[{"text":"... Static vs Dynamic Allocation85/114"}]},{"tags":["table"],"items":[{"text":"... Static vs Dynamic Allocation86/114"}]},{"tags":["table"],"items":[{"text":"1-d Arrays in MIPS87/114"}]},{"tags":["table"],"items":[{"text":"... 1-d Arrays in MIPS88/114"}]},{"tags":["table"],"items":[{"text":"... 1-d Arrays in MIPS89/114"}]},{"tags":["table"],"items":[{"text":"... 1-d Arrays in MIPS90/114"}]},{"tags":["table"],"items":[{"text":"2-d Arrays in MIPS91/114"}]},{"tags":["table"],"items":[{"text":"... 2-d Arrays in MIPS92/114"}]},{"tags":["table"],"items":[{"text":"... 2-d Arrays in MIPS93/114"}]},{"tags":["table"],"items":[{"text":"... 2-d Arrays in MIPS94/114"}]},{"tags":["table"],"items":[{"text":"... 2-d Arrays in MIPS95/114"}]},{"tags":["table"],"items":[{"text":"Structs in MIPS96/114"}]},{"tags":["table"],"items":[{"text":"... Structs in MIPS97/114"}]},{"tags":["table"],"items":[{"text":"... Structs in MIPS98/114"}]},{"tags":["table"],"items":[{"text":"... Structs in MIPS99/114"}]},{"tags":["table"],"items":[{"text":"... Structs in MIPS100/114"}]},{"tags":["table"],"items":[{"text":"... Structs in MIPS101/114"}]},{"tags":["table"],"items":[{"text":"... Structs in MIPS102/114"}]},{"tags":["table"],"items":[{"text":"Compiling C to MIPS103/114"}]},{"tags":["table"],"items":[{"text":"C Pre-processor104/114"}]},{"tags":["table"],"items":[{"text":"... C Pre-processor105/114"}]},{"tags":["table"],"items":[{"text":"C Parser106/114"}]},{"tags":["table"],"items":[{"text":"Symbol Table Management107/114"}]},{"tags":["table"],"items":[{"text":"Local Variables108/114"}]},{"tags":["table"],"items":[{"text":"Expression Evaluation109/114"}]},{"tags":["table"],"items":[{"text":"Mapping Control Structures110/114"}]},{"tags":["table"],"items":[{"text":"... Mapping Control Structures111/114"}]},{"tags":["table"],"items":[{"text":" Argc and Argv112/114"}]},{"tags":["table"],"items":[{"text":"... Argc and Argv113/114"}]},{"tags":["table"],"items":[{"text":"... Argc and Argv114/114"}]},{"tags":["list"],"items":[{"text":" a set of data registers "},{"text":" a set of control registers (incl PC) "},{"text":" an arithmetic-logic unit (ALU) "},{"text":" access to random access memory (RAM) "},{"text":" a set of simple instructions transfer data between memory and registers push values through the ALU to compute results make tests and transfer control of execution "},{"text":" transfer data between memory and registers "},{"text":" push values through the ALU to compute results "},{"text":" make tests and transfer control of execution "}]},{"tags":["list"],"items":[{"text":" transfer data between memory and registers "},{"text":" push values through the ALU to compute results "},{"text":" make tests and transfer control of execution "}]},{"tags":["list"],"items":[{"text":" e.g. different # registers, different sized registers, different instructions "}]},{"tags":["list"],"items":[{"text":" sometimes you are required to use it (e.g. device handlers) "},{"text":" improves your understanding of how C programs execute very helpful when debugging able to avoid using known inefficient constructs "},{"text":" very helpful when debugging "},{"text":" able to avoid using known inefficient constructs "},{"text":" uber-nerdy performance tweaking (squeezing out last nano-s) re-write that critical (frequently-used) function in assembler "},{"text":" re-write that critical (frequently-used) function in assembler "}]},{"tags":["list"],"items":[{"text":" very helpful when debugging "},{"text":" able to avoid using known inefficient constructs "}]},{"tags":["list"],"items":[{"text":" re-write that critical (frequently-used) function in assembler "}]},{"tags":["list"],"items":[{"text":" small(ish) set of simple, general instructions "},{"text":" separate computation & data transfer instructions "},{"text":" leading to simpler processor hardware "},{"text":" e.g. MIPS, RISC, Alpha, SPARC, PowerPC, ARM, ... "}]},{"tags":["list"],"items":[{"text":" large(r) set of powerful instructions "},{"text":" each instruction has multiple actions (comp+store) "},{"text":" more circuitry to decode/process instructions "},{"text":" e.g. PDP, VAX, Z80, Motorola 68xxx, Intel x86, ... "}]},{"tags":["list"],"items":[{"text":" typically have 1-2 32-bit words per instruction "},{"text":" partition bits in each word into operator & operands "},{"text":" #bits for each depends on #instructions, #registers, ... "}]},{"tags":["list"],"items":[{"text":" load Register, MemoryAddress copy value stored in memory at address into named register "},{"text":" copy value stored in memory at address into named register "},{"text":" loadc Register, ConstantValue copy value into named register "},{"text":" copy value into named register "},{"text":" store Register, MemoryAddress copy value stored in named register into memory at address "},{"text":" copy value stored in named register into memory at address "},{"text":" jump MemoryAddress transfer execution of program to instruction at address "},{"text":" transfer execution of program to instruction at address "},{"text":" jumpif Register, MemoryAddress transfer execution of program if e.g. register holds zero value "},{"text":" transfer execution of program if e.g. register holds zero value "}]},{"tags":["list"],"items":[{"text":" copy value stored in memory at address into named register "}]},{"tags":["list"],"items":[{"text":" copy value into named register "}]},{"tags":["list"],"items":[{"text":" copy value stored in named register into memory at address "}]},{"tags":["list"],"items":[{"text":" transfer execution of program to instruction at address "}]},{"tags":["list"],"items":[{"text":" transfer execution of program if e.g. register holds zero value "}]},{"tags":["list"],"items":[{"text":" add Register1, Register2, Register3 (similarly for sub, mul, div) Register3 = Register1 + Register2 "},{"text":" Register3 = Register1 + Register2 "},{"text":" and Register1, Register2, Register3 (similarly for or, xor) Register3 = Register1 & Register2 "},{"text":" Register3 = Register1 & Register2 "},{"text":" neg Register1, Register2 Register2 = ~ Register1 "},{"text":" Register2 = ~ Register1 "},{"text":" shiftl Register1, Value, Register2 (similarly for shiftr) Register2 = Register1 << Value "},{"text":" Register2 = Register1 << Value "},{"text":" syscall Value invoke a system service; which service determined by Value "},{"text":" invoke a system service; which service determined by Value "}]},{"tags":["list"],"items":[{"text":" Register3 = Register1 + Register2 "}]},{"tags":["list"],"items":[{"text":" Register3 = Register1 & Register2 "}]},{"tags":["list"],"items":[{"text":" Register2 = ~ Register1 "}]},{"tags":["list"],"items":[{"text":" Register2 = Register1 << Value "}]},{"tags":["list"],"items":[{"text":" invoke a system service; which service determined by Value "}]},{"tags":["list"],"items":[{"text":" determine what the operator is "},{"text":" determine which registers, if any, are involved "},{"text":" determine which memory location, if any, is involved "},{"text":" carry out the operation with the relevant operands "},{"text":" store result, if any, in appropriate register "}]},{"tags":["list"],"items":[{"text":" write instructions using mnemonics rather than hex codes "},{"text":" reference registers using either numbers or names "},{"text":" can associate names to memory addresses "}]},{"tags":["list"],"items":[{"text":" need to use fine-grained control of memory usage "},{"text":" required to manipulate data in registers "},{"text":" control structures programmed via explicit jumps "}]},{"tags":["list"],"items":[{"text":" very popular in a range of computing devices in the 1990's "},{"text":" e.g. Silicon Graphics, NEC, Nintendo64, Playstation, supercomputers "}]},{"tags":["list"],"items":[{"text":" using two variants of the open-source SPIM emulator "},{"text":" qtspim ... provides a GUI front-end, useful for debugging "},{"text":" spim ... command-line based version, useful for testing "},{"text":" xspim ... GUI front-end, useful for debugging, only in CSE labs "}]},{"tags":["list"],"items":[{"text":" reads text files containing instruction + directives "},{"text":" converts to machine code and loads into \"memory\" "},{"text":" provides debugging capabilities single-step, breakpoints, view registers/memory, ... "},{"text":" single-step, breakpoints, view registers/memory, ... "},{"text":" provides mechanism to interact with operating system (syscall) "}]},{"tags":["list"],"items":[{"text":" single-step, breakpoints, view registers/memory, ... "}]},{"tags":["list"],"items":[{"text":" provide convenient/mnemonic ways to do common operations "},{"text":" e.g. move $s0,$v0 rather than addu $s0,$0,$v0 "}]},{"tags":["list"],"items":[{"text":" spim ... command line tool load programs using -file option interact using stdin/stdout via login terminal "},{"text":" load programs using -file option "},{"text":" interact using stdin/stdout via login terminal "},{"text":" qtspim ... GUI environment load programs via a load button interact via a pop-up stdin/stdout terminal "},{"text":" load programs via a load button "},{"text":" interact via a pop-up stdin/stdout terminal "},{"text":" xspim ... GUI environment similar to qtspim, but not as pretty requires X-windows server "},{"text":" similar to qtspim, but not as pretty "},{"text":" requires X-windows server "}]},{"tags":["list"],"items":[{"text":" load programs using -file option "},{"text":" interact using stdin/stdout via login terminal "}]},{"tags":["list"],"items":[{"text":" load programs via a load button "},{"text":" interact via a pop-up stdin/stdout terminal "}]},{"tags":["list"],"items":[{"text":" similar to qtspim, but not as pretty "},{"text":" requires X-windows server "}]},{"tags":["list"],"items":[{"text":" 32 × 32-bit general purpose registers "},{"text":" 16 × 64-bit double-precision registers "},{"text":" PC ... 32-bit register (always aligned on 4-byte boundary) "},{"text":" HI,LO ... for storing results of multiplication and division "}]},{"tags":["list"],"items":[{"text":" register $0 always has value 0, cannot be written "},{"text":" registers $1, $26, $27 reserved for use by system "}]},{"tags":["list"],"items":[{"text":" registers come in pairs of 2 × 32-bits "},{"text":" only even registers are addressed for double-precision "}]},{"tags":["list"],"items":[{"text":" comments ... introduced by # "},{"text":" labels ... appended with : "},{"text":" directives ... symbol beginning with . "},{"text":" assembly language instructions "}]},{"tags":["list"],"items":[{"text":" data objects that live in the data region "},{"text":" functions (instruction sequences) that live in the code/text region "}]},{"tags":["list"],"items":[{"text":" load and store .. transfer data between registers and memory "},{"text":" computational ... perform arithmetic/logical operations "},{"text":" jump and branch ... transfer control of program execution "},{"text":" coprocessor ... standard interface to various co-processors "},{"text":" special ... miscellaneous tasks (e.g. syscall) "}]},{"tags":["list"],"items":[{"text":" between memory and register (direct, indirect) "},{"text":" constant to register (immediate) "},{"text":" register + register + destination register "}]},{"tags":["list"],"items":[{"text":" an operation (e.g. load, store, add, branch, ...) "},{"text":" one or more operands (e.g. registers, memory addresses, constants) "}]},{"tags":["list"],"items":[{"text":" symbolic name (label) (effectively, a constant) "},{"text":" indirectly via a register (effectively, pointer dereferencing) "}]},{"tags":["list"],"items":[{"text":" computed address for a: is 0x100000008 "},{"text":" computed address for b: is 0x100000000 "},{"text":" computed address for c: is 0x100000004 "}]},{"tags":["list"],"items":[{"text":" single bytes, two bytes (\"halfword\"), four bytes (\"word\") "}]},{"tags":["list"],"items":[{"text":" LB ... load one byte from specified address "},{"text":" LBU ... load unsigned byte from specified address "},{"text":" LH ... load two bytes from specified address "},{"text":" LHU ... load unsigned 2-bytes from specified address "},{"text":" LW ... load four bytes (one word) from specified address "},{"text":" LA ... load the specified address "}]},{"tags":["list"],"items":[{"text":" lw, sw, add, sub, and, or, sll, slt, beq, j, jal, ... "}]},{"tags":["list"],"items":[{"text":" move, rem, la, li, blt, ... "}]},{"tags":["list"],"items":[{"text":" treat registers as unsigned int reg[32] "},{"text":" treat memory as unsigned char mem[232] "}]},{"tags":["list"],"items":[{"text":" develop the solution in C "},{"text":" map to \"simplified\" C "},{"text":" translate each simplified C statement to MIPS instructions "}]},{"tags":["list"],"items":[{"text":" does not have while, switch, complex expressions "},{"text":" does have simple if, goto, one-operator expressions "},{"text":" does not have function calls and auto local variables "},{"text":" does have jump-and-remember-where-you-came-from "}]},{"tags":["list"],"items":[{"text":" labels ... symbolic name for C statement "},{"text":" goto ... transfer control to labelled statement "}]},{"tags":["list"],"items":[{"text":" follow the conventions implied by register names "},{"text":" preserve values that need to be saved across function calls "}]},{"tags":["list"],"items":[{"text":" you manage register usage as you like "},{"text":" typically making use of $t? registers "}]},{"tags":["list"],"items":[{"text":" you transfer control to a separate piece of code "},{"text":" which may change the value of any non-preserved register "},{"text":" $s? registers must be preserved by function "},{"text":" $a?, $v?, $t? registers may be modified by function "}]},{"tags":["list"],"items":[{"text":" x = (1 + y*y) / 2; z = 1.0 / 2; ... "}]},{"tags":["list"],"items":[{"text":" move Rd,Rs, li Rd,Const, add, div, and, ... "}]},{"tags":["list"],"items":[{"text":" sequence (;), if, while, for, break, continue, ... "}]},{"tags":["list"],"items":[{"text":" seq, slti, sltu, ..., beq, bgtz, bgezal, ..., j, jr, jal, ... "}]},{"tags":["list"],"items":[{"text":" describing the process as a sequence of binary operations "},{"text":" managing data flow between the operations "}]},{"tags":["list"],"items":[{"text":" works best for small, dense range of case values (e.g. 1..10) "}]},{"tags":["list"],"items":[{"text":" evaluate Cond1; if 0 then return 0 for whole expression "},{"text":" evaluate Cond2; if 0 then return 0 for whole expression "},{"text":" ... "},{"text":" evaluate Condn; if 0 then return 0 for whole expression "},{"text":" otherwise, return 1 "}]},{"tags":["list"],"items":[{"text":" evaluate Cond1; if !0 then return 1 for whole expression "},{"text":" evaluate Cond2; if !0 then return 1 for whole expression "},{"text":" ... "},{"text":" evaluate Condn; if !0 then return 1 for whole expression "},{"text":" otherwise, return 1 "}]},{"tags":["list"],"items":[{"text":" the arguments are evaluated and set up for function "},{"text":" control is transferred to the code for the function "},{"text":" local variables are created "},{"text":" the function code is executed in this environment "},{"text":" the return value is set up "},{"text":" control transfers back to where the function was called from "},{"text":" the caller receives the return value "}]},{"tags":["list"],"items":[{"text":" used for: saved registers, local variables, parameters to callees "},{"text":" created in the function prologue (pushed) "},{"text":" removed in the function epilogue (popped) "}]},{"tags":["list"],"items":[{"text":" function f() calls g() which calls h() "},{"text":" h() runs, then finishes and returns to g() "},{"text":" g() continues, then finishes and returns to f() "}]},{"tags":["list"],"items":[{"text":" caller saved registers (saved by f()) f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" e.g. $t0 .. $t9, $a0 .. $a3, $ra "},{"text":" f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" "},{"text":" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" "},{"text":" e.g. $t0 .. $t9, $a0 .. $a3, $ra "},{"text":" callee saved registers (saved by g()) f() tells g() \"I assume the values of these registers will be unchanged when you return\" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" e.g. $s0 .. $s7, $sp, $fp "},{"text":" f() tells g() \"I assume the values of these registers will be unchanged when you return\" "},{"text":" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" "},{"text":" e.g. $s0 .. $s7, $sp, $fp "}]},{"tags":["list"],"items":[{"text":" f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" "},{"text":" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" "},{"text":" e.g. $t0 .. $t9, $a0 .. $a3, $ra "}]},{"tags":["list"],"items":[{"text":" f() tells g() \"I assume the values of these registers will be unchanged when you return\" "},{"text":" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" "},{"text":" e.g. $s0 .. $s7, $sp, $fp "}]},{"tags":["list"],"items":[{"text":" one instruction can start before the previous one finishes "}]},{"tags":["list"],"items":[{"text":" instruction following branch is executed before branch completes "}]},{"tags":["list"],"items":[{"text":" $sp can change (e.g. pushing params, adding local vars) "},{"text":" may need to reference local vars on the stack "},{"text":" useful if they can be defined by an offset relative to fixed point "},{"text":" $fp provides a fixed point during function code execution "}]},{"tags":["list"],"items":[{"text":" place 64-bit double args in $f12 and $f14 "},{"text":" place 32-bit arguments in the $a0..$a3 "},{"text":" if more than 4 args, or args larger than 32-bits ... push value of all such args onto stack "},{"text":" push value of all such args onto stack "},{"text":" save any non-$s? registers that need to be preserved push value of all such registers onto stack "},{"text":" push value of all such registers onto stack "},{"text":" jal address of function (usually given by a label) "}]},{"tags":["list"],"items":[{"text":" push value of all such args onto stack "}]},{"tags":["list"],"items":[{"text":" push value of all such registers onto stack "}]},{"tags":["list"],"items":[{"text":" create a stack frame for itself (change $fp and $sp) "},{"text":" save the return address ($ra) in the stack frame "},{"text":" save any $s? registers that it plans to change "}]},{"tags":["list"],"items":[{"text":" 4 bytes for saved $fp + 4 bytes for saved $ra "},{"text":" + 4 bytes for each saved $s? "}]},{"tags":["list"],"items":[{"text":" new $fp = old $sp - 4 "},{"text":" new $sp = old $sp - size of frame (in bytes) "}]},{"tags":["list"],"items":[{"text":" place the return value in $v0 (and maybe $v1) "},{"text":" pop any pushed arguments off the stack "},{"text":" restore the values of any saved $s? registers "},{"text":" restore the saved value of $ra (return address) "},{"text":" remove its stack frame (change $fp and $sp) "},{"text":" return to the calling function (jr $ra) "}]},{"tags":["list"],"items":[{"text":" new $sp = old $fp + 4 "},{"text":" new $fp = memory[old $fp] "}]},{"tags":["list"],"items":[{"text":" char ... as byte in memory, or low-order byte in register "},{"text":" int ... as word in memory, or whole register "},{"text":" double ... as two-words in memory, or $f? register "},{"text":" arrays ... sequence of memory bytes/words, accessed by index "},{"text":" structs ... chunk of memory, accessed by fields/offsets "},{"text":" linked structures ... struct containing address of another struct "}]},{"tags":["list"],"items":[{"text":" could be implemented in register if used in small scope "},{"text":" could be implemented on stack if local to function "},{"text":" could be implemented in .data if need longer persistence "}]},{"tags":["list"],"items":[{"text":" uninitialised memory allocated at compile/assemble-time, e.g. int val; val: .space 4 char str[20]; str: .space 20 int vec[20]; vec: .space 80 "},{"text":" initialised memory allocated at compile/assemble-time, e.g. int val = 5; val: .word 5 int arr[4] = {9,8,7,6}; arr: .word 9, 8, 7, 6 char *msg = \"Hello\\n\"; msg: .asciiz \"Hello\\n\" "}]},{"tags":["list"],"items":[{"text":" variables local to a function "}]},{"tags":["list"],"items":[{"text":" use space allocated on stack during function prologue "},{"text":" referenced during function relative to $fp "},{"text":" space reclaimed from stack in function epilogue "}]},{"tags":["list"],"items":[{"text":" uninitialised block of memory allocated at run-time int *ptr = malloc(sizeof(int)); char *str = malloc(20*sizeof(char)); int *vec = malloc(20*sizeof(int)); *ptr = 5; strcpy(str, \"a string\"); vec[0] = 1; // or *vec = 1; vec[1] = 6; "},{"text":" initialised block of memory allocated at run-time int *vec = calloc(20, sizeof(int)); // vec[i] == 0, for i in 0..19 "}]},{"tags":["list"],"items":[{"text":" but provides syscall 9 to extend .data "},{"text":" before syscall, set $a0 to the number of bytes requested "},{"text":" after syscall, $v0 holds start address of allocated chunk "}]},{"tags":["list"],"items":[{"text":" a complete implementation of C's heap management, i.e. "},{"text":" a large region of memory to manage (syscall 9) "},{"text":" ability to mark chunks of this region as \"in use\" (with size) "},{"text":" ability to maintain list of free chunks "},{"text":" ability to merge free chunks to prevent fragmentation "}]},{"tags":["list"],"items":[{"text":" either approach needs to account for size of elements "}]},{"tags":["list"],"items":[{"text":" must also pass array size, since not available elsewhere "}]},{"tags":["list"],"items":[{"text":" makes things easier for a human to prodcue MIPS code "},{"text":" does not provide an automatic way of translating "},{"text":" this is provided by a compiler (e.g. dcc) "}]},{"tags":["list"],"items":[{"text":" convert #include and #define "},{"text":" parse code to check syntactically valid "},{"text":" manage a list of symbols used in program "},{"text":" decide how to represent data structures "},{"text":" allocate local variables to registers or stack "},{"text":" map control structures to MIPS instructions "}]},{"tags":["list"],"items":[{"text":" #include File replace #include by contents of file \"name.h\" ... uses named File.h <name.h> ... uses File.h in /usr/include "},{"text":" replace #include by contents of file "},{"text":" \"name.h\" ... uses named File.h "},{"text":" <name.h> ... uses File.h in /usr/include "},{"text":" #define Name Constant replace all occurences of symbol Name by Constant e.g #define MAX 5 char array[MAX] → char array[5] "},{"text":" replace all occurences of symbol Name by Constant "},{"text":" e.g #define MAX 5 char array[MAX] → char array[5] "},{"text":" #define Name(Params) Expression replace Name(Params) by SubstitutedExpression e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "},{"text":" replace Name(Params) by SubstitutedExpression "},{"text":" e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "}]},{"tags":["list"],"items":[{"text":" replace #include by contents of file "},{"text":" \"name.h\" ... uses named File.h "},{"text":" <name.h> ... uses File.h in /usr/include "}]},{"tags":["list"],"items":[{"text":" replace all occurences of symbol Name by Constant "},{"text":" e.g #define MAX 5 char array[MAX] → char array[5] "}]},{"tags":["list"],"items":[{"text":" replace Name(Params) by SubstitutedExpression "},{"text":" e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "}]},{"tags":["list"],"items":[{"text":" scope, lifetime, locally/externally defined "},{"text":" disambiguates e.g. x in main() vs x in fun() "},{"text":" resolves symbols to specific locations (data/stack/registers) "},{"text":" external symbols may remain unresolved until linking "},{"text":" however, need to have a type for each external symbol "}]},{"tags":["list"],"items":[{"text":" on the stack ... +persist for whole function, -lw/sw needed in MIPS "},{"text":" in a register ... +efficient, -not many, useful if var used in small scope if need to persist across function calls, use $s? register if used in very localised scope, can use $t? register "},{"text":" if need to persist across function calls, use $s? register "},{"text":" if used in very localised scope, can use $t? register "}]},{"tags":["list"],"items":[{"text":" if need to persist across function calls, use $s? register "},{"text":" if used in very localised scope, can use $t? register "}]},{"tags":["list"],"items":[{"text":" even complex expressions don't generally need > 3-4 registers "}]}],"block":[{"tags":["paragraph"],"text":"C: Assembly Language (MIPS)"},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Instruction Set Architectures "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" CPU Architecture2/114 "},{"tags":["paragraph"],"text":" A typical modern CPU has "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Why Study Assembler?3/114 "},{"tags":["paragraph"],"text":" Useful to know assembly language because ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Instruction Sets4/114 "},{"tags":["paragraph"],"text":" Two broad families of instruction set architectures ... "},{"tags":["paragraph"],"text":" RISC (reduced instruction set computer) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Instruction Sets5/114 "},{"tags":["paragraph"],"text":" Machine-level instructions ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Operands and destination are typically registers "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Instruction Sets6/114 "},{"tags":["paragraph"],"text":" Common kinds of instructions (not from any real machine) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Instruction Sets7/114 "},{"tags":["paragraph"],"text":" Other common kinds of instructions (not from any real machine) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Instruction Sets8/114 "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Fetch-Execute Cycle9/114 "},{"tags":["paragraph"],"text":" All CPUs have program execution logic like: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" PC = Program Counter, a CPU register which keeps track of execution "},{"tags":["paragraph"],"text":" Note that some instructions may modify PC further (e.g. JUMP) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Fetch-Execute Cycle10/114 "},{"tags":["paragraph"],"text":" Executing an instruction involves "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Assembly Language11/114 "},{"tags":["paragraph"],"text":" Instructions are simply bit patterns within a 32-bit bit-string "},{"tags":["paragraph"],"text":" Could describe machine programs as a sequence of hex digits, e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Often call \"assembly language\" as \"assembler\" "},{"tags":["paragraph"],"text":" Slight notational abuse, because \"assembler\" also refers to a program that translates assembly language to machine code "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Assembly Language12/114 "},{"tags":["paragraph"],"text":" Assembler = symbolic language for writing machine code "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS Architecture13/114 "},{"tags":["paragraph"],"text":" MIPS is a well-known and relatively simple architecture "},{"tags":["paragraph"],"text":" Source code for browsing under /home/cs1521/spim/spim "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS vs SPIM14/114 "},{"tags":["paragraph"],"text":" MIPS is a machine architecture, including instruction set "},{"tags":["paragraph"],"text":" SPIM is an emulator for the MIPS instruction set "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Using SPIM15/114 "},{"tags":["paragraph"],"text":" Three ways to execute MIPS code with SPIM "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Using SPIM16/114 "},{"tags":["paragraph"],"text":" Command-line tool: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Using SPIM17/114 "},{"tags":["paragraph"],"text":" GUI tool: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS Machine Archtecture18/114 "},{"tags":["paragraph"],"text":" MIPS CPU has "},{"tags":["paragraph"],"text":" Some registers have special uses e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Machine Archtecture19/114 "},{"tags":["paragraph"],"text":" Registers and their usage "},{"tags":["paragraph"],"text":" Reg Name Notes $0 zero the value 0, not changeable $1 $at assembler temporary; used to implement pseudo-ops $2 $v0 value from expression evaluation or function return $3 $v1 value from expression evaluation or function return $4 $a0 first argument to a function/subroutine, if needed $5 $a1 second argument to a function/subroutine, if needed $6 $a2 third argument to a function/subroutine, if needed $7 $a3 fourth argument to a function/subroutine, if needed $8..$15 $t0..$t7 temporary; must be saved by caller to subroutine;subroutine can overwrite "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Machine Archtecture20/114 "},{"tags":["paragraph"],"text":" More register usage ... "},{"tags":["paragraph"],"text":" Reg Name Notes $16..$23 $s0..$s7 safe function variable;must not be overwritten by called subroutine $24..$25 $t8..$t9 temporary; must be saved by caller to subroutine;subroutine can overwrite $26..$27 $k0..$k1 for kernel use; may change unexpectedly $28 $gp global pointer $29 $sp stack pointer $30 $fp frame pointer $31 $ra return address of most recent caller "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Machine Archtecture21/114 "},{"tags":["paragraph"],"text":" Floating point register usage ... "},{"tags":["paragraph"],"text":" Reg Notes $f0..$f2 hold floating-point function results $f4..$f10 temporary registers; not preserved across function calls $f12..$f14 used for first two double-precision function arguments $f16..$f18 temporary registers; used for expression evaluation $f20..$f30 saved registers; value is preserved across function calls "},{"tags":["paragraph"],"text":" Notes: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS Assembly Language22/114 "},{"tags":["paragraph"],"text":" MIPS assembly language programs contain "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Assembly Language23/114 "},{"tags":["paragraph"],"text":" Example MIPS assembler program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Color coding: label, directive, comment "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Assembly Language24/114 "},{"tags":["paragraph"],"text":" Generic structure of MIPS programs "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Assembly Language25/114 "},{"tags":["paragraph"],"text":" Another example MIPS assembler program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Assembly Language26/114 "},{"tags":["paragraph"],"text":" MIPS programs assume the following memory layout "},{"tags":["paragraph"],"text":" Region Address Notes text 0x00400000 contains only instructions; read-only; cannot expand data 0x10000000 data objects; readable/writeable; can be expanded stack 0x7fffefff grows down from that address; readable/writeable k_text 0x80000000 kernel code; read-only; only accessible kernel mode k_data 0x90000000 kernel data; read/write; only accessible kernel mode "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS Instructions27/114 "},{"tags":["paragraph"],"text":" MIPS has several classes of instructions: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instructions28/114 "},{"tags":["paragraph"],"text":" MIPS instructions are 32-bits long, and specify ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Addressing Modes29/114 "},{"tags":["paragraph"],"text":" Memory addresses can be given by "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" If $s0 contains 0x10000000 and &var = 0x100000008 "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Addressing Modes30/114 "},{"tags":["paragraph"],"text":" Addressing modes in MIPS "},{"tags":["paragraph"],"text":" Format Address computation (register) address = *register = contents of register k address = k k(register) address = k + *register symbol address = &symbol = address of symbol symbol ± k address = &symbol ± k symbol ± k(register) address = &symbol ± (k + *register) "},{"tags":["paragraph"],"text":" where k is a literal constant value (e.g. 4 or 0x10000000) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Addressing Modes31/114 "},{"tags":["paragraph"],"text":" Examples of load/store and addressing: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Operand Sizes32/114 "},{"tags":["paragraph"],"text":" MIPS instructions can manipulate different-sized operands "},{"tags":["paragraph"],"text":" Leads to many opcodes for a (conceptually) single operation, e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS Instruction Set33/114 "},{"tags":["paragraph"],"text":" The MIPS processor implements a base set of instructions, e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Note: use of $at register for intermediate results "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set34/114 "},{"tags":["paragraph"],"text":" In describing instructions: "},{"tags":["paragraph"],"text":" SyntaxSemantics $Reg as source, the content of the register, reg[Reg] $Reg as destination, value is stored in register, reg[Reg] = value Label references the associated address (in C terms, &Label) Addr any expression that yields an address (e.g. Label($Reg)) Addr as source, the content of memory cell memory[Addr] Addr as destination, value is stored in memory[Addr] = value "},{"tags":["paragraph"],"text":" Effectively ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set35/114 "},{"tags":["paragraph"],"text":" Examples of data movement instructions: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Examples of bit manipulation instructions: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set36/114 "},{"tags":["paragraph"],"text":" Examples of arithmetic instructions: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set37/114 "},{"tags":["paragraph"],"text":" Examples of testing and branching instructions: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" After each branch instruction, execution continues at new PC location "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set38/114 "},{"tags":["paragraph"],"text":" Special jump instruction for invoking functions "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set39/114 "},{"tags":["paragraph"],"text":" SPIM interacts with stdin/stdout via syscalls "},{"tags":["paragraph"],"text":" ServiceCodeArgumentsResult print_int1$a0 = integer print_float2$f12 = float print_double3$f12 = double print_string4$a0 = char * read_int5 integer in $v0 read_float6 float in $f0 read_double7 double in $f0 read_string8$a0 = buffer, $a1 = lengthstring in buffer (including \"\\n\\0\") "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Instruction Set40/114 "},{"tags":["paragraph"],"text":" Directives (instructions to assembler, not MIPS instructions) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" MIPS Programming41/114 "},{"tags":["paragraph"],"text":" Writing directly in MIPS assembler is difficult (impossible?) "},{"tags":["paragraph"],"text":" Strategy for producing likely correct MIPS code "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Programming42/114 "},{"tags":["paragraph"],"text":" Example translating C to MIPS: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Programming43/114 "},{"tags":["paragraph"],"text":" Simplified C makes extensive use of "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Programming44/114 "},{"tags":["paragraph"],"text":" Beware: registers are shared by all parts of the code. "},{"tags":["paragraph"],"text":" One function can overwrite value set by another function "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" After the function, x == 6 and y == 120 "},{"tags":["paragraph"],"text":" It is sheer coincidence that y has the correct value. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... MIPS Programming45/114 "},{"tags":["paragraph"],"text":" Need to be careful managing registers "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Rendering C in MIPS46/114 "},{"tags":["paragraph"],"text":" C provides expression evaluation and assignment, e.g. "},{"tags":["paragraph"],"text":" Sequence is easy S1 ; S2 → mips(S1) mips(S2) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Rendering C in MIPS47/114 "},{"tags":["paragraph"],"text":" Simple example of assignment and sequence: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Arithmetic Expressions48/114 "},{"tags":["paragraph"],"text":" Expression evaluation involves "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" It is useful to minimise the number of registers involved in the evaluation "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Conditional Statements49/114 "},{"tags":["paragraph"],"text":" Conditional statements (e.g. if) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Conditional Statements50/114 "},{"tags":["paragraph"],"text":" Conditional statements (e.g. if) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Conditional Statements51/114 "},{"tags":["paragraph"],"text":" Example of if-then-else: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Conditional Statements52/114 "},{"tags":["paragraph"],"text":" Could make switch by first converting to if "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Conditional Statements53/114 "},{"tags":["paragraph"],"text":" Jump table: an alternative implementation of switch "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Boolean Expressions54/114 "},{"tags":["paragraph"],"text":" Boolean expressions in C are short circuit "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Evaluates by "},{"tags":["paragraph"],"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Boolean Expressions55/114 "},{"tags":["paragraph"],"text":" Similarly for disjunctions "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Evaluates by "},{"tags":["paragraph"],"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Iteration Statements56/114 "},{"tags":["paragraph"],"text":" Iteration (e.g. while) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Treat for as a special case of while "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Iteration Statements57/114 "},{"tags":["paragraph"],"text":" Example of iteration over an array: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Functions58/114 "},{"tags":["paragraph"],"text":" When we call a function: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Functions59/114 "},{"tags":["paragraph"],"text":" Data associated with function calls is placed on the MIPS stack. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Functions60/114 "},{"tags":["paragraph"],"text":" Each function allocates a small section of the stack (a frame) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Functions61/114 "},{"tags":["paragraph"],"text":" How stack changes as functions are called and return: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Functions62/114 "},{"tags":["paragraph"],"text":" Register usage conventions when f() calls g(): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Functions63/114 "},{"tags":["paragraph"],"text":" Contents of a typical stack frame: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Aside: MIPS Branch Delay Slots64/114 "},{"tags":["paragraph"],"text":" The real MIPS architecture is \"pipelined\" to improve efficiency "},{"tags":["paragraph"],"text":" A problem scenario, and its solution (branch delay slot): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Since SPIM is not pipelined, the nop is not required "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Aside: Why do we need both $fp and $sp?65/114 "},{"tags":["paragraph"],"text":" During execution of a function "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Function Calling Protocol66/114 "},{"tags":["paragraph"],"text":" Before one function calls another, it needs to "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Calling Protocol67/114 "},{"tags":["paragraph"],"text":" Example: simple function call "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Calling Protocol68/114 "},{"tags":["paragraph"],"text":" Simple function call: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Calling Protocol69/114 "},{"tags":["paragraph"],"text":" Execution of sum() function: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Calling Protocol70/114 "},{"tags":["paragraph"],"text":" Example: function f() calls function g(a,b,c,d,e,f) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Calling Protocol71/114 "},{"tags":["paragraph"],"text":" Function call in MIPS: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Calling Protocol72/114 "},{"tags":["paragraph"],"text":" Execution of g() function: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Structure of Functions73/114 "},{"tags":["paragraph"],"text":" Functions in MIPS have the following general structure: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Aim of prologue: create environment for function to execute in. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Function Prologue74/114 "},{"tags":["paragraph"],"text":" Before a function starts working, it needs to ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Prologue75/114 "},{"tags":["paragraph"],"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Prologue76/114 "},{"tags":["paragraph"],"text":" Alternatively ... (more explicit push) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Prologue77/114 "},{"tags":["paragraph"],"text":" Alternatively ... (relative to new $fp) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Function Epilogue78/114 "},{"tags":["paragraph"],"text":" Before a function returns, it needs to ... "},{"tags":["paragraph"],"text":" Changing $fp and $sp ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Function Epilogue79/114 "},{"tags":["paragraph"],"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Data Structures and MIPS80/114 "},{"tags":["paragraph"],"text":" C data structures and their MIPS representations: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Static vs Dynamic Allocation81/114 "},{"tags":["paragraph"],"text":" Static allocation: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Static vs Dynamic Allocation82/114 "},{"tags":["paragraph"],"text":" Dynamic allocation (i): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Static vs Dynamic Allocation83/114 "},{"tags":["paragraph"],"text":" Example of local variables on the stack: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Static vs Dynamic Allocation84/114 "},{"tags":["paragraph"],"text":" Dynamic allocation (ii): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Static vs Dynamic Allocation85/114 "},{"tags":["paragraph"],"text":" SPIM doesn't provide malloc()/free() functions "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Cannot access allocated data by name; need to retain address. "},{"tags":["paragraph"],"text":" No way to free allocated data, and no way to align data appropriately "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Static vs Dynamic Allocation86/114 "},{"tags":["paragraph"],"text":" Implementing C-like malloc() and free() in MIPS requires "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" 1-d Arrays in MIPS87/114 "},{"tags":["paragraph"],"text":" Can be named/initialised as noted above: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Can access elements via index or cursor (pointer) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 1-d Arrays in MIPS88/114 "},{"tags":["paragraph"],"text":" Scanning across an array of N elements using index "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 1-d Arrays in MIPS89/114 "},{"tags":["paragraph"],"text":" Scanning across an array of N elements using cursor "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 1-d Arrays in MIPS90/114 "},{"tags":["paragraph"],"text":" Arrays that are local to functions are allocated space on the stack "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" 2-d Arrays in MIPS91/114 "},{"tags":["paragraph"],"text":" 2-d arrays could be represented two ways: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 2-d Arrays in MIPS92/114 "},{"tags":["paragraph"],"text":" Representations of int matrix[4][4] ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Now consider summing all elements "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 2-d Arrays in MIPS93/114 "},{"tags":["paragraph"],"text":" Accessing elements: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 2-d Arrays in MIPS94/114 "},{"tags":["paragraph"],"text":" Computing sum of all elements for strategy (a) int matrix[4][4] "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... 2-d Arrays in MIPS95/114 "},{"tags":["paragraph"],"text":" Computing sum of all elements for strategy (b) int matrix[4][4] "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Structs in MIPS96/114 "},{"tags":["paragraph"],"text":" C structs hold a collection of values accessed by name "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs in MIPS97/114 "},{"tags":["paragraph"],"text":" C struct definitions effectively define a new type. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Instances of structures can be created by allocating space: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs in MIPS98/114 "},{"tags":["paragraph"],"text":" Accessing structure components is by offset, not name "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs in MIPS99/114 "},{"tags":["paragraph"],"text":" Structs that are local to functions are allocated space on the stack "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs in MIPS100/114 "},{"tags":["paragraph"],"text":" C can pass whole structures to functions, e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs in MIPS101/114 "},{"tags":["paragraph"],"text":" Accessing struct within function ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Structs in MIPS102/114 "},{"tags":["paragraph"],"text":" Can also pass a pointer to a struct "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Clearly a more efficient way to pass a large struct "},{"tags":["paragraph"],"text":" Also, required if the function needs to update the original struct "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Compiling C to MIPS103/114 "},{"tags":["paragraph"],"text":" Using simplified C as an intermediate language "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" C Pre-processor104/114 "},{"tags":["paragraph"],"text":" Maps C→C, performing various substitutions "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... C Pre-processor105/114 "},{"tags":["paragraph"],"text":" More C pre-processor substitions "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" C Parser106/114 "},{"tags":["paragraph"],"text":" Understands syntax of C language "},{"tags":["paragraph"],"text":" Attempts to convert C program into parse tree "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Symbol Table Management107/114 "},{"tags":["paragraph"],"text":" Compiler keeps track of names "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Local Variables108/114 "},{"tags":["paragraph"],"text":" Two choices for local variables "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Expression Evaluation109/114 "},{"tags":["paragraph"],"text":" Uses temporary ($t?) registers "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Complex boolean expressions handled by short-circuit evaluation. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Mapping Control Structures110/114 "},{"tags":["paragraph"],"text":" Use templates, e.g. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Mapping Control Structures111/114 "},{"tags":["paragraph"],"text":" Template for if...else if... else "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Argc and Argv112/114 "},{"tags":["paragraph"],"text":" The real MIPS machine has no idea about argc and argv "},{"tags":["paragraph"],"text":" SPIM runs under Linux, and needs to interact with environment "},{"tags":["paragraph"],"text":" So, the initialisation code (that invokes main) sets them up: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Note: we are ignoring envp (environment pointer) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Argc and Argv113/114 "},{"tags":["paragraph"],"text":" What the main program receives: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Argc and Argv114/114 "},{"tags":["paragraph"],"text":" Code to print the program's name (argv[0]): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Code to print the first cmd-line arg (argv[1]) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Produced: 2 Apr 2018 "}]}