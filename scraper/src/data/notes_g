{"allTables":[{"tableRows":[{"text":"Parallelism/Concurrency"}]},{"tableRows":[{"text":"Concurrency/Parallelism2/59"}]},{"tableRows":[{"text":"... Concurrency/Parallelism3/59"}]},{"tableRows":[{"text":"... Concurrency/Parallelism4/59"}]},{"tableRows":[{"text":"... Concurrency/Parallelism5/59"}]},{"tableRows":[{"text":"Creating Concurrency6/59"}]},{"tableRows":[{"text":"... Creating Concurrency7/59"}]},{"tableRows":[{"text":"Linux/Unix Threads8/59"}]},{"tableRows":[{"text":"... Linux/Unix Threads9/59"}]},{"tableRows":[{"text":"... Linux/Unix Threads10/59"}]},{"tableRows":[{"text":"... Linux/Unix Threads11/59"}]},{"tableRows":[{"text":"Concurrency12/59"}]},{"tableRows":[{"text":"... Concurrency13/59"}]},{"tableRows":[{"text":"... Concurrency14/59"}]},{"tableRows":[{"text":"... Concurrency15/59"}]},{"tableRows":[{"text":"Concurrency Control16/59"}]},{"tableRows":[{"text":"... Concurrency Control17/59"}]},{"tableRows":[{"text":"Producer-Consumer Problem18/59"}]},{"tableRows":[{"text":"... Producer-Consumer Problem19/59"}]},{"tableRows":[{"text":"... Producer-Consumer Problem20/59"}]},{"tableRows":[{"text":"... Producer-Consumer Problem21/59"}]},{"tableRows":[{"text":"... Producer-Consumer Problem22/59"}]},{"tableRows":[{"text":"Semaphores23/59"}]},{"tableRows":[{"text":"... Semaphores24/59"}]},{"tableRows":[{"text":"... Semaphores25/59"}]},{"tableRows":[{"text":"... Semaphores26/59"}]},{"tableRows":[{"text":"... Semaphores27/59"}]},{"tableRows":[{"text":"Message Passing28/59"}]},{"tableRows":[{"text":"... Message Passing29/59"}]},{"tableRows":[{"text":"... Message Passing30/59"}]},{"tableRows":[{"text":"... Message Passing31/59"}]},{"tableRows":[{"text":"... Message Passing32/59"}]},{"tableRows":[{"text":"... Message Passing33/59"}]},{"tableRows":[{"text":"Process Interaction"}]},{"tableRows":[{"text":"Interacting Processes35/59"}]},{"tableRows":[{"text":"... Interacting Processes36/59"}]},{"tableRows":[{"text":"File Locking37/59"}]},{"tableRows":[{"text":"... File Locking38/59"}]},{"tableRows":[{"text":"Pipes39/59"}]},{"tableRows":[{"text":"... Pipes40/59"}]},{"tableRows":[{"text":"... Pipes41/59"}]},{"tableRows":[{"text":"... Pipes42/59"}]},{"tableRows":[{"text":"... Pipes43/59"}]},{"tableRows":[{"text":"... Pipes44/59"}]},{"tableRows":[{"text":"Message Queues45/59"}]},{"tableRows":[{"text":"... Message Queues46/59"}]},{"tableRows":[{"text":"... Message Queues47/59"}]},{"tableRows":[{"text":"... Message Queues48/59"}]},{"tableRows":[{"text":"... Message Queues49/59"}]},{"tableRows":[{"text":"... Message Queues50/59"}]},{"tableRows":[{"text":"... Message Queues51/59"}]},{"tableRows":[{"text":"Sockets52/59"}]},{"tableRows":[{"text":"... Sockets53/59"}]},{"tableRows":[{"text":"... Sockets54/59"}]},{"tableRows":[{"text":"... Sockets55/59"}]},{"tableRows":[{"text":"... Sockets56/59"}]},{"tableRows":[{"text":"... Sockets57/59"}]},{"tableRows":[{"text":"... Sockets58/59"}]},{"tableRows":[{"text":"... Sockets59/59"}]}],"allParagraphs":[{"text":"G: Parallelism/Concurrency"},{"text":" "},{"text":""},{"text":" Parallelism/Concurrency "},{"text":" "},{"text":""},{"text":" Concurrency/Parallelism2/59 "},{"text":" Parallelism = multiple computations executed simultaneously "},{"text":" Both parallelism and concurrency need to deal with synchronisation. "},{"text":""},{"text":" ... Concurrency/Parallelism3/59 "},{"text":" Example of SIMD parallel processing (e.g. GPU) "},{"text":""},{"text":" But not totally independent: need to synchronise on completion "},{"text":""},{"text":" ... Concurrency/Parallelism4/59 "},{"text":" Map-reduce is a programming model for "},{"text":""},{"text":" ... Concurrency/Parallelism5/59 "},{"text":" Canonical example: compute word frequencies "},{"text":""},{"text":" "},{"text":""},{"text":" Creating Concurrency6/59 "},{"text":" One method for creating concurrent tasks: "},{"text":" fork() creates a new (child) process "},{"text":""},{"text":" ... Creating Concurrency7/59 "},{"text":" Alternative mechanism for concurrent tasks: threads "},{"text":" Difference between threads and processes "},{"text":""},{"text":" Linux/Unix Threads8/59 "},{"text":" pThreads = POSIX implementation of threads "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Linux/Unix Threads9/59 "},{"text":" int pthread_create(pthread_t *Thread, pthread_attr_t *Attr, void *(*Func)(void *), void *Arg) "},{"text":""},{"text":" ... Linux/Unix Threads10/59 "},{"text":" pthread_t pthread_self(void) "},{"text":""},{"text":" ... Linux/Unix Threads11/59 "},{"text":" int pthread_join(pthread_t T, void **value_ptr) "},{"text":""},{"text":" Concurrency12/59 "},{"text":" The alternative to concurrency ... sequential execution "},{"text":""},{"text":" ... Concurrency13/59 "},{"text":" In reality, processes are often not independent "},{"text":""},{"text":" ... Concurrency14/59 "},{"text":" Example of problematic concurrency ... bank withdrawal: "},{"text":""},{"text":" Scenario: two processes, one account A, initial balance $500 "},{"text":""},{"text":" ... Concurrency15/59 "},{"text":" Restatement of program: "},{"text":""},{"text":" Possible outcome of scenario: "},{"text":""},{"text":" Concurrency Control16/59 "},{"text":" Concurrency control aims to "},{"text":""},{"text":" ... Concurrency Control17/59 "},{"text":" Shared memory approach: "},{"text":""},{"text":" Producer-Consumer Problem18/59 "},{"text":" Classic example for concurrency control issues "},{"text":""},{"text":" "},{"text":""},{"text":" ... Producer-Consumer Problem19/59 "},{"text":" Data objects shared by two processes: "},{"text":""},{"text":" Functions on buffer (simplified view): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Producer-Consumer Problem20/59 "},{"text":" Producer process (P): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Producer-Consumer Problem21/59 "},{"text":" Consumer process (C): "},{"text":""},{"text":" "},{"text":""},{"text":" ... Producer-Consumer Problem22/59 "},{"text":" A possible scenario (assumes signals only reach paused processes) "},{"text":""},{"text":" Semaphores23/59 "},{"text":" Semaphore operations: "},{"text":""},{"text":" ... Semaphores24/59 "},{"text":" Using semaphores for the producer-consumer problem: "},{"text":""},{"text":" The mutex semaphore ensures that "},{"text":""},{"text":" ... Semaphores25/59 "},{"text":" Using semaphores for the producer-consumer problem (cont) "},{"text":""},{"text":" "},{"text":""},{"text":" ... Semaphores26/59 "},{"text":" Using semaphores for the producer-consumer problem (cont) "},{"text":""},{"text":" "},{"text":""},{"text":" ... Semaphores27/59 "},{"text":" Semaphores on Linux/Unix ... "},{"text":""},{"text":" Message Passing28/59 "},{"text":" Message passing = a method for invoking computations "},{"text":""},{"text":" ... Message Passing29/59 "},{"text":" Message passing systems can be ... "},{"text":""},{"text":" ... Message Passing30/59 "},{"text":" Message passing architecture "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Message Passing31/59 "},{"text":" A standard message passing framework (MPI) has been defined "},{"text":" Bindings exist for many languages (e.g. C, C++, Java, Python, ...) "},{"text":" Other languages have message passing built in "},{"text":""},{"text":" ... Message Passing32/59 "},{"text":" Example of message passing with language support: Google's Go "},{"text":""},{"text":" "},{"text":""},{"text":" ... Message Passing33/59 "},{"text":" Bank withdrawal example using Go: "},{"text":""},{"text":" For more info on Go, see https://tour.golang.org/ "},{"text":""},{"text":" Process Interaction "},{"text":" "},{"text":""},{"text":" Interacting Processes35/59 "},{"text":" Processes can interact via "},{"text":""},{"text":" ... Interacting Processes36/59 "},{"text":" Example of problematic process interaction: "},{"text":""},{"text":" "},{"text":" Could control access to file via semaphores "},{"text":" An alternative (less general) mechanism: file locking "},{"text":""},{"text":" File Locking37/59 "},{"text":" int flock(int FileDesc, int Operation) "},{"text":""},{"text":" ... File Locking38/59 "},{"text":" If a process tries to acquire a shared lock ... "},{"text":""},{"text":" Pipes39/59 "},{"text":" A common style of process interaction (communication) "},{"text":""},{"text":" A pipe provides buffered i/o between producer and consumer "},{"text":""},{"text":" ... Pipes40/59 "},{"text":" int pipe(int fd[2]) "},{"text":""},{"text":" ... Pipes41/59 "},{"text":" Creating a pipe ... "},{"text":""},{"text":" "},{"text":""},{"text":" ... Pipes42/59 "},{"text":" Example: setting up a pipe "},{"text":""},{"text":" "},{"text":""},{"text":" ... Pipes43/59 "},{"text":" A common pattern in pipe usage "},{"text":" FILE *popen(char *Cmd, char *Mode) "},{"text":""},{"text":" ... Pipes44/59 "},{"text":" Example of popen() "},{"text":""},{"text":" "},{"text":""},{"text":" Message Queues45/59 "},{"text":" Pipes operate between two processes on same host "},{"text":""},{"text":" ... Message Queues46/59 "},{"text":" Message queue architecture "},{"text":""},{"text":" "},{"text":""},{"text":" ... Message Queues47/59 "},{"text":" Requires #include <mqueue.h>, giving mqd_t "},{"text":" mqd_t mq_open(char *Name, int Flags) "},{"text":" int mq_close(mqd_t *MQ) "},{"text":""},{"text":" ... Message Queues48/59 "},{"text":" int mq_send(mqd_t MQ, char *Msg, int Size, uint Prio) "},{"text":""},{"text":" ... Message Queues49/59 "},{"text":" int mq_receive(mqd_t MQ, char *Msg, int Size, uint *Prio) "},{"text":""},{"text":" ... Message Queues50/59 "},{"text":" Pseudo-code showing structure of a MQ server program: "},{"text":""},{"text":" "},{"text":""},{"text":" ... Message Queues51/59 "},{"text":" Pseudo-code showing structure of a MQ client program: "},{"text":""},{"text":" "},{"text":""},{"text":" Sockets52/59 "},{"text":" Inter-process communication (IPC) mechanisms considered so far "},{"text":" "},{"text":""},{"text":" "},{"text":""},{"text":" ... Sockets53/59 "},{"text":" Socket = an end-point of an IPC channel "},{"text":""},{"text":" ... Sockets54/59 "},{"text":" int socket(int Domain, int Type, int Protocol) "},{"text":""},{"text":" ... Sockets55/59 "},{"text":" int bind(int Sockfd, SockAddr *Addr, socklen_t AddrLen) "},{"text":""},{"text":" ... Sockets56/59 "},{"text":" SockAddr = struct sockaddr_in "},{"text":""},{"text":" "},{"text":""},{"text":" ... Sockets57/59 "},{"text":" int accept(int Sockfd, SockAddr *Addr, socklen_t *AddrLen) "},{"text":""},{"text":" ... Sockets58/59 "},{"text":" Pseudo-code showing structure of a simple client program: "},{"text":""},{"text":" (See http://www.linuxhowtos.org/C_C++/socket.htm) "},{"text":""},{"text":" ... Sockets59/59 "},{"text":" Pseudo-code showing structure of a server program: "},{"text":""},{"text":" "},{"text":""},{"text":" Produced: 2 May 2018 "}],"allLists":[{"type":"list"}," e.g. multiple CPUs, one process on each CPU (MIMD) ",{"type":"list"}," e.g. data vector, one processor computes on each element (SIMD) ",{"type":"list"}," e.g. map-reduce: computation spread across multiple hosts ",{"type":"list"}," e.g. single CPU, alternating between processes (time-slicing) ",{"type":"list"}," mutliple identical processors ",{"type":"list"}," each given one element of a data structure from main memory ",{"type":"list"}," each performing same computation on that element ",{"type":"list"}," results copied back to main memory data structure ",{"type":"list"}," manipulating very large data sets ",{"type":"list"}," on a large network of nodes (local or distributed) ",{"type":"list"}," data distributed (shuffled) as (key,value) pairs ",{"type":"list"}," each node receives a set of pairs with common key(s) ",{"type":"list"}," nodes perform calculation on received data items ",{"type":"list"}," and combine outputs from these calculations ",{"type":"list"}," child executes concurrently with parent ",{"type":"list"}," inherits some state from parent (e.g. open fd's) ",{"type":"list"}," runs in its own address space ",{"type":"list"}," process switching requires kernel intervention ",{"type":"list"}," each has a significant amount of state ",{"type":"list"}," process interaction requires system-level mechanisms ",{"type":"list"}," processes are independent of each other; threads exist within a (parent) process ",{"type":"list"}," processes have own state; threads share parent process state ",{"type":"list"}," each process has own address space; all threads within a process share one address space ",{"type":"list"}," processes communicate via IPC mechanisms (see later); threads can communicate via shared memory ",{"type":"list"}," context-switching between processes is expensive; context-switching between threads is (relatively) cheap ",{"type":"list"}," requires #include <pthread.h> ",{"type":"list"}," provides (opaque) pthread_t data type ",{"type":"list"}," functions on threads: create, identify, send signals, exit, ... ",{"type":"list"}," creates a new thread with specified Attributes ",{"type":"list"}," thread info stored in *Thread ",{"type":"list"}," thread starts by executing Func() with Arg ",{"type":"list"}," returns 0 if OK, -1 otherwise and sets errno ",{"type":"list"}," returns pthread_t for current thread ",{"type":"list"}," in some ways, analogous to getpid() ",{"type":"list"}," compares two thread IDs ",{"type":"list"}," returns non-zero if same thread, 0 otherwise ",{"type":"list"}," suspend execution until thread T terminates ",{"type":"list"}," pthread_exit() value is placed in *value_ptr ",{"type":"list"}," if T has already exited, does not wait ",{"type":"list"}," terminate execution of thread, and do some cleaning up ",{"type":"list"}," stores a return value in *value_ptr ",{"type":"list"}," each process runs to completion before next one starts ",{"type":"list"}," low throughput; not acceptable on multi-user systems ",{"type":"list"}," if one process is delayed, others can run ",{"type":"list"}," if we have multiple CPUs, use all of them at once ",{"type":"list"}," each process runs and completes its task ",{"type":"list"}," without any effect on the computation of other processes ",{"type":"list"}," multiple processes accessing a shared resource ",{"type":"list"}," one process synchronizing with another for some computation ",{"type":"list"}," nondeterminism ... same code, different runs, different results e.g. output on shared resource is jumbled e.g. input from shared resource is unpredictable ",{"type":"list"}," e.g. output on shared resource is jumbled ",{"type":"list"}," e.g. input from shared resource is unpredictable ",{"type":"list"}," deadlock ... a group of processes end up waiting for each other ",{"type":"list"}," starvation ... one process keeps missing access to resource ",{"type":"list"}," each process attempts to withdraw($300, A) ",{"type":"list"}," process 1 executes up to line 3, then swapped out ",{"type":"list"}," process 2 executes up to line 3, then swapped out ",{"type":"list"}," process 1 continues and reduces balance by $300 ",{"type":"list"}," process 2 continues and reduces balance by $300 ",{"type":"list"}," provide correct sequencing of interactions between processes ",{"type":"list"}," coordinate semantically-valid access to shared resources ",{"type":"list"}," shared memory based (e.g. semaphores) ",{"type":"list"}," message passing based (e.g. send/receive) ",{"type":"list"}," available via special library functions, or ",{"type":"list"}," available via new language constructs ",{"type":"list"}," uses shared variable, manipulated atomically ",{"type":"list"}," blocks if access unavailable, decrements once available ",{"type":"list"}," processes communicate by sending/receiving messages ",{"type":"list"}," receiver can block waiting for message to arrive ",{"type":"list"}," sender may block waiting for message to be received synchronous message passing: sender waits for ACK of receipt asynchronous message passing: sender transmits and continues ",{"type":"list"}," synchronous message passing: sender waits for ACK of receipt ",{"type":"list"}," asynchronous message passing: sender transmits and continues ",{"type":"list"}," have a buffer with slots for N items ",{"type":"list"}," a process that produces new items and puts them in the buffer ",{"type":"list"}," a process that consumes items from the buffer ",{"type":"list"}," a mechanism for a process to pause itself ",{"type":"list"}," a mechanism for signalling a process to wake up ",{"type":"list"}," C checks nItems, finds zero, decides to pause ",{"type":"list"}," just before pausing, C is timed-out (different to paused) ",{"type":"list"}," P creates item, puts it in currently empty buffer ",{"type":"list"}," because buffer now has one item, P signals C ",{"type":"list"}," because C is not paused, signal is lost ",{"type":"list"}," C is resumed after time-out and pauses ",{"type":"list"}," P resumes and adds more items ",{"type":"list"}," eventually buffer fills and P pauses ",{"type":"list"}," each process is paused, waiting for signal from the other ",{"type":"list"}," init(Sem, InitValue) set the initial value of semaphore Sem ",{"type":"list"}," set the initial value of semaphore Sem ",{"type":"list"}," wait(Sem) (also called P()) if current value of Sem > 0, decrement Sem and continue otherwise, block and wait until Sem value > 0 ",{"type":"list"}," if current value of Sem > 0, decrement Sem and continue ",{"type":"list"}," otherwise, block and wait until Sem value > 0 ",{"type":"list"}," signal(Sem) (also called V()) increment value of Sem, and continue ",{"type":"list"}," increment value of Sem, and continue ",{"type":"list"}," can be achieved via a FIFO queue (fair, but maybe not optimal) ",{"type":"list"}," semaphores are updated atomically ",{"type":"list"}," so can't timeout in if (nItems == 0) pause() ",{"type":"list"}," only one process at a time manipulates the buffer ",{"type":"list"}," allows multiple producers/consumers to interact correctly ",{"type":"list"}," #include <semaphore.h>, giving sem_t ",{"type":"list"}," int sem_init(sem_t *Sem, int Shared, uint Value) create a semaphore object, and set initial value ",{"type":"list"}," create a semaphore object, and set initial value ",{"type":"list"}," int sem_wait(sem_t *Sem) (i.e. wait()) try to decrement; block if Sem == 0 ",{"type":"list"}," try to decrement; block if Sem == 0 ",{"type":"list"}," int sem_post(sem_t *Sem) (i.e. signal()) increment the value of semaphore Sem ",{"type":"list"}," increment the value of semaphore Sem ",{"type":"list"}," int sem_destroy(sem_t *Sem) free all memory associated with semaphore Sem ",{"type":"list"}," free all memory associated with semaphore Sem ",{"type":"list"}," source process sends a message to a target process ",{"type":"list"}," target process uses message to invoke appropriate code ",{"type":"list"}," may send a reply message containing the computed result ",{"type":"list"}," data is passed by copying value into a message (cf. parameters) ",{"type":"list"}," particularly effective for concurrent, distributed systems ",{"type":"list"}," synchronous sender transmits message, waits for response familiar programming model; like a (remote) function call ",{"type":"list"}," sender transmits message, waits for response ",{"type":"list"}," familiar programming model; like a (remote) function call ",{"type":"list"}," asynchronous sender transmits message, continues with own task reponse arrival eventually interrupts original sender ",{"type":"list"}," sender transmits message, continues with own task ",{"type":"list"}," reponse arrival eventually interrupts original sender ",{"type":"list"}," could occur on local processor, or across wide-area network ",{"type":"list"}," MPI_Init(..) ... initialises message passing environment ",{"type":"list"}," MPI_Send(..) ... send a message (synchronous) ",{"type":"list"}," MPI_Recv(..) ... send a message (synchronous) ",{"type":"list"}," goroutines ... concurrently executing \"functions\" ",{"type":"list"}," channels ... communication pipes between goroutines ",{"type":"list"}," select ... manage multiple channels ",{"type":"list"}," signals: kill(), wait(), signal handlers ",{"type":"list"}," accessing the same resource (e.g. writing onto the same file) ",{"type":"list"}," pipes: stdout of process A goes into stdin of process B ",{"type":"list"}," message queues: passing data between each other ",{"type":"list"}," sockets: client-server style interaction ",{"type":"list"}," two processes writing to same file \"simultaneously\" ",{"type":"list"}," order of output depends on actions of (opaque) scheduler ",{"type":"list"}," controls access to shared files (note: files not fds) ",{"type":"list"}," possible operations LOCK_SH ... acquire shared lock LOCK_EX ... acquire exclusive lock LOCK_UN ... unlock LOCK_NB ... operation fails rather than blocking ",{"type":"list"}," LOCK_SH ... acquire shared lock ",{"type":"list"}," LOCK_EX ... acquire exclusive lock ",{"type":"list"}," LOCK_UN ... unlock ",{"type":"list"}," LOCK_NB ... operation fails rather than blocking ",{"type":"list"}," in blocking mode, flock() does not return until lock available ",{"type":"list"}," only works correctly if all processes accessing file use locks ",{"type":"list"}," return value: 0 in success, -1 on failure ",{"type":"list"}," if file not locked or other shared locks, OK ",{"type":"list"}," if file has exclusive lock, blocked ",{"type":"list"}," if file is not locked, OK ",{"type":"list"}," if any locks (shared or exclusive) on file, blocked ",{"type":"list"}," flock() returns 0 if lock was acquired ",{"type":"list"}," flock() returns -1 if process would have been blocked ",{"type":"list"}," producer process writes to byte stream (cf. stdout) ",{"type":"list"}," consumer process reads from same byte stream ",{"type":"list"}," producer blocks when buffer full; consumer blocks when buffer empty ",{"type":"list"}," open two file descriptors (to be shared by processes) ",{"type":"list"}," fd[0] is opened for reading; fd[1] is opened for writing ",{"type":"list"}," return 0 if OK, otherwise return -1 and sets errno ",{"type":"list"}," fork() to create a child process ",{"type":"list"}," both processes have copies of fd[] ",{"type":"list"}," one can write to fd[1], the other can read from fd[0] ",{"type":"list"}," set up a pipe between parent and child ",{"type":"list"}," exec() child to become a new process talking to parent ",{"type":"list"}," analogous to fopen, except first arg is a command ",{"type":"list"}," Cmd is passed to shell for interpretation ",{"type":"list"}," returns FILE* which be read/written depending on Mode ",{"type":"list"}," returns NULL if can't establish pipe or invalid Cmd ",{"type":"list"}," processes come initially from parent/child pair (fork) ",{"type":"list"}," connection established via shared file descriptions ",{"type":"list"}," for unrelated processes to pass information ",{"type":"list"}," along a buffered channel shared by many processes ",{"type":"list"}," MQ names look like \"/SomeCharacters \" (no slash chars) ",{"type":"list"}," create a new message queue, or open existing one ",{"type":"list"}," Flags are like those for fopen() (e.g. O_RDONLY) ",{"type":"list"}," finish accessing message queue MQ ",{"type":"list"}," the message queue continues to exist (cf. fclose()) ",{"type":"list"}," adds message Msg to message queue MQ ",{"type":"list"}," Prio gives priority (determines order of messages on MQ) ",{"type":"list"}," if MQ is full ... blocks until MQ space available if O_NONBLOCK is set, fails and returns error ",{"type":"list"}," blocks until MQ space available ",{"type":"list"}," if O_NONBLOCK is set, fails and returns error ",{"type":"list"}," also, mq_timedsend() which waits for specified time if MQ full fails if still no space on MQ after timeout ",{"type":"list"}," waits for specified time if MQ full ",{"type":"list"}," fails if still no space on MQ after timeout ",{"type":"list"}," removes highest priority message from queue MQ ",{"type":"list"}," if *Prio is not NULL, receives message priority ",{"type":"list"}," if MQ is empty ... blocks until a message is added to MQ if O_NONBLOCK is set, fails and returns error ",{"type":"list"}," blocks until a message is added to MQ ",{"type":"list"}," if O_NONBLOCK is set, fails and returns error ",{"type":"list"}," if several processes blocked on mq_receive() oldest and highest priority process receives the message ",{"type":"list"}," oldest and highest priority process receives the message ",{"type":"list"}," assume that both processes are on the same host ",{"type":"list"}," e.g. web servers, networked databases, networked message queues, ... ",{"type":"list"}," commonly used to construct client-server systems ",{"type":"list"}," either locally (Unix domain) or network-wide (Internet domain) ",{"type":"list"}," server creates a socket, then ... binds to an address (local or network) listens for connections from clients ",{"type":"list"}," binds to an address (local or network) ",{"type":"list"}," listens for connections from clients ",{"type":"list"}," client creates a socket, then ... connects to the server using known address writes to server via socket (i.e. sends requests) reads from server via socket (i.e. receives responses) ",{"type":"list"}," connects to the server using known address ",{"type":"list"}," writes to server via socket (i.e. sends requests) ",{"type":"list"}," reads from server via socket (i.e. receives responses) ",{"type":"list"}," requires #include <sys/socket.h> ",{"type":"list"}," creates a socket, using ... Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... ",{"type":"list"}," Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) ",{"type":"list"}," AF_LOCAL ... on the local host (Unix domain) ",{"type":"list"}," AF_INET ... over the network (Internet domain) ",{"type":"list"}," Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer ",{"type":"list"}," SOCK_STREAM ... sequenced, reliable communications stream ",{"type":"list"}," SOCK_DGRAM ... connectionless, unreliable packet transfer ",{"type":"list"}," Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... ",{"type":"list"}," many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... ",{"type":"list"}," returns a socket descriptor (small int) or -1 on error ",{"type":"list"}," associates an open socket with an address ",{"type":"list"}," for Unix Domain, address is a pathname in the file system ",{"type":"list"}," for Internet Domain, address is IP address + port number ",{"type":"list"}," wait for connections on socket Sockfd ",{"type":"list"}," allow at most Backlog connections to be queued up ",{"type":"list"}," sin_family ... domain: AF_UNIX or AF_INET ",{"type":"list"}," sin_port ... port number: 80, 443, etc. ",{"type":"list"}," sin_addr ... structure containing host address ",{"type":"list"}," sin_zero[8] ... padding ",{"type":"list"}," Sockfd has been created, bound and is listening ",{"type":"list"}," blocks until a connection request is received ",{"type":"list"}," sets up a connection between client/server after connect() ",{"type":"list"}," places information about the requestor in Addr ",{"type":"list"}," returns a new socket descriptor, or -1 on error ",{"type":"list"}," connects the socket Sockfd to address Addr ",{"type":"list"}," assumes that Addr contains a process listening appropriately ",{"type":"list"}," returns 0 on success, or -1 on error "]}