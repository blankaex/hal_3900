<html>
<head>
<title>G: Parallelism/Concurrency</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>G: Parallelism/Concurrency</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Parallelism/Concurrency</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Concurrency/Parallelism</span></td><td align='right'><small>2/59</small></td></tr></table>
<p>
<em>Parallelism</em> = multiple computations executed simultaneously
<ul>
<li> e.g. multiple CPUs, one process on each CPU &nbsp; <small>(MIMD)</small>
<li> e.g. data vector, one processor computes on each element &nbsp; <small>(SIMD)</small>
<li> e.g. map-reduce: computation spread across multiple hosts
</ul>
<br>
<em>Concurrency</em> = multiple processes running (pseudo) simultaneously
<ul>
<li> e.g. single CPU, alternating between processes &nbsp; <small>(time-slicing)</small>
</ul>
<br>
Primarily concerned with concurrency and <em>concurrency control</em>.
<p>
Both parallelism and concurrency need to deal with <em>synchronisation</em>.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency/Parallelism</span></td><td align='right'><small>3/59</small></td></tr></table>
<p>
Example of SIMD parallel processing (e.g. GPU)
<ul>
<li> mutliple identical processors
<li> each given one element of a data structure from main memory
<li> each performing same computation on that element
<li> results copied back to main memory data structure
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/mp-small.png]" src="Pics/processes/mp-small.png">
</div><p>
<br>
But not totally independent: need to <i>synchronise</i> on completion
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency/Parallelism</span></td><td align='right'><small>4/59</small></td></tr></table>
<p>
<em>Map-reduce</em> is a programming model for
<ul>
<li> manipulating very large data sets
<li> on a large network of nodes &nbsp;<small>(local or distributed)</small>
</ul>
The <em>map</em> step filters data and distributes it to nodes
<ul>
<li> data distributed (shuffled) as <i>(key,value)</i> pairs
<li> each node receives a set of pairs with common <i>key</i>(s)
</ul>
The <em>reduce</em> step computes the final result
<ul>
<li> nodes perform calculation on received data items
<li> and combine outputs from these calculations
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency/Parallelism</span></td><td align='right'><small>5/59</small></td></tr></table>
<p>
Canonical example: compute word frequencies
<p><pre>
map(Document)
{
   for each word W in Document
      emit (W,1)  <comment>// send to node</comment>
}

reduce(Word, PartialCounts)
{
   sum = 0
   <comment>// retrieve from nodes</comment>
   for each N in partialCounts
      sum += N
   emit (Word, sum)  <comment>// send a result</comment>
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Creating Concurrency</span></td><td align='right'><small>6/59</small></td></tr></table>
<p>
One method for creating concurrent tasks:
<p>
<large><code>fork()</code></large> creates a new (child) process
<ul>
<li> child executes concurrently with parent
<li> inherits some state from parent (e.g. open fd's)
<li> runs in its own address space
</ul>
Processes have some disadvantages
<ul>
<li> process switching requires kernel intervention
<li> each has a significant amount of state
<li> process interaction requires system-level mechanisms
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Creating Concurrency</span></td><td align='right'><small>7/59</small></td></tr></table>
<p>
Alternative mechanism for concurrent tasks: <em>threads</em>
<p>
Difference between threads and processes
<ul>
<li> processes are independent of each other; <br>
	threads exist within a (parent) process
<li> processes have own state; <br>
	threads share parent process state
<li> each process has own address space; <br>
	all threads within a process share one address space
<li> processes communicate via IPC mechanisms <small>(see later)</small>; <br>
	threads can communicate via shared memory
<li> context-switching between processes is expensive; <br>
	context-switching between threads is (relatively) cheap
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Linux/Unix Threads</span></td><td align='right'><small>8/59</small></td></tr></table>
<p>
<em>pThreads</em> = POSIX implementation of threads
<ul>
<li> requires <large><font color="#008800"><b><code>#include &lt;pthread.h&gt;</code></b></font></large>
<li> provides (opaque) <large><font color="#008800"><b><code>pthread_t</code></b></font></large> data type
<li> functions on threads: create, identify, send signals, exit, ...
</ul>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/threads-small.png]" src="Pics/processes/threads-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Linux/Unix Threads</span></td><td align='right'><small>9/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int pthread_create(pthread_t *Thread, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pthread_attr_t *Attr, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; void *(*Func)(void *), void *Arg)</code></b></font></large>
<ul>
<li> creates a new thread with specified <large><font color="#008800"><b><code>Attr</code></b></font></large>ibutes
<li> thread info stored in <large><font color="#008800"><b><code>*Thread</code></b></font></large>
<li> thread starts by executing <large><font color="#008800"><b><code>Func()</code></b></font></large> with <large><font color="#008800"><b><code>Arg</code></b></font></large>
<li> returns 0 if OK, -1 otherwise and sets <large><code>errno</code></large>
</ul>
In some ways, analogous to <large><code>fork()</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Linux/Unix Threads</span></td><td align='right'><small>10/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>pthread_t pthread_self(void)</code></b></font></large>
<ul>
<li> returns <large><font color="#008800"><b><code>pthread_t</code></b></font></large> for current thread
<li> in some ways, analogous to <large><code>getpid()</code></large>
</ul>
<large><font color="#008800"><b><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></b></font></large>
<ul>
<li> compares two thread IDs
<li> returns non-zero if same thread, 0 otherwise
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Linux/Unix Threads</span></td><td align='right'><small>11/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int pthread_join(pthread_t T, void **value_ptr)</code></b></font></large>
<ul>
<li> suspend execution until thread <large><font color="#008800"><b><code>T</code></b></font></large> terminates
<li> <large><font color="#008800"><b><code>pthread_exit()</code></b></font></large> value is placed in <large><font color="#008800"><b><code>*value_ptr</code></b></font></large>
<li> if <large><font color="#008800"><b><code>T</code></b></font></large> has already exited, does not wait
</ul>
<large><font color="#008800"><b><code>void pthread_exit(void *value_ptr)</code></b></font></large>
<ul>
<li> terminate execution of thread, and do some cleaning up
<li> stores a return value in <large><font color="#008800"><b><code>*value_ptr</code></b></font></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Concurrency</span></td><td align='right'><small>12/59</small></td></tr></table>
<p>
The alternative to concurrency ... sequential execution
<ul>
<li> each process runs to completion before next one starts
<li> low throughput; not acceptable on multi-user systems
</ul>
Concurrency increases system throughput, e.g.
<ul>
<li> if one process is delayed, others can run
<li> if we have multiple CPUs, use all of them at once
</ul>
If processes are completely independent ...
<ul>
<li> each process runs and completes its task
<li> without any effect on the computation of other processes
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency</span></td><td align='right'><small>13/59</small></td></tr></table>
<p>
In reality, processes are often not independent
<ul>
<li> multiple processes accessing a shared resource
<li> one process synchronizing with another for some computation
</ul>
Effects of poorly-controlled concurrency
<ul>
<li> <em>nondeterminism</em> ... same code, different runs, different results
<ul>
<li> e.g. output on shared resource is jumbled
<li> e.g. input from shared resource is unpredictable
</ul>
<li> <em>deadlock</em> ... a group of processes end up waiting for each other
<li> <em>starvation</em> ... one process keeps missing access to resource
</ul>
Therefore we need <em>concurrency control</em> methods
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency</span></td><td align='right'><small>14/59</small></td></tr></table>
<p>
Example of problematic concurrency ... bank withdrawal:
<p><pre>
<comment>// check balance and return amount withdrawn</comment>
<font color='#999999'>1.</font> int withdraw(Account acct, int howMuch)
<font color='#999999'>2.</font> {
<font color='#999999'>3.</font>    if (acct.balance < howMuch) {
<font color='#999999'>4.</font>       return 0; // can't withdraw
<font color='#999999'>5.</font>    else {
<font color='#999999'>6.</font>       acct.balance -= howMuch;
<font color='#999999'>7.</font>       return howMuch;
<font color='#999999'>8.</font>    }
<font color='#999999'>9.</font> }
</pre><p>
Scenario: two processes, one account A, initial balance $500
<ul>
<li> each process attempts to <large><code>withdraw($300, A)</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency</span></td><td align='right'><small>15/59</small></td></tr></table>
<p>
Restatement of program:
<p><pre>
<font color='#999999'>1.</font> int withdraw(Account acct, int howmuch) {
<font color='#999999'>2.</font>    if (acct.balance < howMuch) return 0;
<font color='#999999'>3.</font>    acct.balance -= howMuch; return howMuch;
<font color='#999999'>4.</font> }
</pre><p>
Possible outcome of scenario:
<ul>
<li> process 1 executes up to line 3, then swapped out
<li> process 2 executes up to line 3, then swapped out
<li> process 1 continues and reduces balance by $300
<li> process 2 continues and reduces balance by $300
</ul>
Result: each process gets $300; account balance is -$100
<br>
Expected: one process gets $300; other fails; balance is $200
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Concurrency Control</span></td><td align='right'><small>16/59</small></td></tr></table>
<p>
<em>Concurrency control</em> aims to
<ul>
<li> provide correct sequencing of interactions between processes
<li> coordinate semantically-valid access to shared resources
</ul>
Two broad classes of concurrency control schemes
<ul>
<li> <em>shared memory</em> based &nbsp; <small>(e.g. semaphores)</small>
<li> <em>message passing</em> based &nbsp; <small>(e.g. send/receive)</small>
</ul>
Both schemes require programming support
<ul>
<li> available via special library functions, or
<li> available via new language constructs
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Concurrency Control</span></td><td align='right'><small>17/59</small></td></tr></table>
<p>
Shared memory approach:
<ul>
<li> uses shared variable, manipulated <em>atomically</em>
<li> blocks if access unavailable, decrements once available
</ul>
Message passing approach:
<ul>
<li> processes communicate by sending/receiving messages
<li> receiver can block waiting for message to arrive
<li> sender <i>may</i> block waiting for message to be received
<small>
<ul>
<li> synchronous message passing: sender waits for ACK of receipt
<li> asynchronous message passing: sender transmits and continues
</ul>
</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Producer-Consumer Problem</span></td><td align='right'><small>18/59</small></td></tr></table>
<p>
Classic example for concurrency control issues
<ul>
<li> have a buffer with slots for N items
<li> a process that produces new items and puts them in the buffer
<li> a process that consumes items from the buffer
<li> a mechanism for a process to pause itself
<li> a mechanism for signalling a process to wake up
</ul>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/prod-cons-small.png]" src="Pics/processes/prod-cons-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Producer-Consumer Problem</span></td><td align='right'><small>19/59</small></td></tr></table>
<p>
Data objects shared by two processes:
<p><pre><small>
#define N ??
Item buffer[N];  <comment>// buffer with slots for N items</comment>
int  nItems = 0; <comment>// #items currently in buffer</comment>
int  head = 0, tail = 0;
</small></pre><p>
Functions on buffer (simplified view):
<p><pre><small>
putItemIntoBuffer(item) {     Item getitemFromBuffer() {
   tail = (tail+1) % N;          Item res = buffer[head];
   buffer[tail] = item;          head = (head + 1) % N;
}                                return res;
                              }
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Producer-Consumer Problem</span></td><td align='right'><small>20/59</small></td></tr></table>
<p>
Producer process (P):
<p><pre>
producer() <comment>// process</comment>
{
   Item item;
   for (;;) {
      item = produceItem();
      <comment>// wait if buffer currently full</comment>
      if (nItems == N) pause();
      putItemIntoBuffer(item);
      nItems++;
      <comment>// tell consumer item now available</comment>
      if (nItems == 1) wakeup(consumer);
   }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Producer-Consumer Problem</span></td><td align='right'><small>21/59</small></td></tr></table>
<p>
Consumer process (C):
<p><pre>
consumer() <comment>// process</comment>
{
   Item item;
   for (;;) {
      <comment>// wait if nothing to consume</comment>
      if (nItems == 0) pause();
      item = getItemFromBuffer()
      nItems--;
      <comment>// free slot available in buffer</comment>
      <comment>// wake up producer in case sleeping</comment>
      if (nItems == N-1) wakeup(producer);
      consumeItem(item);
   }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Producer-Consumer Problem</span></td><td align='right'><small>22/59</small></td></tr></table>
<p>
A possible scenario &nbsp; <small>(assumes signals only reach paused processes)</small>
<ul>
<li> C checks <large><code>nItems</code></large>, finds zero, decides to pause
<li> just before pausing, C is timed-out &nbsp;<small>(different to paused)</small>
<li> P creates item, puts it in currently empty <large><code>buffer</code></large>
<li> because <large><code>buffer</code></large> now has one item, P signals C
<li> because C is not paused, signal is lost
<li> C is resumed after time-out and pauses
<li> P resumes and adds more items
<li> eventually <large><code>buffer</code></large> fills and P pauses
<li> each process is paused, waiting for signal from the other
</ul>
This situation is <em>deadlock</em> &nbsp;...&nbsp; How to fix?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Semaphores</span></td><td align='right'><small>23/59</small></td></tr></table>
<p>
Semaphore operations:
<ul>
<li> <large><font color="#008800"><b><code>init(<i>Sem</i>, <i>InitValue</i>)</code></b></font></large>
<ul>
<li> set the initial value of semaphore <large><code><i>Sem</i></code></large>
</ul>
<li> <large><font color="#008800"><b><code>wait(<i>Sem</i>)</code></b></font></large> &nbsp;&nbsp; <small>(also called <large><code>P()</code></large>)</small>
<ul>
<li> if current value of <large><code><i>Sem</i></code></large> > 0, decrement <large><code><i>Sem</i></code></large> and continue
<li> otherwise, block and wait until <large><code><i>Sem</i></code></large> value > 0
</ul>
<li> <large><font color="#008800"><b><code>signal(<i>Sem</i>)</code></b></font></large> &nbsp;&nbsp; <small>(also called <large><code>V()</code></large>)</small>
<ul>
<li> increment value of <large><code><i>Sem</i></code></large>, and continue
</ul>
</ul>
<br>
Needs fair release of blocked processes, otherwise &rArr; starvation
<ul>
<li> can be achieved via a FIFO queue &nbsp; <small>(fair, but maybe not optimal)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Semaphores</span></td><td align='right'><small>24/59</small></td></tr></table>
<p>
Using semaphores for the producer-consumer problem:
<ul>
<li> semaphores are updated atomically
<li> so can't timeout in <large><code>if (nItems == 0) pause()</code></large>
</ul>
<p><pre>
semaphore nFilled;  init(nFilled, 0);
semaphore nEmpty;   init(nEmpty, N);
semaphore mutex;    init(mutex, 1);
</pre><p>
The <large><code>mutex</code></large> semaphore ensures that
<ul>
<li> only one process at a time manipulates the buffer
<li> allows multiple producers/consumers to interact correctly
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Semaphores</span></td><td align='right'><small>25/59</small></td></tr></table>
<p>
Using semaphores for the producer-consumer problem <small>(cont)</small>
<p><pre>
producer() <comment>// process</comment>
{
   Item item;
   for (;;) {
      item = produceItem();
      wait(nEmpty);  <comment>// pause if buffer full</comment>
      wait(mutex);  <comment>// get exclusive access</comment>
      putItemIntoBuffer(item);
      signal(mutex);  <comment>// release exclusive access</comment>
      signal(nFilled);
   }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Semaphores</span></td><td align='right'><small>26/59</small></td></tr></table>
<p>
Using semaphores for the producer-consumer problem <small>(cont)</small>
<p><pre>
consumer() <comment>// process</comment>
{
   Item item;
   for (;;) {
      wait(nFilled);  <comment>// pause if buffer empty</comment>
      wait(mutex);  <comment>// get exclusive access</comment>
      item = getItemFromBuffer()
      signal(mutex);  <comment>// release exclusive access</comment>
      signal(nEmpty);
      consumeItem(item);
   }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Semaphores</span></td><td align='right'><small>27/59</small></td></tr></table>
<p>
<em>Semaphores</em> on Linux/Unix ...
<ul>
<li> <large><font color="#008800"><b><code>#include &lt;semaphore.h&gt;</code></b></font></large>, &nbsp; giving &nbsp;<large><font color="#008800"><b><code>sem_t</code></b></font></large>
<li> <large><font color="#008800"><b><code>int sem_init(sem_t *<i>Sem</i>, int <i>Shared</i>, uint <i>Value</i>)</code></b></font></large>
<ul>
<li> create a semaphore object, and set initial value
</ul>
<li> <large><font color="#008800"><b><code>int sem_wait(sem_t *<i>Sem</i>)</code></b></font></large> &nbsp;&nbsp; <small>(i.e. wait())</small>
<ul>
<li> try to decrement; block if <large><code><i>Sem</i> == 0</code></large>
</ul>
<li> <large><font color="#008800"><b><code>int sem_post(sem_t *<i>Sem</i>)</code></b></font></large> &nbsp;&nbsp; <small>(i.e. signal())</small>
<ul>
<li> increment the value of semaphore <large><code><i>Sem</i></code></large>
</ul>
<li> <large><font color="#008800"><b><code>int sem_destroy(sem_t *<i>Sem</i>)</code></b></font></large>
<ul>
<li> free all memory associated with semaphore <large><code><i>Sem</i></code></large>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Message Passing</span></td><td align='right'><small>28/59</small></td></tr></table>
<p>
<em>Message passing</em> = a method for invoking computations
<ul>
<li> source process sends a message to a target process
<li> target process uses message to invoke appropriate code
<li> may send a reply message containing the computed result
</ul>
<br>
Message passing is an alternative to <i>function calls</i>
<ul>
<li> data is passed by copying value into a message <small>(cf. parameters)</small>
<li> particularly effective for concurrent, distributed systems
</ul>
<br>
Requires OS support for assembling/queueing/transmitting messages
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Passing</span></td><td align='right'><small>29/59</small></td></tr></table>
<p>
Message passing systems can be ...
<ul>
<li> <em>synchronous</em>
<ul>
<li> sender transmits message, waits for response
<li> familiar programming model; like a (remote) function call
</ul>
<li> <em>asynchronous</em>
<ul>
<li> sender transmits message, continues with own task
<li> reponse arrival eventually interrupts original sender
</ul>
</ul>
<br>
Transmission handled by <em>message bus</em> &nbsp;<small>(e.g. store/forward)</small>
<ul>
<li> could occur on local processor, or across wide-area network
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Passing</span></td><td align='right'><small>30/59</small></td></tr></table>
<p>
Message passing architecture
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/message-passing-small.png]" src="Pics/processes/message-passing-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Passing</span></td><td align='right'><small>31/59</small></td></tr></table>
<p>
A standard message passing framework (MPI) has been defined
<ul>
<li> <large><font color="#008800"><b><code>MPI_Init(..)</code></b></font></large> ... initialises message passing environment
<li> <large><font color="#008800"><b><code>MPI_Send(..)</code></b></font></large> ... send a message (synchronous)
<li> <large><font color="#008800"><b><code>MPI_Recv(..)</code></b></font></large> ... send a message (synchronous)
</ul>
<br>
Defines many other operations to manipulate processes/messages
<p>
Bindings exist for many languages (e.g. C, C++, Java, Python, ...)
<p>
Other languages have message passing built in
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Passing</span></td><td align='right'><small>32/59</small></td></tr></table>
<p>
Example of message passing with language support: Google's <em>Go</em>
<ul>
<li> <em>goroutines</em> ... concurrently executing "functions"
<li> <em>channels</em> ... communication pipes between goroutines
<li> <em>select</em> ... manage multiple channels
</ul>
<p><pre>
<comment>// declare a channel</comment>
pipeline := make(chan int)

<comment>// send a value on a channel</comment>
pipeline <- 42

<comment>// receive a value from a channel</comment>
object = <- pipeline
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Passing</span></td><td align='right'><small>33/59</small></td></tr></table>
<p>
Bank withdrawal example using <em>Go</em>:
<p><pre>
<comment>// define 4 channels wd, dep, bal, resp</comment>
<comment>// define a variable to hold the balance</comment>
for {
   <font color='#009900'>select</font> {
   case howMuch := <- wd:
      if howMuch > balance {
         resp <- 0
      }
      else {
         balance -= howMuch
         resp <- howMuch
      }
   case howMuch := <- dep:
      balance += howMuch
   case <- bal:
      resp <- balance
   }
}
</pre><p>
For more info on Go, see https://tour.golang.org/
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Process Interaction</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Interacting Processes</span></td><td align='right'><small>35/59</small></td></tr></table>
<p>
Processes can interact via
<ul>
<li> signals: <large><code>kill()</code></large>, <large><code>wait()</code></large>, signal handlers
<li> accessing the same resource &nbsp;<small>(e.g. writing onto the same file)</small>
<li> pipes: stdout of process A goes into stdin of process B
<li> message queues: passing data between each other
<li> sockets: client-server style interaction
</ul>
<br>
Uncontrolled interaction is a problem: nondeterministic
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Interacting Processes</span></td><td align='right'><small>36/59</small></td></tr></table>
<p>
Example of problematic process interaction:
<ul>
<li> two processes writing to same file "simultaneously"
<li> order of output depends on actions of (opaque) scheduler
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/flock0-small.png]" src="Pics/processes/flock0-small.png">
</div><p>
<p>
Could control access to file via semaphores
<p>
An alternative (less general) mechanism: <em>file locking</em>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File Locking</span></td><td align='right'><small>37/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int flock(int <i>FileDesc</i>, int <i>Operation</i>)</code></b></font></large>
<ul>
<li> controls access to shared files  &nbsp; <small>(<b>note</b>: files not fds)</small>
<li> possible operations
<ul>
<li> <large><font color="#008800"><b><code>LOCK_SH</code></b></font></large> ... acquire shared lock
<li> <large><font color="#008800"><b><code>LOCK_EX</code></b></font></large> ... acquire exclusive lock
<li> <large><font color="#008800"><b><code>LOCK_UN</code></b></font></large> ... unlock
<li> <large><font color="#008800"><b><code>LOCK_NB</code></b></font></large> ... operation fails rather than blocking
</ul>
<li> in blocking mode, <large><code>flock()</code></large> does not return until lock available
<li> only works correctly if all processes accessing file use locks
<li> return value: 0 in success, -1 on failure
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... File Locking</span></td><td align='right'><small>38/59</small></td></tr></table>
<p>
If a process tries to acquire a <em>shared lock</em> ...
<ul>
<li> if file not locked or other shared locks, OK
<li> if file has exclusive lock, blocked
</ul>
If a process tries to acquire an <em>exclusive lock</em> ...
<ul>
<li> if file is not locked, OK
<li> if any locks (shared or exclusive) on file, blocked
</ul>
If using a non-blocking lock
<ul>
<li> <large><code>flock()</code></large> returns 0 if lock was acquired
<li> <large><code>flock()</code></large> returns -1 if process would have been blocked
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Pipes</span></td><td align='right'><small>39/59</small></td></tr></table>
<p>
A common style of process interaction &nbsp;<small>(communication)</small>
<ul>
<li> producer process writes to byte stream &nbsp;<small>(cf. stdout)</small>
<li> consumer process reads from same byte stream
</ul>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe0-small.png]" src="Pics/processes/pipe0-small.png">
</div><p>
<br>
A <em>pipe</em> provides buffered i/o between producer and consumer
<ul>
<li> <small>producer blocks when buffer full; consumer blocks when buffer empty</small>
</ul>
Pipes are bidirectional unless processes close one file descriptor
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>40/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int pipe(int fd[2])</code></b></font></large>
<ul>
<li> open two file descriptors <small>(to be shared by processes)</small>
<li> <large><code>fd[0]</code></large> is opened for reading; <large><code>fd[1]</code></large> is opened for writing
<li> return 0 if OK, otherwise return -1 and sets <large><code>errno</code></large>
</ul>
Creating the pipe would then be followed by
<ul>
<li> <large><code>fork()</code></large> to create a child process
<li> both processes have copies of <large><code>fd[]</code></large>
<li> one can write to <large><code>fd[1]</code></large>, the other can read from <large><code>fd[0]</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>41/59</small></td></tr></table>
<p>
Creating a pipe ...
<p><div class='center'>
<img alt="[Diagram:Pics/processes/pipe1-small.png]" src="Pics/processes/pipe1-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>42/59</small></td></tr></table>
<p>
Example: setting up a pipe
<p><pre><small>
int main(void)
{
   int fd[2], pid;  char buffer[10];
   assert(pipe(fd) == 0);
   pid = fork();
   assert(pid >= 0);
   if (pid != 0) {  <comment>// parent</comment>
      close(fd[0]); <comment>// writer; don't need fd[0]</comment>
      write(fd[1], "123456789", 10);
   }
   else {           <comment>// child</comment>
      close(fd[1]); <comment>// reader; don't need fd[1]</comment>
      read(fd[0], buffer, 10);
      printf("got \"%s\"\n", buffer);
   }
   return 0;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>43/59</small></td></tr></table>
<p>
A common pattern in pipe usage
<ul>
<li> set up a pipe between parent and child
<li> <large><code>exec()</code></large> child to become a new process talking to parent
</ul>
Because so common, a library function is available for it ...
<p><br>
<large><font color="#008800"><b><code>FILE *popen(char *<i>Cmd</i>, char *<i>Mode</i>)</code></b></font></large>
<ul>
<li> analogous to <large><code>fopen</code></large>, except first arg is a command
<li> <large><code><i>Cmd</i></code></large> is passed to shell for interpretation
<li> returns <large><code>FILE*</code></large> which be read/written depending on <large><code><i>Mode</i></code></large>
<li> returns <large><code>NULL</code></large> if can't establish pipe or invalid <large><code><i>Cmd</i></code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pipes</span></td><td align='right'><small>44/59</small></td></tr></table>
<p>
Example of <large><code>popen()</code></large>
<p><pre>
int main(void)
{
   FILE *p = <font color='#000099'>popen("ls -l", "r")</font>;
   assert(p != NULL);
   char line[200], a[20],b[20],c[20],d[20];
   long int tot = 0, size;
   while (fgets(line,199,p) != NULL) {
      sscanf(line, "%s %s %s %s %ld",
                     a, b, c, d, &size);
      fputs(line, stdout);
      tot += size;
   }
   printf("Total: %ld\n", tot);
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Message Queues</span></td><td align='right'><small>45/59</small></td></tr></table>
<p>
Pipes operate between two processes on same host
<ul>
<li> processes come initially from parent/child pair <small>(<large><code>fork</code></large>)</small>
<li> connection established via shared file descriptions
</ul>
A <em>message queue</em> (MQ) provides a mechanism
<ul>
<li> for unrelated processes to pass information 
<li> along a buffered channel shared by many processes
</ul>
Processes connect to message queues by name
<ul>
<li> MQ names look like &nbsp;"<large><code>/</code></large><i>SomeCharacters</i> " &nbsp;<small>(no slash chars)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>46/59</small></td></tr></table>
<p>
Message queue architecture
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/msg-queue0-small.png]" src="Pics/processes/msg-queue0-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>47/59</small></td></tr></table>
<p>
Requires <large><font color="#008800"><b><code>#include &lt;mqueue.h&gt;</code></b></font></large>, &nbsp; giving &nbsp;<large><font color="#008800"><b><code>mqd_t</code></b></font></large>
<p>
<large><font color="#008800"><b><code>mqd_t mq_open(char *<i>Name</i>, int <i>Flags</i>)</code></b></font></large>
<ul>
<li> create a new message queue, or open existing one
<li> <large><code>Flags</code></large> are like those for <large><code>fopen()</code></large> (e.g. <large><code>O_RDONLY</code></large>)
</ul>
<p>
<large><font color="#008800"><b><code>int mq_close(mqd_t *<i>MQ</i>)</code></b></font></large>
<ul>
<li> finish accessing message queue <large><code><i>MQ</i></code></large>
<li> the message queue continues to exist &nbsp;<small>(cf. <large><code>fclose()</code></large>)</small>
</ul>
<br>
More details <large><code>man 7 mq_overview</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>48/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mq_send(mqd_t <i>MQ</i>, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *<i>Msg</i>, int <i>Size</i>, uint <i>Prio</i>)</code></b></font></large>
<ul>
<li> adds message <large><code><i>Msg</i></code></large> to message queue <large><code><i>MQ</i></code></large>
<li> <large><code><i>Prio</i></code></large> gives priority
	&nbsp;<small>(determines order of messages on MQ)</small>
<li> if <large><code><i>MQ</i></code></large> is full ...
<ul>
<li> blocks until MQ space available
<li> if <large><code>O_NONBLOCK</code></large> is set, fails and returns error
</ul>
<li> also, <large><font color="#008800"><b><code>mq_timedsend()</code></b></font></large> which
<ul>
<li> waits for specified time if MQ full
<li> fails if still no space on MQ after timeout
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>49/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mq_receive(mqd_t <i>MQ</i>,<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *<i>Msg</i>, int <i>Size</i>, uint *<i>Prio</i>)</code></b></font></large>
<ul>
<li> removes highest priority message from queue <large><code><i>MQ</i></code></large>
<li> if <large><code><i>*Prio</i></code></large> is not NULL, receives message priority
<li> if <large><code><i>MQ</i></code></large> is empty ...
<ul>
<li> blocks until a message is added to <large><code><i>MQ</i></code></large>
<li> if <large><code>O_NONBLOCK</code></large> is set, fails and returns error
</ul>
<li> if several processes blocked on <large><code>mq_receive()</code></large>
<ul>
<li> oldest and highest priority process receives the message
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>50/59</small></td></tr></table>
<p>
Pseudo-code showing structure of a MQ server program:
<p><pre><small>
main() {
   <comment>// set up message queue</comment>
   attr = (0,#msgs,MsgSize)
   mode = O_CREAT|O_RDWR
   mq = <font color='#000099'>mq_open</font>("/queue", mode, Perms, &attr)
   while (1) {
      <comment>// ask for request ... wait</comment>
      <font color='#000099'>mq_receive</font>(mq, InBuf, Size, NULL)
      <comment>... determine response ... put in OutBuf ...</comment>
      <font color='#000099'>mq_send</font>(mq, OutBuf, strlen(OutBuf), 0)
   }
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Message Queues</span></td><td align='right'><small>51/59</small></td></tr></table>
<p>
Pseudo-code showing structure of a MQ client program:
<p><pre><small>
main() {
   <comment>// set up message queue</comment>
   attr = (0,#msgs,MsgSize)
   mode = O_RDWR
   mq = <font color='#000099'>mq_open</font>("/queue", mode, Perms, &attr)
   <comment>// read request from user</comment>
   while (fgets(Request, Size, stdin) {
      <font color='#000099'>mq_send</font>(mq, Request, strlen(OutBuf), 0)
      <font color='#000099'>mq_receive</font>(mq, InBuf, Size, NULL)
      <comment>... get response ... act accordingly ...</comment>
   }
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Sockets</span></td><td align='right'><small>52/59</small></td></tr></table>
<p>
Inter-process communication (IPC) mechanisms considered so far
<ul>
<li> assume that both processes are on the same host
</ul>
How to implement systems that work across the network?
<ul>
<li> <small>e.g. web servers, networked databases, networked message queues, ...</small>
</ul>
Unix/Linux provides <em>sockets</em>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/networks/sockets-small.png]" src="Pics/networks/sockets-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>53/59</small></td></tr></table>
<p>
<em>Socket</em> = an end-point of an IPC channel
<ul>
<li> commonly used to construct client-server systems
<li> either locally (Unix domain) or network-wide (Internet domain)
<li> server creates a socket, then ...
<ul>
<li> binds to an address <small>(local or network)</small>
<li> listens for connections from clients
</ul>
<li> client creates a socket, then ...
<ul>
<li> connects to the server using known address
<li> writes to server via socket &nbsp;<small>(i.e. sends <em>requests</em>)</small>
<li> reads from server via socket &nbsp;<small>(i.e. receives <em>responses</em>)</small>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>54/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int socket(int <i>Domain</i>, int <i>Type</i>, int <i>Protocol</i>)</code></b></font></large>
<ul>
<li> requires <large><font color="#008800"><b><code>#include &lt;sys/socket.h&gt;</code></b></font></large>
<li> creates a socket, using ...
<ul>
<li> <large><font color="#008800"><b><code><i>Domain</i></code></b></font></large> ... communications domain
<ul>
<li> <large><code>AF_LOCAL</code></large> ... <small>on the local host (Unix domain)</small>
<li> <large><code>AF_INET</code></large> ... <small>over the network (Internet domain)</small>
</ul>
<li> <large><font color="#008800"><b><code><i>Type</i></code></b></font></large> ... semantics of communication
<ul>
<li> <large><code>SOCK_STREAM</code></large> ... <small>sequenced, reliable communications stream</small>
<li> <large><code>SOCK_DGRAM</code></large> ... <small>connectionless, unreliable packet transfer</small>
</ul>
<li> <large><font color="#008800"><b><code><i>Protocol</i></code></b></font></large> ... communication protocol
<ul>
<li> many exist (see <large><code>/etc/protocols</code></large>), <small>e.g. IP, TCP, UDP, ...</small>
</ul>
</ul>
<li> returns a socket descriptor <small>(small <large><code>int</code></large>)</small> or -1 on error
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>55/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int bind(int <i>Sockfd</i>, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <i>SockAddr</i> *<i>Addr</i>, socklen_t <i>AddrLen</i>)</code></b></font></large>
<ul>
<li> associates an open socket with an address
<li> for Unix Domain, address is a pathname in the file system
<li> for Internet Domain, address is IP address + port number
</ul>
<br>
<large><font color="#008800"><b><code>int listen(int <i>Sockfd</i>, int <i>Backlog</i>)</code></b></font></large>
<ul>
<li> wait for connections on socket <large><code><i>Sockfd</i></code></large>
<li> allow at most <large><code><i>Backlog</i></code></large> connections to be queued up
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>56/59</small></td></tr></table>
<p>
<large><font color="#008800"><b><code><i>SockAddr</i></code></b></font></large> &nbsp;=&nbsp; <large><font color="#008800"><b><code>struct sockaddr_in</code></b></font></large>
<ul>
<li> <large><font color="#008800"><b><code>sin_family</code></b></font></large> ... domain: &nbsp;<large><code>AF_UNIX</code></large>&nbsp; or &nbsp;<large><code>AF_INET</code></large>
<li> <large><font color="#008800"><b><code>sin_port</code></b></font></large> ... port number: <large><code>80</code></large>, <large><code>443</code></large>, etc.
<li> <large><font color="#008800"><b><code>sin_addr</code></b></font></large> ... structure containing host address
<li> <large><font color="#008800"><b><code>sin_zero[8]</code></b></font></large> ... padding
</ul>
Example:
<p><pre><small>
struct sockaddr_in web_server;
server = gethostbyname("www.cse.unsw.edu.au");
web_server.sin_family = AF_INET;
web_server.sin_addr.s_addr = server;
web_server.sin_port = htons(80);
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>57/59</small></td></tr></table>
<p>
<small><large><font color="#008800"><b><code>int accept(int <i>Sockfd</i>, <i>SockAddr</i> *<i>Addr</i>, socklen_t *<i>AddrLen</i>)</code></b></font></large></small>
<ul>
<li> <large><code><i>Sockfd</i></code></large> has been created, bound and is listening
<li> blocks until a connection request is received
<li> sets up a connection between client/server after <large><code>connect()</code></large>
<li> places information about the requestor in <large><code><i>Addr</i></code></large>
<li> returns a new socket descriptor, or -1 on error
</ul>
<br>
<small><large><font color="#008800"><b><code>int connect(int <i>Sockfd</i>, <i>SockAddr</i> *<i>Addr</i>, socklen_t <i>AddrLen</i>)</code></b></font></large></small>
<ul>
<li> connects the socket <large><code><i>Sockfd</i></code></large> to address <large><code><i>Addr</i></code></large>
<li> assumes that <large><code><i>Addr</i></code></large> contains a process listening appropriately
<li> returns 0 on success, or -1 on error
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>58/59</small></td></tr></table>
<p>
Pseudo-code showing structure of a simple client program:
<p><pre>
main() {
  s = socket(Domain, Type, Protocol)
  serverAddr = {Family,HostName,Port}
  connect(s, &serverAddr, Size)
  write(s, Message, MsgLength)
  read(s, Response, MaxLength)
  close(s)
}
</pre><p>
<br>
<small>(See <a target="_new" href="http://www.linuxhowtos.org/C_C++/socket.htm">http://www.linuxhowtos.org/C_C++/socket.htm</a>)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Sockets</span></td><td align='right'><small>59/59</small></td></tr></table>
<p>
Pseudo-code showing structure of a server program:
<p><pre><small>
main() {
   s = socket(Domain, Type, Protocol)
   serverAddr = {Family,HostName,Port}
   bind(s, serverAddr, Size)
   listen(s, QueueLen)
   while (1) {
      int ss = accept(s, &clientAddr, &Size)
      if (fork() != 0)
         close(ss)  <comment>// server not involved</comment>
      else {
         <comment>// fork of server handles request</comment>
         close(s)
         handleConnection(ss)
         exit(0)
      }
   }
}
</small></pre><p>
<p><hr><p>
<small><small>Produced: 2 May 2018</small></small>
</body>
</html>
