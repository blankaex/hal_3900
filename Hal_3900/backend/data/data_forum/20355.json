{"posts":[{"tags":[{"name":"forums"},{"name":"lectures"},{"name":"week 3"},{"name":"wed 5-6 lecture video: syscall, addressing modes"},{"name":"memory","salience":0.09179817140102386},{"name":"syntax","salience":0.08387650549411774},{"name":"var b","salience":0.07133708894252777},{"name":"variations","salience":0.06520456075668335},{"name":"syntax","salience":0.0630374625325203},{"name":"modes","salience":0.05742708593606949},{"name":"discussion","salience":0.05742708593606949},{"name":"examples","salience":0.05473458021879196},{"name":"b","salience":0.03232420235872269},{"name":"result","salience":0.03171463683247566},{"name":"instruction","salience":0.027393151074647903},{"name":"lecture examples","salience":0.027393151074647903},{"name":"0x1000","salience":0.023982329294085503},{"name":"declaration","salience":0.02198261022567749},{"name":"variable","salience":0.014285949058830738},{"name":"var","salience":0.012892095372080803},{"name":"c","salience":0.012554016895592213},{"name":"value","salience":0.011745517142117023},{"name":"var","salience":0.01158834621310234},{"name":"var","salience":0.011544806882739067},{"name":"var","salience":0.011487525887787342},{"name":"address","salience":0.010218270123004913},{"name":"memory address","salience":0.010093623772263527},{"name":"data","salience":0.010093623772263527},{"name":"0x1008","salience":0.009640688076615334},{"name":"data value","salience":0.009606702253222466},{"name":"memory location","salience":0.009564182721078396},{"name":"memory location","salience":0.00894622690975666},{"name":"load word instruction","salience":0.008912582881748676},{"name":"b","salience":0.00818684883415699},{"name":"line","salience":0.007468176539987326},{"name":"line","salience":0.007468176539987326},{"name":"slide","salience":0.0071951658464968204},{"name":"video","salience":0.00710730254650116},{"name":"memory address","salience":0.00692377146333456},{"name":"part","salience":0.006560835056006908},{"name":"symbol","salience":0.006069285795092583},{"name":"&amp","salience":0.005606114864349365},{"name":"another","salience":0.004924603272229433},{"name":"memory address","salience":0.004883153364062309},{"name":"data","salience":0.004883153364062309},{"name":"0x1000","salience":0.004613314755260944},{"name":"value","salience":0.004613314755260944},{"name":"0x1000","salience":0.004606637172400951},{"name":"example","salience":0.004295612685382366},{"name":"parentheses","salience":0.003960797563195229},{"name":"thanks","salience":0.003432059194892645},{"name":"data","salience":0.0030820334795862436},{"name":"memory address","salience":0.0030820334795862436},{"name":"data","salience":0.0030820334795862436},{"name":"idea","salience":0.002928538480773568},{"name":"instruction","salience":0.0027070660144090652},{"name":"memory location","salience":0.0027070660144090652},{"name":"parentheses","salience":0.002469003666192293},{"name":"sorts","salience":0.002168560866266489},{"name":"pointer","salience":0.002168560866266489}],"question":" In the discussion about memory addressing modes the following syntax (and variations) was used to provide different examples of symbolic, indirect and indexed addressing: a: lw $t0, var b: lw $t0, ($s0) I hadn't seen this syntax (where a declaration (a:) is combined with an instruction (lw $t0, var) before in the lecture examples so can I first confirm what this does? I understand the following: lw $t0, var would use the load word instruction to copy 'var' in to the register $t0 but what is the result when combined with a:? I believe the data stored in var, not the memory address, would be loaded into $t0 but then the slide/video then says this would result in \"computed address for a: is 0x1008\" given that &amp;var=0x1008. But why does a: equal the memory location of var when it seems we are copying the data value of var into $t0. Secondly, I think I also a little confused by the following line: b: lw $t0, ($s0) Leaving aside the b: part of the line above for the moment, because $s0 is contained within parentheses it is treated like a 'pointer' of sorts and the data within register $s0 is interpreted as a memory address so the instruction would copy the data at the memory location specified in $s0 into $t0. I am wondering firstly how we would come to have a memory address in $s0? Would it be like in C where would would use the &amp; symbol to find the memory location of a variable which could then save to another? Secondly, why again like in the first example does b end up computing to a value of 0x1000 when the value in $s0 is 0x1000? I thought the idea of using parentheses around $s0 means the data at memory address 0x1000 is copied not the value 0x1000 itself. Thanks ","answers":[]}]}