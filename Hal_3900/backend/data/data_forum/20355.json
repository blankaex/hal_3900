{"posts":[{"intent":"forum","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"lectures","salience":0.5,"theta":1},{"name":"week 3","salience":0.5,"theta":1},{"name":"wed 5 6 lecture video syscall addressing modes","salience":0.5,"theta":1}],"question":"in the discussion about memory addressing modes the following syntax and variations was used to provide different examples of symbolic indirect and indexed addressing a lw t0 var b lw t0 s0 i hadn t seen this syntax where a declaration a is combined with an instruction lw t0 var before in the lecture examples so can i first confirm what this does i understand the following lw t0 var would use the load word instruction to copy var in to the register t0 but what is the result when combined with a i believe the data stored in var not the memory address would be loaded into t0 but then the slide video then says this would result in computed address for a is 0x1008 given that amp var 0x1008 but why does a equal the memory location of var when it seems we are copying the data value of var into t0 secondly i think i also a little confused by the following line b lw t0 s0 leaving aside the b part of the line above for the moment because s0 is contained within parentheses it is treated like a pointer of sorts and the data within register s0 is interpreted as a memory address so the instruction would copy the data at the memory location specified in s0 into t0 i am wondering firstly how we would come to have a memory address in s0 would it be like in c where would would use the amp symbol to find the memory location of a variable which could then save to another secondly why again like in the first example does b end up computing to a value of 0x1000 when the value in s0 is 0x1000 i thought the idea of using parentheses around s0 means the data at memory address 0x1000 is copied not the value 0x1000 itself thanks","answers":[]}]}