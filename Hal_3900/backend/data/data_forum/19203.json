{"posts":[{"intent":"forum","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"tutorials","salience":0.5,"theta":1},{"name":"week 03 memory data representation","salience":0.5,"theta":1}],"question":"q18 not sure about the answers here anyone care to explain please","answers":[{"text":"it s just showing how a given set of bits can be interpreted in many ways","theta":1,"count":0}]},{"intent":"forum","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"tutorials","salience":0.5,"theta":1},{"name":"week 03 memory data representation","salience":0.5,"theta":1}],"question":"i noticed something interesting when looking at q11 using the following code include lt stdio h gt include lt stdlib h gt extern char etext edata end typedef struct int x int y int z str1 typedef struct char x int y float z str2 void main void int intptr short int sintptr char chptr char charray 5 int intarray 5 double dbptr str1 str1ptr str2 str2ptr printf etext p n amp etext printf edata p n amp edata printf end p n amp end printf n printf intptr address p n intptr printf sintptr address p n sintptr printf chptr address p n chptr printf charray address p n charray printf intarray address p n intarray printf dbptr address p n dbptr printf str1ptr address p n str1ptr printf str2ptr address p n str2ptr intptr sintptr chptr dbptr str1ptr str2ptr printf n printf intptr address p n intptr printf sintptr address p n sintptr printf chptr address p n chptr printf charray address p n charray printf intarray address p n intarray printf dbptr address p n dbptr printf str1ptr address p n str1ptr printf str2ptr address p n str2ptr that code produced the following output etext 0x8048678 edata 0x804a020 end 0x804a024 intptr address 0x8048621 sintptr address 0xfff37a7c chptr address 0xfff37a74 charray address 0xfff379a3 intarray address 0xfff3798c dbptr address 0x1 str1ptr address 0x804864b str2ptr address 0xf751ede0 intptr address 0x8048625 sintptr address 0xfff37a7e chptr address 0xfff37a75 charray address 0xfff379a3 intarray address 0xfff3798c dbptr address 0x9 str1ptr address 0x8048657 str2ptr address 0xf751edec what i find interesting is that all variables are local pointers yet they reference memory in four different areas some are in the data section intptr and str1ptr some are in the main stack sintptr chptr others are elsewhere in the stack str2ptr while dbptr is at some very strange address 0x1 originally is this because the pointers haven t actually been pointed to something with something like the following int num int intptr amp num when i add the above content to the code i get the following output where intptr now has a value in the same memory as sinptr and chptr seems strange why some pointers hold addresses similiar and others hold different when none have been set up to point at something specifically etext 0x8048688 edata 0x804a020 end 0x804a024 intptr content 0xff96d3e4 sintptr content 0xff96d4bc chptr content 0xff96d4b4 charray content 0xff96d3df intarray content 0xff96d3c8 dbptr content 0x1 str1ptr content 0x804865b str2ptr content 0xf7513de0 intptr content 0xff96d3e8 sintptr content 0xff96d4be chptr content 0xff96d4b5 charray content 0xff96d3df intarray content 0xff96d3c8 dbptr content 0x9 str1ptr content 0x8048667 str2ptr content 0xf7513dec thanks","answers":[]},{"intent":"forum","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"tutorials","salience":0.5,"theta":1},{"name":"week 03 memory data representation","salience":0.5,"theta":1}],"question":"i am looking at q8 from the tutorial and i am confused how the bitwise operations are working i know they do work as i compiled and ran the code but just not sure how so for example i understand to check if we have found a unicode character using 2 byte encoding we have the following masks defined define top4 0xf0 which is 11110000 and define mask2 0xc0 which is 11000000 i believe a 2 byte encoded unicode character will have the first byte in the form 110xxxxx and the second in the form 10xxxxxx to me that means the first byte must start with 110 and the second with 10 but all other bits can be any combination of 0s and 1s based on this understanding lets say i have a 2 byte character in this form 11011011 10110101 i have no idea what that represents but i believe it conforms to the 2 byte character encoding standard of unicode so in the following line of code from the answer to q8 if c amp top4 mask2 we perform a bitwise amp on the data at address c and the mask top4 11110000 in my example the first byte of my 2 byte character is 11011011 so by my calculations a bitwise amp on these would be c 11011011 top4 11110000 amp result 11010000 but the result is not the same as mask2 defined in the program as this is 0xc0 11000000 the value of mask2 seems assumes that the first byte of the 2 byte encoded character takes the form 11000000 and not 110xxxxx am i understanding the encoding of the multi byte characters wrong from what i can see the masks for 2 3 and 4 byte characters seem to imply the whole 1st byte must take a particular form not just the first 3 4 and 5 bits of the first byte respectively thanks","answers":[]}]}