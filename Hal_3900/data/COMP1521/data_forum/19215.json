{"posts":[{"intent":"assignments","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"lab classes","salience":0.5,"theta":1},{"name":"week 08 a minimal shell","salience":0.5,"theta":1}],"question":"i was trouble shooting my code and so changed teh compiler to dcc and it raised a seg fault with line 35 where the skeleton code loops through envp i what's going on","answers":[{"text":"hi robert i just ran the supplied code under dcc and it worked fine. check if you have edited anything before the start of the loop in main. and maybe just to be sure re-download a new copy and copy across the execute function and the loop body.","theta":1,"count":0},[{"text":"actually no it still messes up with dcc but executes exactly how it is supposed to with gcc","theta":1,"count":0}]]},{"intent":"assignments","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"lab classes","salience":0.5,"theta":1},{"name":"week 08 a minimal shell","salience":0.5,"theta":1}],"question":"i can't quite work out why a loop of mine doesn't seem to execute those lines in the the function after the loop ends. having played around with it the following loop seems to execute properly note that the condition is just fore testing int i 0 for i 0 i lt 9 i printf d n i printf ---ending execute n the above code produces the following 0 1 2 3 4 5 6 7 8 ---ending execute however when i add one line to the loop to print the path the line ---ending execute after the loop no longer prints. also the loop only increments to 6 and not 8 as per the loop condition int i 0 for i 0 i lt 9 i printf d element in path is s n i path i printf d n i printf ---ending execute n this outputs 0 element in path is /import/glass/4/z5200681/bin-pc.i86.linux 0 1 element in path is /import/glass/4/z5200681/bin 1 2 element in path is /usr/local/bin 2 3 element in path is /usr/bin 3 4 element in path is /bin 4 5 element in path is null 5 6 element in path is null 6 interestingly when i change path i to path 2 the loops starts working again. int i 0 for i 0 i lt 9 i printf d element in path is s n i path 2 printf d n i printf ---ending execute n this outputs 0 element in path is /usr/local/bin 0 1 element in path is /usr/local/bin 1 2 element in path is /usr/local/bin 2 3 element in path is /usr/local/bin 3 4 element in path is /usr/local/bin 4 5 element in path is /usr/local/bin 5 6 element in path is /usr/local/bin 6 7 element in path is /usr/local/bin 7 8 element in path is /usr/local/bin 8 ---ending execute can anyone provide any input as to why this happens as it seems utterly strange to me thanks","answers":[{"text":"why are you using i lt 9 as the loop condition do you know for sure that there are 9 elements in path i have no idea why the second loop terminates after 7 iterations but the fact that the last few iterations even work and show null is pure luck. if you use path 2 rather than path i it's hardly surprising that it runs for 9 iterations. why are you surprised","theta":1,"count":0},[{"text":"as mentioned the condition i lt 9 was just for testing. i was having some trouble with the correct condition which has since been resolved but as part of the troubleshooting i wanted to simplify my condition to check the operation of the loop. this is what led me to the above question - i wasn't sure why a printf statement would cause the loop to fail and actually it seems cause the child process to crash as the --ending execute line after the loop would not print whenever trying to print path i for values of i above 6. i understand that in this case maybe there is no path 7 or greater but i wouldn't think trying to print that string would have broken the loop. i thought at worst it may just print random data. when i gets to 5 and 6 i still prints something for printf d element in path is s n i path i lt span class redactor-invisible-space gt lt /span gt specifically 5 element in path is null 6 element in path is null even though path 5 and path 6 are null. i am not sure what is different about values of i above this which would actually cause the loop to break. i understand it may not print anything meaningful but i was surprised the loop if not the entire process broke as my understanding was the index i was a number of bytes past the start of the array.i also would have thought if it did try and access memory it wasn't allowed to it would have output an error of some sort to stdout but there has never been one. thanks","theta":1,"count":0}]]},{"intent":"assignments","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"lab classes","salience":0.5,"theta":1},{"name":"week 08 a minimal shell","salience":0.5,"theta":1}],"question":"permission denied hi i'm working on cse machine. but i get permission denied when used execve. so what should i do to avoid this thank you in advance","answers":[{"text":"it's possible that your parameters to execve are not right ... despite the message about executing /bin/ls . you might want to print the values of the arguments that you're actually passing to execve or use gdb to help you check them.","theta":1,"count":0}]},{"intent":"assignments","courseCode":"COMP1521","tags":[{"name":"forums","salience":0.5,"theta":1},{"name":"lab classes","salience":0.5,"theta":1},{"name":"week 08 a minimal shell","salience":0.5,"theta":1}],"question":"hi i wonder why command cd does not work in my-shell is it due to cd is not in the directory /bin and if so is it possible to achieve this goal thanks","answers":[{"text":"good question ... and to be resolved in assignment 2. cd is a special command built-into the shell. it needs to be built in because it changes the state of the shell. programs that you execute via execve run as separate processes and do not affect the shell's internal state. you can achieve this via chdir . read the manual entry.","theta":1,"count":0},[{"text":"got it. thanks","theta":1,"count":0}]]}]}