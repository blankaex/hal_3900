{"posts":[{"tags":[{"name":"Forums"},{"name":"Lectures"},{"name":"Week 3"},{"name":"Wed 5-6 Lecture Video: syscall, Addressing modes"}],"question":" In the discussion about memory addressing modes the following syntax (and variations) was used to provide different examples of symbolic, indirect and indexed addressing: a: lw $t0, var b: lw $t0, ($s0) I hadn't seen this syntax (where a declaration (a:) is combined with an instruction (lw $t0, var) before in the lecture examples so can I first confirm what this does? I understand the following: lw $t0, var would use the load word instruction to copy 'var' in to the register $t0 but what is the result when combined with a:? I believe the data stored in var, not the memory address, would be loaded into $t0 but then the slide/video then says this would result in \"computed address for a: is 0x1008\" given that &amp;var=0x1008. But why does a: equal the memory location of var when it seems we are copying the data value of var into $t0. Secondly, I think I also a little confused by the following line: b: lw $t0, ($s0) Leaving aside the b: part of the line above for the moment, because $s0 is contained within parentheses it is treated like a 'pointer' of sorts and the data within register $s0 is interpreted as a memory address so the instruction would copy the data at the memory location specified in $s0 into $t0. I am wondering firstly how we would come to have a memory address in $s0? Would it be like in C where would would use the &amp; symbol to find the memory location of a variable which could then save to another? Secondly, why again like in the first example does b end up computing to a value of 0x1000 when the value in $s0 is 0x1000? I thought the idea of using parentheses around $s0 means the data at memory address 0x1000 is copied not the value 0x1000 itself. Thanks ","answers":[]}]}