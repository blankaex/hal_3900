{"posts":[{"tags":[{"name":"forums"},{"name":"tutorials"},{"name":"week 03: memory, data representation"},{"name":"q18","salience":0.6971759796142578},{"name":"answers","salience":0.23335595428943634},{"name":"anyone","salience":0.06946808099746704}],"question":" Q18: Not sure about the answers here. Anyone care to explain please? ","answers":[" It's just showing how a given set of bits can be interpreted in many ways "]},{"tags":[{"name":"forums"},{"name":"tutorials"},{"name":"week 03: memory, data representation"},{"name":"0xfff37a7c chptr","salience":0.1125837117433548},{"name":"intptr","salience":0.04712672531604767},{"name":"dbptr","salience":0.043028950691223145},{"name":"output","salience":0.03253700211644173},{"name":"printf","salience":0.03234732523560524},{"name":"sintptr","salience":0.029356565326452255},{"name":"char","salience":0.02296629175543785},{"name":"char charray","salience":0.02296629175543785},{"name":"char","salience":0.02296629175543785},{"name":"code","salience":0.022637544199824333},{"name":"str1ptr++","salience":0.020792031660676003},{"name":"int y","salience":0.02065371721982956},{"name":"int","salience":0.02065371721982956},{"name":"int","salience":0.02065371721982956},{"name":"int","salience":0.02065371721982956},{"name":"int","salience":0.02065371721982956},{"name":"int","salience":0.02065371721982956},{"name":"something","salience":0.016589315608143806},{"name":"end","salience":0.015457388944923878},{"name":"edata","salience":0.015457388944923878},{"name":"char etext","salience":0.015457388944923878},{"name":"float z","salience":0.014110171236097813},{"name":"int z","salience":0.014110171236097813},{"name":"void","salience":0.012406628578901291},{"name":"0x8048657 str2ptr","salience":0.011774575337767601},{"name":"intptr","salience":0.010540778748691082},{"name":"printf","salience":0.010121633298695087},{"name":"printf","salience":0.010121633298695087},{"name":"intptr address %p\\n","salience":0.010121633298695087},{"name":"printf","salience":0.010121633298695087},{"name":"printf","salience":0.010121633298695087},{"name":"n","salience":0.010121633298695087},{"name":"printf","salience":0.010121633298695087},{"name":"q11","salience":0.007354599889367819},{"name":"printf","salience":0.006839997600764036},{"name":"sintptr address %p\\n","salience":0.006839997600764036},{"name":"printf","salience":0.006839997600764036},{"name":"chptr address %p\\n","salience":0.006839997600764036},{"name":"printf","salience":0.006839997600764036},{"name":"charray address %p\\n","salience":0.006839997600764036},{"name":"printf","salience":0.006839997600764036},{"name":"intarray address %p\\n","salience":0.006839997600764036},{"name":"printf","salience":0.006839997600764036},{"name":"@%p\\n","salience":0.005880577024072409},{"name":"etext","salience":0.005880577024072409},{"name":"@%p\\n","salience":0.005880577024072409},{"name":"etext","salience":0.005880577024072409},{"name":"edata","salience":0.005880577024072409},{"name":"@%p\\n","salience":0.005880577024072409},{"name":"end","salience":0.005880577024072409},{"name":"edata","salience":0.005880577024072409},{"name":"intarray","salience":0.005319226533174515},{"name":"0x8048621 sintptr","salience":0.004787311423569918},{"name":"chptr address %p\\n","salience":0.0038596622180193663},{"name":"charray address %p\\n","salience":0.0038596622180193663},{"name":"str2ptr address %p\\n","salience":0.00381253520026803},{"name":"address %p\\n","salience":0.00381253520026803},{"name":"address","salience":0.0035415850579738617},{"name":"address","salience":0.0035415850579738617},{"name":"address","salience":0.0035415850579738617},{"name":"str2ptr address %p\\n","salience":0.0035415850579738617},{"name":"intarray address %p\\n","salience":0.0035415850579738617},{"name":"str1ptr address %p\\n","salience":0.0035415850579738617},{"name":"dbptr address %p\\n","salience":0.0035415850579738617},{"name":"charray","salience":0.0035040450748056173},{"name":"intptr address %p\\n","salience":0.0033275841269642115},{"name":"sintptr address %p\\n","salience":0.0033275841269642115},{"name":"n","salience":0.0033275841269642115},{"name":"printf","salience":0.0033275841269642115},{"name":"str1ptr address %p\\n","salience":0.003286939114332199},{"name":"addresses","salience":0.0030522621236741543},{"name":"0x804864b str2ptr","salience":0.002629799535498023},{"name":"str1ptr","salience":0.0025202976539731026},{"name":"intarray","salience":0.0023730220273137093},{"name":"content","salience":0.0021339573431760073},{"name":"dbptr","salience":0.0019855271093547344},{"name":"intptr","salience":0.0019230289617553353},{"name":"pointers","salience":0.0018776186043396592},{"name":"chptr","salience":0.001874421490356326},{"name":"int","salience":0.0017682346515357494},{"name":"charray","salience":0.0015621362254023552},{"name":"content","salience":0.0014874424086883664},{"name":"sintptr content","salience":0.0014874424086883664},{"name":"chptr content","salience":0.0014874424086883664},{"name":"charray content","salience":0.0014874424086883664},{"name":"intarray content","salience":0.0014874424086883664},{"name":"content","salience":0.0014874424086883664},{"name":"content","salience":0.0014874424086883664},{"name":"content","salience":0.0014874424086883664},{"name":"intarray content","salience":0.0014874424086883664},{"name":"charray content","salience":0.0014874424086883664},{"name":"chptr content","salience":0.0014874424086883664},{"name":"sintptr content","salience":0.0014874424086883664},{"name":"content","salience":0.0014874424086883664},{"name":"pointers","salience":0.0014376032631844282},{"name":"something","salience":0.0014165602624416351},{"name":"something","salience":0.0014165602624416351},{"name":"address 0x1","salience":0.001322573283687234},{"name":"code","salience":0.001318946247920394},{"name":"stack","salience":0.0012062592431902885},{"name":"memory","salience":0.0012029509525746107},{"name":"following","salience":0.0012029509525746107},{"name":"others","salience":0.0011769287521019578},{"name":"address","salience":0.0011706915684044361},{"name":"intarray address","salience":0.0011706915684044361},{"name":"address","salience":0.0011706915684044361},{"name":"charray address","salience":0.0011706915684044361},{"name":"address","salience":0.0011706915684044361},{"name":"address","salience":0.0011706915684044361},{"name":"address","salience":0.001164863700978458},{"name":"intarray address","salience":0.001164863700978458},{"name":"charray address","salience":0.001164863700978458},{"name":"elsewhere","salience":0.001059468719176948},{"name":"sinptr","salience":0.0010565627599135041},{"name":"value","salience":0.0010565627599135041},{"name":"int num","salience":0.0010565627599135041},{"name":"sintptr++","salience":0.0010400665923953056},{"name":"pointers","salience":0.0010162482503801584},{"name":"something","salience":0.0009891176596283913},{"name":"content 0xf7513de0","salience":0.0009872425580397248},{"name":"etext@0x8048678 edata@0x804a020 end@0x804a024","salience":0.000954199698753655},{"name":"content 0x1","salience":0.0009191936114802957},{"name":"content 0x9","salience":0.0008383342646993697},{"name":"none","salience":0.0008343399967998266},{"name":"thanks","salience":0.0007362939068116248},{"name":"others","salience":0.000648568500764668},{"name":"some","salience":0.0006074982811696827},{"name":"some","salience":0.0006074982811696827},{"name":"0x1","salience":0.0005846850690431893},{"name":"memory","salience":0.0005305850645527244},{"name":"stack","salience":0.0005287088570185006},{"name":"sintptr","salience":0.0005287088570185006},{"name":"0xfff37a7e chptr","salience":0.0004886090173386037},{"name":"areas","salience":0.00046599117922596633},{"name":"data section","salience":0.00046434332034550607},{"name":"variables","salience":0.00045465477160178125}],"question":" I noticed something interesting when looking at Q11 using the following code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; extern char etext, edata, end; typedef struct { int x; int y; int z; } str1; typedef struct { char x; int y; float z; } str2; void main (void){ int *intptr; short int *sintptr; char *chptr; char charray[5]; int intarray[5]; double *dbptr; str1 *str1ptr; str2 *str2ptr; printf(\"etext@%p\\n\",&amp;etext); printf(\"edata@%p\\n\",&amp;edata); printf(\"end@%p\\n\",&amp;end); printf(\"-------------------------\\n\"); printf(\"intptr address %p\\n\", intptr); printf(\"sintptr address %p\\n\", sintptr); printf(\"chptr address %p\\n\", chptr); printf(\"charray address %p\\n\", charray); printf(\"intarray address %p\\n\", intarray); printf(\"dbptr address %p\\n\", dbptr); printf(\"str1ptr address %p\\n\", str1ptr); printf(\"str2ptr address %p\\n\", str2ptr); intptr++; sintptr++; chptr++; dbptr++; str1ptr++; str2ptr++; printf(\"-------------------------\\n\"); printf(\"intptr address %p\\n\", intptr); printf(\"sintptr address %p\\n\", sintptr); printf(\"chptr address %p\\n\", chptr); printf(\"charray address %p\\n\", charray); printf(\"intarray address %p\\n\", intarray); printf(\"dbptr address %p\\n\", dbptr); printf(\"str1ptr address %p\\n\", str1ptr); printf(\"str2ptr address %p\\n\", str2ptr); } That code produced the following output: etext@0x8048678 edata@0x804a020 end@0x804a024 ------------------------- intptr address 0x8048621 sintptr address 0xfff37a7c chptr address 0xfff37a74 charray address 0xfff379a3 intarray address 0xfff3798c dbptr address 0x1 str1ptr address 0x804864b str2ptr address 0xf751ede0 ------------------------- intptr address 0x8048625 sintptr address 0xfff37a7e chptr address 0xfff37a75 charray address 0xfff379a3 intarray address 0xfff3798c dbptr address 0x9 str1ptr address 0x8048657 str2ptr address 0xf751edec What I find interesting is that all variables are local pointers yet they reference memory in four different areas. Some are in the data section (intptr and str1ptr), some are in the main() stack (sintptr, chptr), others are elsewhere in the stack (str2ptr) while dbptr is at some very strange address 0x1 originally. Is this because the pointers haven't actually been 'pointed' to something with something like the following: int num; int *intptr = &amp;num; When I add the above content to the code I get the following output where intptr now has a value in the same memory as sinptr and chptr. Seems strange why some pointers hold addresses similiar and others hold different when none have been set up to point at something specifically. etext@0x8048688 edata@0x804a020 end@0x804a024 ------------------------- intptr content 0xff96d3e4 sintptr content 0xff96d4bc chptr content 0xff96d4b4 charray content 0xff96d3df intarray content 0xff96d3c8 dbptr content 0x1 str1ptr content 0x804865b str2ptr content 0xf7513de0 ------------------------- intptr content 0xff96d3e8 sintptr content 0xff96d4be chptr content 0xff96d4b5 charray content 0xff96d3df intarray content 0xff96d3c8 dbptr content 0x9 str1ptr content 0x8048667 str2ptr content 0xf7513dec Thanks ","answers":[]},{"tags":[{"name":"forums"},{"name":"tutorials"},{"name":"week 03: memory, data representation"},{"name":"mask2 0xc0","salience":0.1535806655883789},{"name":"byte","salience":0.13352471590042114},{"name":"operations","salience":0.06364639103412628},{"name":"tutorial","salience":0.06364639103412628},{"name":"top4 0xf0","salience":0.042328398674726486},{"name":"idea","salience":0.03835053741931915},{"name":"code","salience":0.03504607453942299},{"name":"example","salience":0.03487331047654152},{"name":"mask2 #","salience":0.03396538272500038},{"name":"byte","salience":0.021594800055027008},{"name":"character","salience":0.018827736377716064},{"name":"byte","salience":0.01882239431142807},{"name":"masks","salience":0.018134554848074913},{"name":"unicode character","salience":0.018084565177559853},{"name":"encoding","salience":0.014719590544700623},{"name":"byte","salience":0.014413083903491497},{"name":"character","salience":0.012610132806003094},{"name":"mask","salience":0.01124294102191925},{"name":"form","salience":0.011216464452445507},{"name":"form","salience":0.011134895496070385},{"name":"form","salience":0.011134895496070385},{"name":"bits","salience":0.010965999215841293},{"name":"1st byte","salience":0.010463036596775055},{"name":"&amp","salience":0.009676369838416576},{"name":"combination","salience":0.009634442627429962},{"name":"c","salience":0.009010784327983856},{"name":"second","salience":0.008924133144319057},{"name":"form","salience":0.0088266059756279},{"name":"character","salience":0.008777091279625893},{"name":"characters","salience":0.008766819722950459},{"name":"code","salience":0.008219634182751179},{"name":"example","salience":0.008207746781408787},{"name":"understanding","salience":0.007897412404417992},{"name":"unicode","salience":0.007882465608417988},{"name":"character encoding standard","salience":0.007882465608417988},{"name":"line","salience":0.007869541645050049},{"name":"answer","salience":0.007220827508717775},{"name":"address","salience":0.007220827508717775},{"name":"data","salience":0.007220827508717775},{"name":"byte","salience":0.007061798591166735},{"name":"encoding","salience":0.0067656817846000195},{"name":"byte characters","salience":0.006284368224442005},{"name":"masks","salience":0.006279551889747381},{"name":"form","salience":0.006166339386254549},{"name":"value","salience":0.005562473088502884},{"name":"program","salience":0.005434367805719376},{"name":"bits","salience":0.004940574988722801},{"name":"character","salience":0.0038559597451239824},{"name":"thanks","salience":0.0037866709753870964},{"name":"same","salience":0.0030480881687253714},{"name":"result","salience":0.0028661771211773157},{"name":"calculations","salience":0.0023829848505556583}],"question":" I am looking at Q8 from the tutorial and I am confused how the bitwise operations are working. I know they do work as I compiled and ran the code but just not sure how so. For example, I understand to check if we have found a unicode character using 2-byte encoding we have the following masks defined: #define TOP4 0xF0 which is 11110000, and #define MASK2 0xC0 which is 11000000. I believe a 2 byte encoded unicode character will have the first byte in the form 110xxxxx and the second in the form 10xxxxxx. To me that means the first byte must start with 110 and the second with 10 but all other bits can be any combination of 0s and 1s. Based on this understanding lets say I have a 2-byte character in this form 11011011 10110101. I have no idea what that represents but I believe it conforms to the 2-byte character encoding standard of unicode. So in the following line of code from the answer to Q8 if ( (*c &amp; TOP4) == MASK2 ){ We perform a bitwise &amp; on the data at address 'c' and the mask TOP4 (11110000). In my example, the first byte of my 2-byte character is 11011011 so by my calculations a bitwise &amp; on these would be: c 11011011 TOP4 11110000 &amp; Result 11010000 But the result is not the same as MASK2 #defined in the program as this is 0xC0 (11000000). The value of MASK2 seems assumes that the first byte of the 2-byte encoded character takes the form 11000000 and not 110xxxxx. Am I understanding the encoding of the multi-byte characters wrong? From what I can see the masks for 2, 3 and 4 byte characters seem to imply the whole 1st byte must take a particular form, not just the first 3, 4 and 5 bits of the first byte respectively. Thanks ","answers":[]}]}