<html>
<head>
<title>C: Assembly Language (MIPS)</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>C: Assembly Language (MIPS)</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Instruction Set Architectures</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>CPU Architecture</span></td><td align='right'><small>2/114</small></td></tr></table>
<p>
A typical modern CPU has
<ul>
<li> a set of data registers
<li> a set of control registers (incl PC)
<li> an arithmetic-logic unit (ALU)
<li> access to random access memory (RAM)
<li> a set of simple instructions
<ul>
<li> transfer data between memory and registers
<li> push values through the ALU to compute results
<li> make tests and transfer control of execution
</ul>
</ul>
<br>
Different types of processors have different configurations of the above
<ul>
<li> <small>e.g. different # registers, different sized registers, different instructions</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Why Study Assembler?</span></td><td align='right'><small>3/114</small></td></tr></table>
<p>
Useful to know assembly language because ...
<ul>
<li> sometimes you are <i>required</i> to use it &nbsp; <small>(e.g. device handlers)</small>
<li> improves your understanding of how C programs execute
<ul>
<li> very helpful when debugging
<li> able to avoid using known inefficient constructs
</ul>
<li> uber-nerdy performance tweaking &nbsp; <small>(squeezing out last nano-s)</small>
<ul>
<li> re-write that critical (frequently-used) function in assembler
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Instruction Sets</span></td><td align='right'><small>4/114</small></td></tr></table>
<p>
Two broad families of instruction set architectures ...
<p>
RISC &nbsp;(<em>reduced instruction set computer</em>)
<ul>
<li> small(ish) set of simple, general instructions
<li> separate computation & data transfer instructions
<li> leading to simpler processor hardware
<li> e.g. MIPS, RISC, Alpha, SPARC, PowerPC, ARM, ...
</ul>
CISC &nbsp;(<em>complex instruction set computer</em>)
<ul>
<li> large(r) set of powerful instructions
<li> each instruction has multiple actions (comp+store)
<li> more circuitry to decode/process instructions
<li> e.g. PDP, VAX, Z80, Motorola 68xxx, Intel x86, ...
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Instruction Sets</span></td><td align='right'><small>5/114</small></td></tr></table>
<p>
Machine-level instructions ...
<ul>
<li> typically have 1-2 32-bit words per instruction
<li> partition bits in each word into operator & operands
<li> #bits for each depends on #instructions, #registers, ...
</ul>
Example instruction word formats:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/instr-words-small.png]" src="Pics/processor/instr-words-small.png">
</div><p>
<p>
<i>Operands</i> and <i>destination</i> are typically registers
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Instruction Sets</span></td><td align='right'><small>6/114</small></td></tr></table>
<p>
Common kinds of instructions <tiny>(not from any real machine)</tiny>
<ul>
<li> <large><font color="#008800"><b><code>load</code></b></font></large> &nbsp;<i>Register</i><large><code>,</code></large> <i>MemoryAddress</i>
<ul>
<li> copy value stored in memory at address into named register
</ul>
<li> <large><font color="#008800"><b><code>loadc</code></b></font></large> &nbsp;<i>Register</i><large><code>,</code></large> <i>ConstantValue</i>
<ul>
<li> copy value into named register
</ul>
<li> <large><font color="#008800"><b><code>store</code></b></font></large> &nbsp;<i>Register</i><large><code>,</code></large> <i>MemoryAddress</i>
<ul>
<li> copy value stored in named register into memory at address
</ul>
<li> <large><font color="#008800"><b><code>jump</code></b></font></large> &nbsp;<i>MemoryAddress</i>
<ul>
<li> transfer execution of program to instruction at address
</ul>
<li> <large><font color="#008800"><b><code>jumpif</code></b></font></large> &nbsp;<i>Register</i><large><code>,</code></large> <i>MemoryAddress</i>
<ul>
<li> transfer execution of program if e.g. register holds zero value
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Instruction Sets</span></td><td align='right'><small>7/114</small></td></tr></table>
<p>
Other common kinds of instructions <tiny>(not from any real machine)</tiny>
<ul>
<li> <large><font color="#008800"><b><code>add</code></b></font></large> &nbsp;<i>Register<sub>1</sub></i><large><code>,</code></large> <i>Register<sub>2</sub></i><large><code>,</code></large> <i>Register<sub>3</sub></i>
&nbsp;&nbsp; <small>(similarly for &nbsp;<large><font color="#008800"><b><code>sub</code></b></font></large>, &nbsp;<large><font color="#008800"><b><code>mul</code></b></font></large>, &nbsp;<large><font color="#008800"><b><code>div</code></b></font></large>)</small>
<ul>
<li> <i>Register<sub>3</sub></i> = <i>Register<sub>1</sub></i> <large><code>+</code></large> <i>Register<sub>2</sub></i>
</ul>
<li> <large><font color="#008800"><b><code>and</code></b></font></large> &nbsp;<i>Register<sub>1</sub></i><large><code>,</code></large> <i>Register<sub>2</sub></i><large><code>,</code></large> <i>Register<sub>3</sub></i>
&nbsp;&nbsp; <small>(similarly for &nbsp;<large><font color="#008800"><b><code>or</code></b></font></large>, &nbsp;<large><font color="#008800"><b><code>xor</code></b></font></large>)</small>
<ul>
<li> <i>Register<sub>3</sub></i> = <i>Register<sub>1</sub></i> <large><code>&</code></large> <i>Register<sub>2</sub></i>
</ul>
<li> <large><font color="#008800"><b><code>neg</code></b></font></large> &nbsp;<i>Register<sub>1</sub></i><large><code>,</code></large> <i>Register<sub>2</sub></i> 
<ul>
<li> <i>Register<sub>2</sub></i> = <large><code>~</code></large> <i>Register<sub>1</sub></i>
</ul>
<li> <large><font color="#008800"><b><code>shiftl</code></b></font></large> &nbsp;<i>Register<sub>1</sub></i><large><code>,</code></large> <i>Value</i><large><code>,</code></large> <i>Register<sub>2</sub></i> 
&nbsp;&nbsp; <small>(similarly for &nbsp;<large><font color="#008800"><b><code>shiftr</code></b></font></large>)</small>
<ul>
<li> <i>Register<sub>2</sub></i> = <i>Register<sub>1</sub></i> <large><code> &lt;< </code></large> <i>Value</i>
</ul>
<li> <large><font color="#008800"><b><code>syscall</code></b></font></large> <i>Value</i>
<ul>
<li> invoke a system service; which service determined by <i>Value</i>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Instruction Sets</span></td><td align='right'><small>8/114</small></td></tr></table>
<p>
<p><br><p>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/cpu-mem-small.png]" src="Pics/processor/cpu-mem-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Fetch-Execute Cycle</span></td><td align='right'><small>9/114</small></td></tr></table>
<p>
All CPUs have program execution logic like:
<p><pre>
while (1)
{
   instruction = memory[PC]
   PC++  <comment>// move to next instr</comment>
   if (instruction == HALT)
      break
   else
      execute(instruction)
}
</pre><p>
<br>
PC = Program Counter, a CPU register which keeps track of execution
<p>
Note that some instructions may modify PC further <small>(e.g. JUMP)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Fetch-Execute Cycle</span></td><td align='right'><small>10/114</small></td></tr></table>
<p>
Executing an <large><code>instruction</code></large> involves
<ul>
<li> determine what the <font color='#CC0000'>operator</font> is
<li> determine which <font color='#009900'>registers</font>, if any, are involved
<li> determine which <font color='#0000CC'>memory location</font>, if any, is involved
<li> carry out the operation with the relevant operands
<li> store result, if any, in appropriate register
</ul>
Example instruction encodings <small>(not from a real machine)</small>:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/instructions-small.png]" src="Pics/processor/instructions-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Assembly Language</span></td><td align='right'><small>11/114</small></td></tr></table>
<p>
Instructions are simply bit patterns within a 32-bit bit-string
<p>
Could describe machine programs as a sequence of hex digits, e.g.
<p><pre>
Address   Content
0x100000  0x3c041001
0x100004  0x34020004
0x100008  0x0000000c
0x10000C  0x03e00008
</pre><p>
<p>
<br>
Often call "assembly language" as "assembler"
<p>
Slight notational abuse, because "assembler" also refers to a program
that translates assembly language to machine code
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Assembly Language</span></td><td align='right'><small>12/114</small></td></tr></table>
<p>
Assembler = symbolic language for writing machine code
<ul>
<li> write instructions using mnemonics rather than hex codes
<li> reference registers using either numbers or names
<li> can associate names to memory addresses
</ul>
<br>
Style of expression is significantly different to e.g. C
<ul>
<li> need to use fine-grained control of memory usage
<li> required to manipulate data in registers
<li> control structures programmed via explicit jumps
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Architecture</span></td><td align='right'><small>13/114</small></td></tr></table>
<p>
MIPS is a well-known and relatively simple architecture
<ul>
<li> very popular in a range of computing devices in the 1990's
<li> e.g. Silicon Graphics, NEC, Nintendo64, Playstation, supercomputers
</ul>
We consider the MIPS32 version of the MIPS family
<ul>
<li> using two variants of the open-source SPIM emulator
<li> <large><font color="#008800"><b><code>qtspim</code></b></font></large> ... provides a GUI front-end, useful for debugging
<li> <large><font color="#008800"><b><code>spim</code></b></font></large> ... command-line based version, useful for testing
<li> <large><font color="#008800"><b><code>xspim</code></b></font></large> ... GUI front-end, useful for debugging, only in CSE labs
</ul>
Executables and source: <font color='#000099'>http://spimsimulator.sourceforge.net/</font>
<p>
Source code for browsing under <font color='#000099'>/home/cs1521/spim/spim</font>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS vs SPIM</span></td><td align='right'><small>14/114</small></td></tr></table>
<p>
MIPS is a machine architecture, including instruction set
<p>
SPIM is an <em>emulator</em> for the MIPS instruction set
<ul>
<li> reads text files containing instruction + directives
<li> converts to machine code and loads into "memory"
<li> provides debugging capabilities
<ul>
<li> single-step, breakpoints, view registers/memory, ...
</ul>
<li> provides mechanism to interact with operating system (syscall)
</ul>
Also provides extra instructions, mapped to MIPS core set
<ul>
<li> provide convenient/mnemonic ways to do common operations
<li> e.g. &nbsp;<large><code>move $s0,$v0</code></large>&nbsp; rather than &nbsp;<large><code>addu $s0,$0,$v0</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Using SPIM</span></td><td align='right'><small>15/114</small></td></tr></table>
<p>
Three ways to execute MIPS code with SPIM
<ul>
<li> <large><font color="#008800"><b><code>spim</code></b></font></large> ... command line tool
<ul>
<li> load programs using <large><code>-file</code></large> option
<li> interact using stdin/stdout via login terminal
</ul>
<li> <large><font color="#008800"><b><code>qtspim</code></b></font></large> ... GUI environment
<ul>
<li> load programs via a load button
<li> interact via a pop-up stdin/stdout terminal
</ul>
<li> <large><font color="#008800"><b><code>xspim</code></b></font></large> ... GUI environment
<ul>
<li> similar to <large><code>qtspim</code></large>, but not as pretty
<li> requires X-windows server
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Using SPIM</span></td><td align='right'><small>16/114</small></td></tr></table>
<p>
Command-line tool:
<p><div class='center'>
<img alt="[Diagram:Pics/mips/use-spim-small.png]" src="Pics/mips/use-spim-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Using SPIM</span></td><td align='right'><small>17/114</small></td></tr></table>
<p>
GUI tool:
<p><div class='center'>
<img alt="[Diagram:Pics/mips/use-qtspim-small.png]" src="Pics/mips/use-qtspim-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Machine Archtecture</span></td><td align='right'><small>18/114</small></td></tr></table>
<p>
MIPS CPU has
<ul>
<li> 32 &times; 32-bit general purpose registers
<li> 16 &times; 64-bit double-precision registers
<li> PC ... 32-bit register <small>(always aligned on 4-byte boundary)</small>
<li> HI,LO ... for storing results of multiplication and division
</ul>
Registers can be referred to as <large><code>$0..$31</code></large> or by symbolic names
<p>
Some registers have special uses e.g.
<ul>
<li> register <large><code>$0</code></large> always has value 0, cannot be written
<li> registers <large><code>$1</code></large>, <large><code>$26</code></large>, <large><code>$27</code></large> reserved for use by system
</ul>
More details on following slides ...
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Machine Archtecture</span></td><td align='right'><small>19/114</small></td></tr></table>
<p>
Registers and their usage
<p>
<table cellspacing="8">
<tr><td><b>Reg</b></td><td>&nbsp;</td><td><b>Name</b></td><td>&nbsp;</td><td><b>Notes</b></td></tr>
<tr>
 <td><large><code>$0</code></large></td><td>&nbsp;</td><td><large><code>zero</code></large></td><td>&nbsp;</td>
 <td><small>the value 0, not changeable</small></td>
</tr>
<tr>
 <td><large><code>$1</code></large></td><td>&nbsp;</td><td><large><code>$at</code></large></td><td>&nbsp;</td>
 <td><small><b>a</b>ssembler <b>t</b>emporary; used to implement pseudo-ops</small></td>
</tr>
<tr>
 <td><large><code>$2</code></large></td><td>&nbsp;</td><td><large><code>$v0</code></large></td><td>&nbsp;</td>
 <td><small><b>v</b>alue from expression evaluation or function return</small></td>
</tr>
<tr>
 <td><large><code>$3</code></large></td><td>&nbsp;</td><td><large><code>$v1</code></large></td><td>&nbsp;</td>
 <td><small><b>v</b>alue from expression evaluation or function return</small></td>
</tr>
<tr>
 <td><large><code>$4</code></large></td><td>&nbsp;</td><td><large><code>$a0</code></large></td><td>&nbsp;</td>
 <td><small>first <b>a</b>rgument to a function/subroutine, if needed</small></td>
</tr>
<tr>
 <td><large><code>$5</code></large></td><td>&nbsp;</td><td><large><code>$a1</code></large></td><td>&nbsp;</td>
 <td><small>second <b>a</b>rgument to a function/subroutine, if needed</small></td>
</tr>
<tr>
 <td><large><code>$6</code></large></td><td>&nbsp;</td><td><large><code>$a2</code></large></td><td>&nbsp;</td>
 <td><small>third <b>a</b>rgument to a function/subroutine, if needed</small></td>
</tr>
<tr>
 <td><large><code>$7</code></large></td><td>&nbsp;</td><td><large><code>$a3</code></large></td><td>&nbsp;</td>
 <td><small>fourth <b>a</b>rgument to a function/subroutine, if needed</small></td>
</tr>
<tr valign="top">
 <td><large><code>$8</code></large>..<large><code>$15</code></large></td><td>&nbsp;</td><td><large><code>$t0</code></large>..<large><code>$t7</code></large></td><td>&nbsp;</td>
 <td><small><b>t</b>emporary; must be saved by caller to subroutine;<br>subroutine can overwrite</small></td>
</tr>
</table>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Machine Archtecture</span></td><td align='right'><small>20/114</small></td></tr></table>
<p>
More register usage ...
<p>
<table cellspacing="8">
<tr><td><b>Reg</b></td><td>&nbsp;</td><td><b>Name</b></td><td>&nbsp;</td><td><b>Notes</b></td></tr>
<tr valign="top">
 <td><nobr><large><code>$16</code></large></code></large>..<large><code><large><code>$23</code></large></nobr></td><td>&nbsp;</td><td><nobr><large><code>$s0</code></large>..<large><code>$s7</code></large></nobr></td><td>&nbsp;</td>
 <td><small><b>s</b>afe function variable;<br>must not be overwritten by called subroutine</small></td>
</tr>
<tr valign="top">
 <td><large><code>$24</code></large>..<large><code>$25</code></large></td><td>&nbsp;</td><td><large><code>$t8</code></large>..<large><code>$t9</code></large></td><td>&nbsp;</td>
 <td><small><b>t</b>emporary; must be saved by caller to subroutine;<br>subroutine can overwrite</small></td>
</tr>
<tr valign="top">
 <td><large><code>$26</code></large>..<large><code>$27</code></large></td><td>&nbsp;</td><td><large><code>$k0</code></large>..<large><code>$k1</code></large></td><td>&nbsp;</td>
 <td><small>for <b>k</b>ernel use; may change unexpectedly</small></td>
</tr>
<tr>
 <td><large><code>$28</code></large></td><td>&nbsp;</td><td><large><code>$gp</code></large></td><td>&nbsp;</td>
 <td><small><b>g</b>lobal <b>p</b>ointer</small></td>
</tr>
<tr>
 <td><large><code>$29</code></large></td><td>&nbsp;</td><td><large><code>$sp</code></large></td><td>&nbsp;</td>
 <td><small><b>s</b>tack <b>p</b>ointer</small></td>
</tr>
<tr>
 <td><large><code>$30</code></large></td><td>&nbsp;</td><td><large><code>$fp</code></large></td><td>&nbsp;</td>
 <td><small><b>f</b>rame <b>p</b>ointer</small></td>
</tr>
<tr>
 <td><large><code>$31</code></large></td><td>&nbsp;</td><td><large><code>$ra</code></large></td><td>&nbsp;</td>
 <td><small><b>r</b>eturn <b>a</b>ddress</small> of most recent caller</td>
</tr>
</table>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Machine Archtecture</span></td><td align='right'><small>21/114</small></td></tr></table>
<p>
Floating point register usage ...
<p>
<table cellspacing="8">
<tr><td><b>Reg</b></td><td>&nbsp;</td><td><b>Notes</b></td></tr>
<tr valign="top">
<tr valign="top">
 <td><large><code>$f0</code></large>..<large><code>$f2</code></large></td><td>&nbsp;</td>
 <td><small>hold floating-point function results</small></td>
</tr>
<tr valign="top">
 <td><large><code>$f4</code></large>..<large><code>$f10</code></large></td><td>&nbsp;</td>
 <td><small>temporary registers; not preserved across function calls</small></td>
</tr>
<tr valign="top">
 <td><large><code>$f12</code></large>..<large><code>$f14</code></large></td><td>&nbsp;</td>
 <td><small>used for first two double-precision function arguments</small></td>
</tr>
<tr valign="top">
 <td><large><code>$f16</code></large>..<large><code>$f18</code></large></td><td>&nbsp;</td>
 <td><small>temporary registers; used for expression evaluation</small></td>
</tr>
<tr valign="top">
 <td><large><code>$f20</code></large>..<large><code>$f30</code></large></td><td>&nbsp;</td>
 <td><small>saved registers; value is preserved across function calls</small></td>
</tr>
</table>
<p>
Notes:
<ul>
<li> registers come in pairs of 2 &times; 32-bits
<li> only even registers are addressed for double-precision
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Assembly Language</span></td><td align='right'><small>22/114</small></td></tr></table>
<p>
MIPS assembly language programs contain
<ul>
<li> comments ... introduced by <large><code>#</code></large>
<li> labels ... appended with <large><code>:</code></large>
<li> directives ... symbol beginning with <large><code>.</code></large>
<li> assembly language instructions
</ul>
Programmers need to specify
<ul>
<li> data objects that live in the data region
<li> functions <small>(instruction sequences)</small> that live in the code/text region
</ul>
Each instruction or directive appears on its own line
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Assembly Language</span></td><td align='right'><small>23/114</small></td></tr></table>
<p>
Example MIPS assembler program:
<p><pre>
<comment># hello.s ... print "Hello, MIPS"</comment>

       <font color='#009900'>.data</font>          <comment># the data segment</comment>
<font color='#CC0000'>msg:</font>   <font color='#009900'>.asciiz</font> "Hello, MIPS\n"

       <font color='#009900'>.text</font>          <comment># the code segment</comment>
       <font color='#009900'>.globl</font> main
<font color='#CC0000'>main:</font>  
        la $a0, msg   <comment># load the argument string</comment>
        li $v0, 4     <comment># load the system call (print)</comment>
        syscall       <comment># print the string</comment>
        jr $ra        <comment># return to caller (__start)</comment>
</pre><p>
<br>
Color coding: <font color='#CC0000'>label</font>, <font color='#009900'>directive</font>, <font color='#999999'>comment</font>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Assembly Language</span></td><td align='right'><small>24/114</small></td></tr></table>
<p>
Generic structure of MIPS programs
<p><pre>
<comment># Prog.s ... comment giving description of function</comment>
<comment># Author ...</comment>

     .data     <comment># variable declarations follow this line</comment>
               <comment># ...</comment>

     .text     <comment># instructions follow this line   </comment>
     .globl main
main:          <comment># indicates start of code</comment>
               <comment># (i.e. first user instruction to execute)</comment>
               <comment># ...</comment>

<comment># End of program; leave a blank line to make SPIM happy</comment>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Assembly Language</span></td><td align='right'><small>25/114</small></td></tr></table>
<p>
Another example MIPS assembler program:
<p><pre>
    <font color='#009900'>.data</font>
<font color='#CC0000'>a</font>:  <font color='#009900'>.word</font> 42            <comment># int a = 42;</comment>
<font color='#CC0000'>b</font>:  <font color='#009900'>.space</font> 4            <comment># int b;</comment>
    <font color='#009900'>.text</font>
    <font color='#009900'>.globl</font> main
<font color='#CC0000'>main</font>:
    lw   $t0, a         <comment># reg[t0] = a</comment>
    li   $t1, 8         <comment># reg[t1] = 8</comment>
    add  $t0, $t0, $t1  <comment># reg[t0] = reg[t0]+reg[t1]</comment>
    li   $t2, 666       <comment># reg[t2] = 666</comment>
    mult $t0, $t2       <comment># (Lo,Hi) = reg[t0]*reg[t2]</comment>
    mflo $t0            <comment># reg[t0] = Lo</comment>
    sw   $t0, b         <comment># b = reg[t0]</comment>
    ....
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Assembly Language</span></td><td align='right'><small>26/114</small></td></tr></table>
<p>
MIPS programs assume the following memory layout
<p>
<table cellpadding="8">
<tr><td><b>Region</b></td><td>&nbsp;</td><td><b>Address</b></b></td><td>&nbsp;</td><td><b>Notes</b></td></tr>
<tr valign="top">
 <td>text</td><td>&nbsp;</td><td><large><code>0x00400000</code></large></td><td>&nbsp;</td>
 <td><small>contains only instructions; read-only; cannot expand</small></td>
</tr>
<tr valign="top">
 <td>data</td><td>&nbsp;</td><td><large><code>0x10000000</code></large></td><td>&nbsp;</td>
 <td><small>data objects; readable/writeable; can be expanded</small></td>
</tr>
<tr valign="top">
 <td>stack</td><td>&nbsp;</td><td><large><code>0x7fffefff</code></large></td><td>&nbsp;</td>
 <td><small>grows down from that address; readable/writeable</small></td>
</tr>
<tr valign="top">
 <td>k_text</td><td>&nbsp;</td><td><large><code>0x80000000</code></large></td><td>&nbsp;</td>
 <td><small>kernel code; read-only; only accessible kernel mode</small></td>
</tr>
<tr valign="top">
 <td>k_data</td><td>&nbsp;</td><td><large><code>0x90000000</code></large></td><td>&nbsp;</td>
 <td><small>kernel data; read/write; only accessible kernel mode</small></td>
</tr>
</table>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Instructions</span></td><td align='right'><small>27/114</small></td></tr></table>
<p>
MIPS has several classes of instructions:
<ul>
<li> <em>load and store</em> .. transfer data between registers and memory
<li> <em>computational</em> ... perform arithmetic/logical operations
<li> <em>jump and branch</em> ... transfer control of program execution
<li> <em>coprocessor</em> ... standard interface to various co-processors
<li> <em>special</em> ... miscellaneous tasks (e.g. syscall)
</ul>
And several addressing modes for each instruction
<ul>
<li> between memory and register <small>(direct, indirect)</small>
<li> constant to register (immediate)
<li> register + register + destination register
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instructions</span></td><td align='right'><small>28/114</small></td></tr></table>
<p>
MIPS instructions are 32-bits long, and specify ...
<ul>
<li> an operation (e.g. load, store, add, branch, ...)
<li> one or more operands (e.g. registers, memory addresses, constants)
</ul>
Some possible instruction formats
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-instr-small.png]" src="Pics/processor/mips-instr-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Addressing Modes</span></td><td align='right'><small>29/114</small></td></tr></table>
<p>
Memory addresses can be given by
<ul>
<li> symbolic name (label) <small>(effectively, a constant)</small>
<li> indirectly via a register <small>(effectively, pointer dereferencing)</small>
</ul>
Examples:
<p><pre>
prog:
a:    lw    $t0, var     <comment># address via name</comment>
b:    lw    $t0, ($s0)   <comment># indirect addressing</comment>
c:    lw    $t0, 4($s0)  <comment># indexed addressing</comment>
</pre><p>
If <large><code>$s0</code></large> contains <large><code>0x10000000</code></large> and <large><code>&var</code></large> = <large><code>0x100000008</code></large>
<ul>
<li> computed address for <large><code>a:</code></large> is <large><code>0x100000008</code></large>
<li> computed address for <large><code>b:</code></large> is <large><code>0x100000000</code></large>
<li> computed address for <large><code>c:</code></large> is <large><code>0x100000004</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Addressing Modes</span></td><td align='right'><small>30/114</small></td></tr></table>
<p>
Addressing modes in MIPS
<p>
<table cellpadding="8">
<tr><td><b>Format</b></td><td>&nbsp;&nbsp;</td><td><b>Address computation</b></td></tr>
<tr>
 <td>(register)</td><td>&nbsp;&nbsp;</td>
 <td>address = *register = contents of register</td>
</tr>
<tr>
 <td>k</td><td>&nbsp;&nbsp;</td>
 <td>address = k</td>
</tr>
<tr>
 <td>k(register)</td><td>&nbsp;&nbsp;</td>
 <td>address = k + *register</td>
</tr>
<tr>
 <td>symbol</td><td>&nbsp;&nbsp;</td>
 <td>address = &amp;symbol = address of symbol</td>
</tr>
<tr>
 <td>symbol &pm; k</td><td>&nbsp;&nbsp;</td>
 <td>address = &amp;symbol &pm; k</td>
</tr>
<tr>
 <td>symbol &pm; k(register)</td><td>&nbsp;&nbsp;</td>
 <td>address = &amp;symbol &pm; (k + *register)</td>
</tr>
</table>
<p>
where <i>k</i> is a literal constant value (e.g. <large><code>4</code></large> or <large><code>0x10000000</code></large>)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Addressing Modes</span></td><td align='right'><small>31/114</small></td></tr></table>
<p>
Examples of load/store and addressing:
<p><pre><small>
    .data
vec: .space   16      <comment># int vec[4], 16 bytes of storage</comment>
    .text
__start:   
    la  $t0, vec      <comment># reg[t0] = &vec</comment>
    li  $t1, 5        <comment># reg[t1] = 5</comment>
    sw  $t1, ($t0)    <comment># vec[0] = reg[t1]</comment>
    li  $t1, 13       <comment># reg[t1] = 13</comment>
    sw  $t1, 4($t0)   <comment># vec[1] = reg[t1]</comment>
    li  $t1, -7       <comment># reg[t1] = -7</comment>
    sw  $t1, 8($t0)   <comment># vec[2] = reg[t1]</comment>
    li  $t2, 12       <comment># reg[t2] = 12</comment>
    li  $t1, 42       <comment># reg[t1] = 42</comment>
    sw  $t1, vec($t2) <comment># vec[3] = reg[t1]</comment>
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Operand Sizes</span></td><td align='right'><small>32/114</small></td></tr></table>
<p>
MIPS instructions can manipulate different-sized operands
<ul>
<li> single bytes, &nbsp; two bytes ("halfword"), &nbsp; four bytes ("word")
</ul>
Many instructions also have variants for signed and unsigned
<p>
Leads to many opcodes for a (conceptually) single operation, e.g.
<ul>
<li> <large><code>LB</code></large> ... load one byte from specified address
<li> <large><code>LBU</code></large> ... load unsigned byte from specified address
<li> <large><code>LH</code></large> ... load two bytes from specified address
<li> <large><code>LHU</code></large> ... load unsigned 2-bytes from specified address
<li> <large><code>LW</code></large> ... load four bytes (one word) from specified address
<li> <large><code>LA</code></large> ... load the specified address
</ul>
All of the above specify a destination register
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Instruction Set</span></td><td align='right'><small>33/114</small></td></tr></table>
<p>
The MIPS processor implements a base set of instructions, e.g.
<ul>
<li> <large><code>lw</code></large>, <large><code>sw</code></large>, <large><code>add</code></large>, <large><code>sub</code></large>, <large><code>and</code></large>, <large><code>or</code></large>, <large><code>sll</code></large>, <large><code>slt</code></large>, <large><code>beq</code></large>, <large><code>j</code></large>, <large><code>jal</code></large>, ...
</ul>
Augmented by a set of pseudo-instructions, e.g.
<ul>
<li> <large><code>move</code></large>, <large><code>rem</code></large>, <large><code>la</code></large>, <large><code>li</code></large>, <large><code>blt</code></large>, ...
</ul>
Each pseudo-instruction maps to one or more base instructions, e.g.
<p><pre>
Pseudo-instruction       Base instruction(s)

<font color='#009900'>li</font>   $t5, const          ori  $t5, $0, const

<font color='#009900'>la</font>   $t3, label          lui  $at, &label[31..16]
                         ori  $t3, $at, &label[15..0]

<font color='#009900'>bge</font>  $t1, $t2, label     slt  $at, $t1, $t2
                         beq  $at, $0, label

<font color='#009900'>blt</font>  $t1, $t2, label     slt  $at, $t1, $t2
                         bne  $at, $0, label
</small></pre><p>
Note: use of <large><code>$at</code></large> register for intermediate results
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>34/114</small></td></tr></table>
<p>
In describing instructions:
<p>
<table border="0" cellpadding="6">
<tr><td><b>Syntax</b></td><td><b>Semantics</b></td></tr>
<tr>
 <td><tt>$Reg</td</td>
 <td><small>as source, the content of the register, <tt>reg[Reg]</tt></small></tr>
</tr>
<tr>
 <td><tt>$Reg</td</td>
 <td><small>as destination, value is stored in register, <tt>reg[Reg] = value</tt></small></tr>
</tr>
<tr>
 <td><tt>Label</tt></td>
 <td><small>references the associated address (in C terms, <tt>&Label</tt>)</small></td>
</tr>
<tr>
 <td><tt>Addr</tt></td>
 <td><small>any expression that yields an address (e.g. <tt>Label($Reg)</tt>)</small></td>
</tr>
<tr>
 <td><tt>Addr</tt></td>
 <td><small>as source, the content of memory cell &nbsp;<tt>memory[Addr]</tt></small></tr>
</tr>
<tr>
 <td><tt>Addr</tt></td>
 <td><small>as destination, value is stored in &nbsp;<tt>memory[Addr] = value</tt></small></tr>
</tr>
</table>
<p>
Effectively ...
<ul>
<li> treat registers as &nbsp;<tt>unsigned int reg[32]</tt>&nbsp;
<li> treat memory as &nbsp;<tt>unsigned char mem[2<sup>32</sup>]</tt>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>35/114</small></td></tr></table>
<p>
Examples of data movement instructions:
<p><pre><small>
<font color='#009900'>la</font>   $t1,label    <comment># reg[t1] = &label</comment>
lw   $t1,label    <comment># reg[t1] = memory[&label]</comment>
sw   $t3,label    <comment># memory[&label] = reg[t3]</comment>
                  <comment># &label must be 4-byte aligned</comment>
lb   $t2,label    <comment># reg[t2] = memory[&label]</comment>
sb   $t4,label    <comment># memory[&label] = reg[t4]</comment>
<font color='#009900'>move</font> $t2,$t3      <comment># reg[t2] = reg[t3]</comment>
lui  $t2,const    <comment># reg[t2][31:16] = const</comment>
</small></pre><p>
Examples of bit manipulation instructions:
<p><pre><small>
and  $t0,$t1,$t2  <comment># reg[t0] = reg[t1] & reg[t2]</comment>
and  $t0,$t1,Imm  <comment># reg[t0] = reg[t1] & Imm[t2]</comment>
                  <comment># Imm is a constant (immediate)</comment>
or   $t0,$t1,$t2  <comment># reg[t0] = reg[t1] | reg[t2]</comment>
xor  $t0,$t1,$t2  <comment># reg[t0] = reg[t1] ^ reg[t2]</comment>
<font color='#009900'>neg</font>  $t0,$t1      <comment># reg[t0] = ~ reg[t1]</comment>
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>36/114</small></td></tr></table>
<p>
Examples of arithmetic instructions:
<p><pre><small>
add  $t0,$t1,$t2  <comment># reg[t0] = reg[t1] + reg[t2]</comment>
                  <comment>#   add as signed (2's complement) ints</comment>
sub  $t2,$t3,$t4  <comment># reg[t2] = reg[t3] + reg[t4]</comment>
addi $t2,$t3, 5   <comment># reg[t2] = reg[t3] + 5</comment>
                  <comment>#   "add immediate" (no sub immediate)</comment>
addu $t1,$t6,$t7  <comment># reg[t1] = reg[t6] + reg[t7]</comment>
                  <comment>#   add as unsigned integers</comment>
subu $t1,$t6,$t7  <comment># reg[t1] = reg[t6] + reg[t7]</comment>
                  <comment>#   subtract as unsigned integers</comment>
mult $t3,$t4      <comment># (Hi,Lo) = reg[t3] * reg[t4]</comment>
                  <comment>#   store 64-bit result in registers Hi,Lo</comment>
div  $t5,$t6      <comment># Lo = reg[t5] / reg[t6] (integer quotient)</comment>
                  <comment># Hi = reg[t5] % reg[t6] (remainder)</comment>
mfhi $t0          <comment># reg[t0] = reg[Hi]</comment>
mflo $t1          <comment># reg[t1] = reg[Lo]</comment>
                  <comment># used to get result of MULT or DIV</comment>
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>37/114</small></td></tr></table>
<p>
Examples of testing and branching instructions:
<p><pre><small>
seq  $t7,$t1,$t2   <comment># reg[t7] = 1 if (reg[t1]==reg[t2])</comment>
                   <comment># reg[t7] = 0 otherwise <small>(signed)</small></comment>
slt  $t7,$t1,$t2   <comment># reg[t7] = 1 if (reg[t1] &lt; reg[t2])</comment>
                   <comment># reg[t7] = 0 otherwise <small>(signed)</small></comment>
slti $t7,$t1,Imm   <comment># reg[t7] = 1 if (reg[t1] &lt; Imm)</comment>
                   <comment># reg[t7] = 0 otherwise <small>(signed)</small></comment>

j    label         <comment># PC = &label</comment>
jr   $t4           <comment># PC = reg[t4]</comment>
beq  $t1,$t2,label <comment># PC = &label if (reg[t1] == reg[t2])</comment>
bne  $t1,$t2,label <comment># PC = &label if (reg[t1] != reg[t2])</comment>
<font color='#009900'>bgt</font>  $t1,$t2,label <comment># PC = &label if (reg[t1] > reg[t2])</comment>
bltz $t2,label     <comment># PC = &label if (reg[t2] &lt; 0)</comment>
bnez $t3,label     <comment># PC = &label if (reg[t3] != 0)</comment>
</small></pre><p>
After each branch instruction, execution continues at new PC location
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>38/114</small></td></tr></table>
<p>
Special jump instruction for invoking functions
<p><pre><small>
jal  label         <comment># make a subroutine call</comment>
                   <comment># save PC in $ra, set PC to &label</comment>
                   <comment># use $a0,$a1 as params, $v0 as return</comment>
</small></pre><p>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/fn-call-small.png]" src="Pics/processor/fn-call-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>39/114</small></td></tr></table>
<p>
SPIM interacts with stdin/stdout via <large><code>syscall</code></large>s
<p>
<table border="1" cellpadding="8" cellspacing="0">
<thead>
<tr><td><b>Service</b></td><td><b>Code</b></td><td><b>Arguments</b></td><td><b>Result</b></td></tr>
</thead>
<tbody>
<tr>
 <td>print_int</td><td>1</td><td><tt>$a0</tt> = integer</td><td>&nbsp;</td>
</tr>
<tr>
 <td>print_float</td><td>2</td><td><tt>$f12</tt> = float</td><td>&nbsp;</td>
</tr>
<tr>
 <td>print_double</td><td>3</td><td><tt>$f12</tt> = double</td><td>&nbsp;</td>
</tr>
<tr>
 <td>print_string</td><td>4</td><td><tt>$a0</tt> = char *</td><td>&nbsp;</td>
</tr>
<tr>
 <td>read_int</td><td>5</td><td>&nbsp;</td><td>integer in <tt>$v0</tt></td>
</tr>
<tr>
 <td>read_float</td><td>6</td><td>&nbsp;</td><td>float in <tt>$f0</tt></td>
</tr>
<tr>
 <td>read_double</td><td>7</td><td>&nbsp;</td><td>double in <tt>$f0</tt></td>
</tr>
<tr valign="top">
 <td>read_string</td><td>8</td><td><tt>$a0</tt> = buffer, <tt>$a1</tt> = length</td><td>string in buffer <br><small>(including "\n\0")</small></td>
</tr>
</tbody>
</table>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Instruction Set</span></td><td align='right'><small>40/114</small></td></tr></table>
<p>
Directives <small>(instructions to assembler, not MIPS instructions)</small>
<p><pre><small>
    .text        <comment># following instructions placed in text</comment>
    .data        <comment># following objects placed in data</comment>

    .globl       <comment># make symbol available globally</comment>

a:  .space 18    <comment># uchar a[18];  or  uint a[4];</comment>
    .align 2     <comment># align next object on 2<sup>2</sup>-byte addr</comment>

i:  .word 2      <comment># unsigned int i = 2;</comment>
v:  .word 1,3,5  <comment># unsigned int v[3] = {1,3,5};</comment>
h:  .half 2,4,6  <comment># unsigned short h[3] = {2,4,6};</comment>
b:  .byte 1,2,3  <comment># unsigned char b[3] = {1,2,3};</comment>
f:  .float 3.14  <comment># float f = 3.14;</comment>

s:  .asciiz "abc"
                 <comment># char s[4] {'a','b','c','\0'};</comment>
t:  .ascii "abc"
                 <comment># char s[3] {'a','b','c'};</comment>
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>MIPS Programming</span></td><td align='right'><small>41/114</small></td></tr></table>
<p>
Writing directly in MIPS assembler is difficult (impossible?)
<p>
Strategy for producing likely correct MIPS code
<ul>
<li> develop the solution in C
<li> map to "simplified" C
<li> translate each simplified C statement to MIPS instructions
</ul>
Simplified C
<ul>
<li> does <em>not</em> have <large><code>while</code></large>, <large><code>switch</code></large>, complex expressions
<li> <em>does</em> have simple <large><code>if</code></large>, <large><code>goto</code></large>, one-operator expressions
<li> does <em>not</em> have function calls and auto local variables
<li> <em>does</em> have jump-and-remember-where-you-came-from
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Programming</span></td><td align='right'><small>42/114</small></td></tr></table>
<p>
Example translating C to MIPS:
<p><pre>
C             Simplified C   MIPS Assembler
------------  ------------   --------------
int x = 5;    int x = 5;     x:  .word 5
int y = 3;    int y = 3;     y:  .word 3
int z;        int z;         z:  .space 4
              int t;         <span class="comment">...</span>
                             lw  $t0, x
                             lw  $t1, y
z = 5*(x+y);   t = x+y;      add $t0, $t0, $t1
                             li  $t1, 5
               t = 5*t;      mul $t0, $t0, $t1
               z = t;        sw  $t0, z
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Programming</span></td><td align='right'><small>43/114</small></td></tr></table>
<p>
Simplified C makes extensive use of
<ul>
<li> <font color='#009900'>labels</font> ... symbolic name for C statement
<li> <font color='#CC0000'>goto</font> ... transfer control to labelled statement
</ul>
Example:
<p><pre>
Standard C            Simplified C
------------------    ------------------
i = 0; n = 0;         i = 0; n = 0; 
while (i < 5) {       <font color='#009900'>loop:</font>
   n = n + i;           if (i >= 5) <font color='#CC0000'>goto</font> <font color='#009900'>end</font>;
   i++;                 n = n + i;
}                       i++;
                        <font color='#CC0000'>goto</font> <font color='#009900'>loop</font>;
                      <font color='#009900'>end:</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Programming</span></td><td align='right'><small>44/114</small></td></tr></table>
<p>
Beware: registers are shared by all parts of the code.
<p>
One function can overwrite value set by another function
<p><pre>
int x;   <comment>// first global variable</comment>
int y;   <comment>// second global variable</comment>

int main(void)          int f(int n)
{                       {
   x = 5;                  y = 1;
   y = f(x);               for (x = 1; x <= n; x++)
   printf("...",x,y);         y = y * x;
   return 0;               return y;
}                       }
</pre><p>
After the function, <large><code>x == 6</code></large> and <large><code>y == 120</code></large>
<p>
It is sheer coincidence that <large><code>y</code></large> has the correct value.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... MIPS Programming</span></td><td align='right'><small>45/114</small></td></tr></table>
<p>
Need to be careful managing registers
<ul>
<li> follow the conventions implied by register names
<li> preserve values that need to be saved across function calls
</ul>
Within a function
<ul>
<li> you manage register usage as you like
<li> typically making use of <large><code>$t?</code></large> registers
</ul>
When making a function call
<ul>
<li> you transfer control to a separate piece of code
<li> which may change the value of any non-preserved register
<li> <large><code>$s?</code></large> registers must be preserved by function
<li> <large><code>$a?</code></large>, <large><code>$v?</code></large>, <large><code>$t?</code></large> registers may be modified by function
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Rendering C in MIPS</span></td><td align='right'><small>46/114</small></td></tr></table>
<p>
C provides expression evaluation and assignment, e.g.
<ul>
<li> <large><code>x = (1 + y*y) / 2; &nbsp; z = 1.0 / 2;</code></large> ...
</ul>
MIPS provides register-register operations, e.g.
<ul>
<li> <large><code>move R<sub>d</sub>,R<sub>s</sub></code></large>, &nbsp; <large><code>li R<sub>d</sub>,Const</code></large>, &nbsp; <large><code>add</code></large>, <large><code>div</code></large>, <large><code>and</code></large>, ...
</ul>
C provides a range of control structures
<ul>
<li> sequence (<large><code>;</code></large>), <large><code>if</code></large>, <large><code>while</code></large>, <large><code>for</code></large>, <large><code>break</code></large>, <large><code>continue</code></large>, ...
</ul>
MIPS provides testing/branching instructions
<ul>
<li> <large><code>seq</code></large>, <large><code>slti</code></large>, <large><code>sltu</code></large>, ..., <large><code>beq</code></large>, <large><code>bgtz</code></large>, <large><code>bgezal</code></large>, ..., <large><code>j</code></large>, <large><code>jr</code></large>, <large><code>jal</code></large>, ...
</ul>
We need to render C's structures in terms of testing/branching
<p>
Sequence is easy &nbsp; <large><code>S<sub>1</sub> ; S<sub>2</sub></code></large> &nbsp; &rarr; &nbsp; <large><code>mips(S<sub>1</sub>) mips(S<sub>2</sub>)</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Rendering C in MIPS</span></td><td align='right'><small>47/114</small></td></tr></table>
<p>
Simple example of assignment and sequence:
<p><pre>
int x;        x: .space 4
int y;        y: .space 4

x = 2;           li   $t0, 2
                 sw   $t0, x

y = x;           lw   $t0, x
                 sw   $t0, y

y = x+3;         lw   $t0, x
                 addi $t0, 3
                 sw   $t0, y
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Arithmetic Expressions</span></td><td align='right'><small>48/114</small></td></tr></table>
<p>
Expression evaluation involves
<ul>
<li> describing the process as a sequence of binary operations
<li> managing data flow between the operations
</ul>
Example:
<p><pre>
# x = (1 + y*y) / 2
<span class="comment"># assume x and y exist as labels in .data</span>
  lw   $t0, y          <span class="comment"># t0 = y</span>
  mul  $t0, $t0, $t0   <span class="comment"># t0 = t0*t0</span>
  addi $t0, $t0, 1     <span class="comment"># t0 = t0+1</span>
  li   $t1, 2          <span class="comment"># t1 = 2</span>
  div  $t0, $t1        <span class="comment"># Lo = t0/t1 (int div)</span>
  mflo $t0             <span class="comment"># t0 = Lo</span>
  sw   $t0, x          <span class="comment"># x = t0</span>
</pre><p>
<small>
It is useful to minimise the number of registers involved in the evaluation
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Conditional Statements</span></td><td align='right'><small>49/114</small></td></tr></table>
<p>
Conditional statements (e.g. <large><code>if</code></large>)
<p><pre>
Standard C                Simplified C
------------------------  ------------------------
                          <font color='#009900'>if_stat:</font>
if (<i>Cond</i>)                   t0 = (<i>Cond</i>)
   { <i>Statements<sub>1</sub></i> }          if (t0 == 0)
else                           goto else_part;
   { <i>Statements<sub>2</sub></i> }          <i>Statements<sub>1</sub></i>
                            goto end_if;
                         <font color='#009900'>else_part:</font>
                            <i>Statements<sub>2</sub></i>
                         <font color='#009900'>end_if:</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>50/114</small></td></tr></table>
<p>
Conditional statements (e.g. <large><code>if</code></large>)
<p><pre>
                         <font color='#009900'>if_stat:</font>
if (<i>Cond</i>)                  t0 = evaluate (<i>Cond</i>)
   { <i>Statements<sub>1</sub></i> }         <b>beqz</b> $t0, <font color='#009900'>else_part</font>
else                       execute <i>Statements<sub>1</sub></i>
   { <i>Statements<sub>2</sub></i> }         <b>j</b>    <font color='#009900'>end_if</font>
                         <font color='#009900'>else_part:</font>
                           execute <i>Statements<sub>2</sub></i>
                         <font color='#009900'>end_if:</font>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>51/114</small></td></tr></table>
<p>
Example of if-then-else:
<p><pre><small>
int x;           x is $t0
int y;           y is $t1
char z;          z is $a0

x = getInt();    li   $v0, 5
                 syscall
                 move $t0, $v0

y = getInt();    li   $v0, 5
                 syscall
                 move $t1, $v0

if (x == y)      bne  $t0, $t1, printN
   z = 'Y';    setY:
                 li   $a0, 'Y'
                 j    print
else           setN:
   z = 'N';      li   $a0, 'N'
                 j    print    <comment># redundant</comment>
               print:
putChar(z);      li   $v0, 11
                 syscall
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>52/114</small></td></tr></table>
<p>
Could make <large><code>switch</code></large> by first converting to <large><code>if</code></large>
<p><pre>
switch (Expr) {              tmp = Expr;
case Val<sub>1</sub>:                   if (tmp == Val<sub>1</sub>)
   Statements<sub>1</sub> ; break;         { Statements<sub>1</sub>; }
case Val<sub>2</sub>:                   else if (tmp == Val<sub>2</sub>
case Val<sub>3</sub>:                            || tmp == Val<sub>3</sub>
case Val<sub>4</sub>:                            || tmp == Val<sub>4</sub>)
   Statements<sub>2</sub> ; break;         { Statements<sub>2</sub>; }
case Val<sub>5</sub>:                   else if (tmp == Val<sub>5</sub>)
   Statements<sub>3</sub> ; break;         { Statements<sub>3</sub>; }
default:                     else
   Statements<sub>4</sub> ; break;         { Statements<sub>4</sub>; }
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Conditional Statements</span></td><td align='right'><small>53/114</small></td></tr></table>
<p>
Jump table: an alternative implementation of <large><code>switch</code></large>
<ul>
<li> works best for small, dense range of case values (e.g. 1..10)
</ul>
<p><pre><small>
                             jump_tab:
                                .word c1, c2, c2, c2, c3
                             switch:
                                 t0 = evaluate Expr
switch (Expr) {                  if (t0 < 1 || t0 > 5)
case 1:                             jump to default
   Statements<sub>1</sub> ; break;          dest = jump_tab[(t0-1)*4]
case 2:                          jump to dest
case 3:                      c1: execute Statements<sub>1</sub> 
case 4:                          jump to end_switch
   Statements<sub>2</sub> ; break;      c2: execute Statements<sub>2</sub>
case 5:                          jump to end_switch
   Statements<sub>3</sub> ; break;      c3: execute Statements<sub>3</sub>
default:                         jump to end_switch
   Statements<sub>4</sub> ; break;      default:
}                                execute Statements<sub>4</sub>
                             end_switch:
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Boolean Expressions</span></td><td align='right'><small>54/114</small></td></tr></table>
<p>
Boolean expressions in C are short circuit
<p>
<p><pre>
(Cond<sub>1</sub> && Cond<sub>2</sub> && ... && Cond<sub>n</sub>)
</pre><p>
Evaluates by 
<ul>
<li> evaluate <large><code>Cond<sub>1</sub></code></large>; if 0 then return 0 for whole expression
<li> evaluate <large><code>Cond<sub>2</sub></code></large>; if 0 then return 0 for whole expression
<li> ...
<li> evaluate <large><code>Cond<sub>n</sub></code></large>; if 0 then return 0 for whole expression
<li> otherwise, return 1
</ul>
In C, any non-zero value is treated as true; MIPS tends to use 1 for true
<p>
C99 standard defines return value for booleans expressions as 0 or 1
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Boolean Expressions</span></td><td align='right'><small>55/114</small></td></tr></table>
<p>
Similarly for disjunctions
<p>
<p><pre>
(Cond<sub>1</sub> || Cond<sub>2</sub> || ... || Cond<sub>n</sub>)
</pre><p>
Evaluates by
<ul>
<li> evaluate <large><code>Cond<sub>1</sub></code></large>; if !0 then return 1 for whole expression
<li> evaluate <large><code>Cond<sub>2</sub></code></large>; if !0 then return 1 for whole expression
<li> ...
<li> evaluate <large><code>Cond<sub>n</sub></code></large>; if !0 then return 1 for whole expression
<li> otherwise, return 1
</ul>
In C, any non-zero value is treated as true; MIPS tends to use 1 for true
<p>
C99 standard defines return value for booleans expressions as 0 or 1
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Iteration Statements</span></td><td align='right'><small>56/114</small></td></tr></table>
<p>
Iteration (e.g. <large><code>while</code></large>)
<p><pre>
                      <font color='#009900'>top_while:</font>
while (Cond) {           t0 = evaluate Cond
   Statements;           <b>beqz</b> $t0,<font color='#009900'>end_while</font>
}                        execute Statements
                         <b>j</b>    <font color='#009900'>top_while</font>
                      <font color='#009900'>end_while:</font>
</pre><p>
Treat <large><code>for</code></large> as a special case of <large><code>while</code></large>
<p><pre>
                                i = 0
for (i = 0; i < N; i++) {       while (i < N) {
    Statements;                    Statements;
}                                  i++;
                                }
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Iteration Statements</span></td><td align='right'><small>57/114</small></td></tr></table>
<p>
Example of iteration over an array:
<p><pre><small>
int sum, i;               sum: .word 4       <span class="comment"># use reg for i</span>
int a[5] = {1,3,5,7,9};   a:   .word 1,3,5,7,9
...                            ...
sum = 0;                       li   $t0, 0   <span class="comment"># i = 0</span>
                               li   $t1, 0   <span class="comment"># sum = 0</span>
                               li   $t2, 4   <span class="comment"># max index</span>
for (i = 0; i < N; i++)   for: bgt  $t0, $t2, end_for
                               move $t3, $t0
                               mul  $t3, $t3, 4
   sum += a[i];                add  $t1, $t1, a($t3)
printf("%d",sum);              addi $t0, $t0, 1   <span class="comment"># i++</span>
                               j    for
                      end_for: sw   $t1, sum
                               move $a0, $t1 
                               li   $v0, 1
                               syscall       <span class="comment"># printf</span>
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Functions</span></td><td align='right'><small>58/114</small></td></tr></table>
<p>
When we call a function:
<ul>
<li> the arguments are evaluated and set up for function
<li> control is transferred to the code for the function
<li> local variables are created
<li> the function code is executed in this environment
<li> the return value is set up
<li> control transfers back to where the function was called from
<li> the caller receives the return value
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>59/114</small></td></tr></table>
<p>
Data associated with function calls is placed on the MIPS stack.
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-memory-small.png]" src="Pics/processor/mips-memory-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>60/114</small></td></tr></table>
<p>
Each function allocates a small section of the stack (a <em>frame</em>)
<ul>
<li> used for: saved registers, local variables, parameters to callees
<li> created in the function <i>prologue</i> &nbsp; <small>(pushed)</small>
<li> removed in the function <i>epilogue</i> &nbsp; <small>(popped)</small>
</ul>
<br>
Why we use a stack:
<ul>
<li> function <large><code>f()</code></large> calls <large><code>g()</code></large> which calls <large><code>h()</code></large>
<li> <large><code>h()</code></large> runs, then finishes and returns to <large><code>g()</code></large>
<li> <large><code>g()</code></large> continues, then finishes and returns to <large><code>f()</code></large>
</ul>
i.e. last-called, exits-first (last-in, first-out) behaviour
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>61/114</small></td></tr></table>
<p>
How stack changes as functions are called and return:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-calls-small.png]" src="Pics/processor/mips-fn-calls-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>62/114</small></td></tr></table>
<p>
Register usage conventions when <large><code>f()</code></large> calls <large><code>g()</code></large>:
<ul>
<li> caller saved registers (saved by <large><code>f()</code></large>)
<ul>
<li> <large><code>f()</code></large> tells <large><code>g()</code></large> "If there is anything I want to preserve in these registers, I have already saved it before calling you"
<li> <large><code>g()</code></large> tells <large><code>f()</code></large> "Don't assume that these registers will be unchanged when I return to you"
<li> e.g. &nbsp;<large><code>$t0</code></large> .. <large><code>$t9</code></large>, &nbsp; <large><code>$a0</code></large> .. <large><code>$a3</code></large>, &nbsp; <large><code>$ra</code></large>
</ul>
<li> callee saved registers (saved by <large><code>g()</code></large>)
<ul>
<li> <large><code>f()</code></large> tells <large><code>g()</code></large> "I assume the values of these registers will be unchanged when you return"
<li> <large><code>g()</code></large> tells <large><code>f()</code></large> "If I need to use these registers, I will save them first and restore them before returning"
<li> e.g. &nbsp;<large><code>$s0</code></large> .. <large><code>$s7</code></large>, &nbsp; <large><code>$sp</code></large>, &nbsp; <large><code>$fp</code></large>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Functions</span></td><td align='right'><small>63/114</small></td></tr></table>
<p>
Contents of a typical stack frame:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-stack-frame-small.png]" src="Pics/processor/mips-stack-frame-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Aside: MIPS Branch Delay Slots</span></td><td align='right'><small>64/114</small></td></tr></table>
<p>
The real MIPS architecture is "pipelined" to improve efficiency
<ul>
<li> one instruction can start before the previous one finishes
</ul>
For branching instructions (e.g. <large><code>jal</code></large>) ...
<ul>
<li> instruction following branch is executed before branch completes
</ul>
To avoid potential problems use <large><font color="#008800"><b><code>nop</code></b></font></large> immediately after branch
<p>
A problem scenario, and its solution <small>(branch delay slot)</small>:
<p><pre>
# Implementation of <font color='#000099'>print(compute(42))</font>
li   $a0, 42           li   $a0, 42
jal  compute           jal  compute
move $a0, $v0          nop
jal  print             move $a0,$v0
                       jal  print
</pre><p>
Since SPIM is not pipelined, the <large><code>nop</code></large> is not required
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Aside: Why do we need both $fp and $sp?</span></td><td align='right'><small>65/114</small></td></tr></table>
<p>
During execution of a function
<ul>
<li> <large><code>$sp</code></large> can change &nbsp; <small>(e.g. pushing params, adding local vars)</small>
<li> may need to reference local vars on the stack
<li> useful if they can be defined by an offset relative to fixed point
<li> <large><code>$fp</code></large> provides a fixed point during function code execution
</ul>
<br>
<p><pre><small>
int f(int x) {
   int y = 0;                   <comment>// y created in prologue</comment>
   for (int i = 0; i < x; i++)  <comment>// i created in for-loop</comment>
      y += i;                   <comment>//     which changes $sp</comment>
   return y;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Calling Protocol</span></td><td align='right'><small>66/114</small></td></tr></table>
<p>
Before one function calls another, it needs to
<ul>
<li> place 64-bit double args in <large><code>$f12</code></large> and <large><code>$f14</code></large>
<li> place 32-bit arguments in the <large><code>$a0</code></large>..<large><code>$a3</code></large>
<li> if more than 4 args, or args larger than 32-bits ...
<ul>
<li> push value of all such args onto stack
</ul>
<li> save any non-<large><code>$s?</code></large> registers that need to be preserved
<ul>
<li> push value of all such registers onto stack
</ul>
<li> <large><code>jal</code></large> address of function (usually given by a label)
</ul>
Pushing value of e.g. <large><code>$t0</code></large> onto stack means:
<p><pre>
addi $sp, $sp, -4
sw   $t0, ($sp)
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>67/114</small></td></tr></table>
<p>
Example: simple function call
<p><pre>
int main()
{
   <comment>// x is $s0, y is $s1, z is $s2</comment>
   int x = 5; int y = 7; int z;
   ...
   z = sum(x,y,30);
   ...
}

int sum(int a, int b, int c)
{
   return a+b+c;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>68/114</small></td></tr></table>
<p>
Simple function call:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-args0-small.png]" src="Pics/processor/mips-fn-args0-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>69/114</small></td></tr></table>
<p>
Execution of <large><code>sum()</code></large> function:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-body0-small.png]" src="Pics/processor/mips-fn-body0-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>70/114</small></td></tr></table>
<p>
Example: function <large><code>f()</code></large> calls function <large><code>g(a,b,c,d,e,f)</code></large>
<p><pre>
int f(...)
{
   <span class="comment">// variables happen to be stored </span>
   <span class="comment">// in registers $s0, $s1, ..., $s5 </span>
   int a,b,c,d,e,f;
   ...
   a = g(a,b,c,d,e,f);
   ...
}
int g(int u,v,w,x,y,z)
{
   return u+v+w*w*x*y*z;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>71/114</small></td></tr></table>
<p>
Function call in MIPS:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-args-small.png]" src="Pics/processor/mips-fn-args-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Calling Protocol</span></td><td align='right'><small>72/114</small></td></tr></table>
<p>
Execution of <large><code>g()</code></large> function:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-body-small.png]" src="Pics/processor/mips-fn-body-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Structure of Functions</span></td><td align='right'><small>73/114</small></td></tr></table>
<p>
Functions in MIPS have the following general structure:
<p><pre><small>
# start of function
<font color='#009900'>FuncName:</font>
   # <b>function prologue</b>
   #   set up stack frame ($fp, $sp)
   #   save relevant registers (incl. $ra)
   ...
   # <b>function body</b>
   #   perform computation using $a0, etc.
   #   leaving result in <font color='#009900'>$v0</font>
   ...
   # <b>function epilogue</b>
   #   restore saved registers (esp. $ra)
   #   clean up stack frame ($fp, $sp)
   <font color='#009900'>jr  $ra</font>
</small></pre><p>
Aim of prologue: create environment for function to execute in.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Prologue</span></td><td align='right'><small>74/114</small></td></tr></table>
<p>
Before a function starts working, it needs to ...
<ul>
<li> create a stack frame for itself &nbsp;(change <large><code>$fp</code></large> and <large><code>$sp</code></large>)
<li> save the return address (<large><code>$ra</code></large>) in the stack frame
<li> save any <large><code>$s?</code></large> registers that it plans to change
</ul>
We can determine the initial size of the stack frame via
<ul>
<li> 4 bytes for saved <large><code>$fp</code></large> + 4 bytes for saved <large><code>$ra</code></large>
<li> + 4 bytes for each saved <large><code>$s?</code></large>
</ul>
Changing <large><code>$fp</code></large> and <large><code>$sp</code></large> ...
<ul>
<li> new <large><code>$fp</code></large> = old <large><code>$sp</code></large> - 4
<li> new <large><code>$sp</code></large> = old <large><code>$sp</code></large> - size of frame <small>(in bytes)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Prologue</span></td><td align='right'><small>75/114</small></td></tr></table>
<p>
Example of function <large><code>fx()</code></large>, which uses <large><code>$s0</code></large>, <large><code>$s1</code></large>, <large><code>$s2</code></large>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-prologue-small.png]" src="Pics/processor/mips-fn-prologue-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Prologue</span></td><td align='right'><small>76/114</small></td></tr></table>
<p>
Alternatively ... <small>(more explicit <large><code>push</code></large>)</small>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-prologue2-small.png]" src="Pics/processor/mips-fn-prologue2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Prologue</span></td><td align='right'><small>77/114</small></td></tr></table>
<p>
Alternatively ... <small>(relative to new <large><code>$fp</code></large>)</small>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-prologue3-small.png]" src="Pics/processor/mips-fn-prologue3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Function Epilogue</span></td><td align='right'><small>78/114</small></td></tr></table>
<p>
Before a function returns, it needs to ...
<ul>
<li> place the return value in <large><code>$v0</code></large> &nbsp;<small>(and maybe <large><code>$v1</code></large>)</small>
<li> pop any pushed arguments off the stack
<li> restore the values of any saved <large><code>$s?</code></large> registers
<li> restore the saved value of <large><code>$ra</code></large> &nbsp; <small>(return address)</small>
<li> remove its stack frame &nbsp;(change <large><code>$fp</code></large> and <large><code>$sp</code></large>)
<li> return to the calling function &nbsp; (<large><code>jr $ra</code></large>)
</ul>
Locations of saved values computed relative to <large><code>$fp</code></large>
<p>
Changing <large><code>$fp</code></large> and <large><code>$sp</code></large> ...
<ul>
<li> new <large><code>$sp</code></large> = old <large><code>$fp</code></large> + 4
<li> new <large><code>$fp</code></large> = <large><code>memory[</code></large>old <large><code>$fp]</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Function Epilogue</span></td><td align='right'><small>79/114</small></td></tr></table>
<p>
Example of function <large><code>fx()</code></large>, which uses <large><code>$s0</code></large>, <large><code>$s1</code></large>, <large><code>$s2</code></large>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/mips-fn-epilogue-small.png]" src="Pics/processor/mips-fn-epilogue-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Data Structures and MIPS</span></td><td align='right'><small>80/114</small></td></tr></table>
<p>
C data structures and their MIPS representations:
<ul>
<li> <large><code>char</code></large> ... as byte in memory, or low-order byte in register
<li> <large><code>int</code></large> ... as word in memory, or whole register
<li> <large><code>double</code></large> ... as two-words in memory, or <large><code>$f?</code></large> register
<li> arrays ... sequence of memory bytes/words, accessed by index
<li> structs ... chunk of memory, accessed by fields/offsets
<li> linked structures ... struct containing address of another struct
</ul>
A <large><code>char</code></large>, <large><code>int</code></large> or <large><code>double</code></large>
<ul>
<li> could be implemented in register if used in small scope
<li> could be implemented on stack if local to function
<li> could be implemented in <large><code>.data</code></large> if need longer persistence
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Static vs Dynamic Allocation</span></td><td align='right'><small>81/114</small></td></tr></table>
<p>
Static allocation:
<ul>
<li> uninitialised memory allocated at compile/assemble-time, e.g.
<p><pre>
int  val;              val: .space 4
char str[20];          str: .space 20
int  vec[20];          vec: .space 80
</pre><p>
<li> initialised memory allocated at compile/assemble-time, e.g.
<p><pre>
int val = 5;                 val: .word 5
int arr[4] = {9,8,7,6};      arr: .word 9, 8, 7, 6
char *msg = "Hello\n";       msg: .asciiz "Hello\n"
</pre><p>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>82/114</small></td></tr></table>
<p>
Dynamic allocation (i):
<ul>
<li> variables local to a function
</ul>
Prefer to put local vars in registers, but if cannot ...
<ul>
<li> use space allocated on stack during function prologue
<li> referenced during function relative to <large><code>$fp</code></large>
<li> space reclaimed from stack in function epilogue
</ul>
Example:
<p><pre>
int fx(int a[])
{
   <font color='#009900'>int i, j, max;</font>
   i = 1; j = 2; max = i+j;
   ...
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>83/114</small></td></tr></table>
<p>
Example of local variables on the stack:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/local-vars-small.png]" src="Pics/processor/local-vars-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>84/114</small></td></tr></table>
<p>
Dynamic allocation (ii):
<ul>
<li> uninitialised block of memory allocated at run-time
<p><pre>
int  *ptr = malloc(sizeof(int));
char *str = malloc(20*sizeof(char));
int  *vec = malloc(20*sizeof(int));

*ptr = 5;
strcpy(str, "a string");
vec[0] = 1;  <comment>// or  *vec = 1;</comment>
vec[1] = 6;
</pre><p>
<li> initialised block of memory allocated at run-time
<p><pre>
int *vec = calloc(20, sizeof(int));
<comment>// vec[i] == 0, for i in 0..19</comment>
</pre><p>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>85/114</small></td></tr></table>
<p>
SPIM doesn't provide <large><code>malloc()</code></large>/<large><code>free()</code></large> functions
<ul>
<li> but provides &nbsp;<large><code>syscall</code></large> 9 to extend <large><code>.data</code></large>
<li> before <large><code>syscall</code></large>, set <large><code>$a0</code></large> to the number of bytes requested
<li> after <large><code>syscall</code></large>, <large><code>$v0</code></large> holds start address of allocated chunk
</ul>
Example:
<p><pre>
li   $a0, 20    <comment># $v0 = malloc(20)</comment>
li   $v0, 9
syscall
move $s0, $v0   <comment># $s0 = $v0</comment>
</pre><p>
Cannot access allocated data by name; need to retain address.
<p>
No way to free allocated data, and no way to align data appropriately
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Static vs Dynamic Allocation</span></td><td align='right'><small>86/114</small></td></tr></table>
<p>
Implementing C-like <large><code>malloc()</code></large> and <large><code>free()</code></large> in MIPS requires
<ul>
<li> a complete implementation of C's heap management, i.e.
<li> a large region of memory to manage (<large><code>syscall</code></large> 9)
<li> ability to mark chunks of this region as "in use" (with size)
<li> ability to maintain list of free chunks
<li> ability to merge free chunks to prevent fragmentation
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/processor/heap-small.png]" src="Pics/processor/heap-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>1-d Arrays in MIPS</span></td><td align='right'><small>87/114</small></td></tr></table>
<p>
Can be named/initialised as noted above:
<p><pre>
vec:  .space 40
<comment># could be either int vec[10] or char vec[40]</comment>

nums: .word 1, 3, 5, 7, 9
<comment># int nums[6] = {1,3,5,7,9}</comment>
</pre><p>
Can access elements via index or cursor (pointer)
<ul>
<li> either approach needs to account for size of elements
</ul>
Arrays passed to functions via pointer to first element
<ul>
<li> must also pass array size, since not available elsewhere
</ul>
<small>
See <large><code>sumOf()</code></large> exercise for an example of passing an array to a function
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 1-d Arrays in MIPS</span></td><td align='right'><small>88/114</small></td></tr></table>
<p>
Scanning across an array of <large><code>N</code></large> elements using index
<p><pre>
<font color='#000099'># int vec[10] = {...};
# int i;
# for (i = 0; i < 10; i++)
#    printf("%d\n", vec[i]);</font>

   li   $s0, 0               <comment># i = 0</comment>
   li   $s1, 10              <comment># no of elements</comment>
   li   $s2, 4               <comment># sizeof each element</comment>
loop: 
   bge  $s0, $s1, end_loop   <comment># if (i >= 10) break</comment>
   mul  $t0, $s0, $s2        <comment># index -> byte offset</comment>
   lw   $a0, vec($t0)        <comment># a0 = vec[i]</comment>
   jal  print                <comment># print a0</comment>
   addi $s0, $s0, 1          <comment># i++</comment>
   j    loop
end_loop:
</pre><p>
<small>Assumes the existence of a <large><code>print()</code></large> function to do <large><code>printf("%d\n",x)</code></large></small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 1-d Arrays in MIPS</span></td><td align='right'><small>89/114</small></td></tr></table>
<p>
Scanning across an array of <large><code>N</code></large> elements using cursor
<p><pre>
<font color='#000099'># int vec[10] = {...};
# int *cur, *end = &vec[10];
# for (cur = vec; cur < end; cur++)
#    printf("%d\n", *cur);</font>

   la   $s0, vec             <comment># cur = &vec[0]</comment>
   la   $s1, vec+40          <comment># end = &vec[10]</comment>
loop:
   bge  $s0, $s1, end_loop   <comment># if (cur >= end) break</comment>
   lw   $a0, ($s0)           <comment># a0 = *cur</comment>
   jal  print                <comment># print a0</comment>
   addi $s0, $s0, 4          <comment># cur++</comment>
   j    loop
end_loop:
</pre><p>
<small>Assumes the existence of a <large><code>print()</code></large> function to do <large><code>printf("%d\n",x)</code></large></small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 1-d Arrays in MIPS</span></td><td align='right'><small>90/114</small></td></tr></table>
<p>
Arrays that are local to functions are allocated space on the stack
<p><pre><small>
fun:                         int fun(int x) 
   <comment># prologue</comment>                {
   addi $sp, $sp, -4
   sw   $fp, ($sp)
   move $fp, $sp
   addi $sp, $sp, -4
   sw   $ra, ($sp)              // push a[] onto stack
   addi $sp, $sp, -40           int a[10];
   move $s0, $sp                int *s0 = a;
   <comment># function body</comment>
   ... compute ...              // compute using s0
   <comment># epilogue</comment>                   // to access a[]
   addi $sp, $sp, 40            // pop a[] off stack
   lw   $ra, ($sp)
   addi $sp, $sp, 4
   lw   $fp, ($sp)
   addi $sp, $sp, 4
   jr   $ra                  }
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>2-d Arrays in MIPS</span></td><td align='right'><small>91/114</small></td></tr></table>
<p>
2-d arrays could be represented two ways:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/2d-array-small.png]" src="Pics/processor/2d-array-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>92/114</small></td></tr></table>
<p>
Representations of &nbsp;<large><code>int matrix[4][4]</code></large> ...
<p><pre>
<comment># for strategy (a)</comment>
matrix: .space 64
<comment># for strategy (b)</comment>
row0:   .space 16
row1:   .space 16
row2:   .space 16
row3:   .space 16
matrix: .word row0, row1, row2, row3
</pre><p>
Now consider summing all elements
<p><pre>
int i, j, sum = 0;
for (i = 0; i < 4; i++)
   for (j = 0; j < 4; j++)
      sum += matrix[i][j];
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>93/114</small></td></tr></table>
<p>
Accessing elements:
<p><div class='center'>
<img alt="[Diagram:Pics/processor/2d-array-access-small.png]" src="Pics/processor/2d-array-access-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>94/114</small></td></tr></table>
<p>
Computing sum of all elements for strategy (a) &nbsp;<large><code>int matrix[4][4]</code></large>
<p><pre><small>
   li  $s0, 0             <comment># sum = 0</comment>
   li  $s1, 4             <comment># s1 = 4 (and sizeof int)</comment>
   li  $s2, 0             <comment># i = 0</comment>
   li  $s3, 16            <comment># sizeof row in bytes</comment>
loop1:
   beq  $s2, $s1, end1    <comment># if (i >= 4) break</comment>
   li   $s3, 0            <comment># j = 0</comment>
loop2:
   beq  $s3, $s1, end2    <comment># if (j >= 4) break</comment>
   mul  $t0, $s2, $s3     <comment># off = 4*4*i + 4*j</comment>
   mul  $t1, $s3, $s1     <comment>#  matrix[i][j] is</comment>
   add  $t0, $t0, $t1     <comment>#  done as *(matrix+off)</comment>
   lw   $t0, matrix($t0)  <comment># t0 = matrix[i][j]</comment>
   add  $s0, $s0, $t0     <comment># sum += t0</comment>
   addi $s3, $s3, 1       <comment># j++</comment>
   j    loop2
end2:
   addi $s2, $s2, 1       <comment># i++</comment>
   j    loop1
end1:
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... 2-d Arrays in MIPS</span></td><td align='right'><small>95/114</small></td></tr></table>
<p>
Computing sum of all elements for strategy (b) &nbsp;<large><code>int matrix[4][4]</code></large>
<p><pre><small>
   li  $s0, 0             <comment># sum = 0</comment>
   li  $s1, 4             <comment># s1 = 4 (sizeof(int))</comment>
   li  $s2, 0             <comment># i = 0</comment>
loop1:
   beq  $s2, $s1, end1    <comment># if (i >= 4) break</comment>
   li   $s3, 0            <comment># j = 0</comment>
   mul  $t0, $s2, $s1     <comment># off = 4*i</comment>
   lw   $s4, matrix($t0)  <comment># row = &matrix[i][0]</comment>
loop2:
   beq  $s3, $s1, end2    <comment># if (j >= 4) break</comment>
   mul  $t0, $s3, $s1     <comment># off = 4*j</comment>
   add  $t0, $t0, $s4     <comment># int *p = &row[j]</comment>
   lw   $t0, ($t0)        <comment># t0 = *p</comment>
   add  $s0, $s0, $t0     <comment># sum += t0</comment>
   addi $s3, $s3, 1       <comment># j++</comment>
   j    loop2
end2:
   addi $s2, $s2, 1       <comment># i++</comment>
   j    loop1
end1:
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Structs in MIPS</span></td><td align='right'><small>96/114</small></td></tr></table>
<p>
C <large><code>struct</code></large>s hold a collection of values accessed by name
<p><div class='center'>
<img alt="[Diagram:Pics/processor/struct-small.png]" src="Pics/processor/struct-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>97/114</small></td></tr></table>
<p>
C <large><code>struct</code></large> definitions effectively define a new type.
<p><pre>
<comment>// new type called struct _student</comment>
struct _student {...};
<comment>// new type called Student</comment>
typedef struct _student Student;
</pre><p>
Instances of structures can be created by allocating space:
<p><pre>
                  <comment>// sizeof(Student) == 56</comment>
stu1:             Student stu1;
   .space 56
stu2:             Student stu2;
   .space 56
stu:
   .space 4       Student *stu;
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>98/114</small></td></tr></table>
<p>
Accessing structure components is by offset, not name
<p><pre>
li  $t0  5012345
sw  $t0, <font color='#009900'>stu1+0</font>       # stu1.id = 5012345;
li  $t0, 3778
sw  $t0, <font color='#009900'>stu1+44</font>      # stu1.program = 3778;
la  $s1, stu2         # stu = & stu2;
li  $t0, 3707
sw  $t0, <font color='#009900'>44($s1)</font>      # stu->program = 3707;
li  $t0, 5034567
sw  $t0, <font color='#009900'>0($s1)</font>       # stu->id = 5034567;
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>99/114</small></td></tr></table>
<p>
Structs that are local to functions are allocated space on the stack
<p><pre><small>
fun:                         int fun(int x) 
   <comment># prologue</comment>                {
   addi $sp, $sp, -4
   sw   $fp, ($sp)
   move $fp, $sp
   addi $sp, $sp, -4
   sw   $ra, ($sp)              // push onto stack
   <font color='#009900'>addi $sp, $sp, -56</font>           Student st;
   <font color='#009900'>move $t0, $sp</font>                Student *t0 = &st;
   <comment># function body</comment>
   ... compute ...              // compute using t0
   <comment># epilogue</comment>                   // to access struct
   <font color='#009900'>addi $sp, $sp, 56</font>            // pop st off stack
   lw   $ra, ($sp)
   addi $sp, $sp, 4
   lw   $fp, ($sp)
   addi $sp, $sp, 4
   jr   $ra                  }
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>100/114</small></td></tr></table>
<p>
C can pass whole structures to functions, e.g.
<p><pre><small>
<font color='#000099'># Student stu; ...
# // set values in stu struct
# showStudent(<font color='#009900'>stu</font>);</font>

   .data
stu: .space 56
   .text
   ...
   la   $t0, stu
   addi $sp, $sp, -56    <comment># push Student object onto stack</comment>
   lw   $t1, 0($t0)      <comment># allocate space and copy all</comment>
   sw   $t1, 0($sp)      <comment># values in Student object</comment>
   lw   $t1, 4($t0)      <comment># onto stack</comment>
   sw   $t1, 4($sp)
   ...
   lw   $t1, 52($t0)     <comment># and once whole object copied</comment>
   sw   $t1, 52($sp)
   jal  showStudent      <comment># invoke showStudent()</comment>
   ...
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>101/114</small></td></tr></table>
<p>
Accessing <large><code>struct</code></large> within function ...
<p><div class='center'>
<img alt="[Diagram:Pics/processor/pass-struct-by-value-small.png]" src="Pics/processor/pass-struct-by-value-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs in MIPS</span></td><td align='right'><small>102/114</small></td></tr></table>
<p>
Can also pass a pointer to a <large><code>struct</code></large>
<p><pre><small>
<font color='#000099'># Student stu;
# // set values in stu struct
# changeWAM(<font color='#009900'>&stu</font>, float newWAM);</font>

   .data
stu: .space 56
wam: .space 4
   .text
   ...
   la   $a0, stu
   lw   $a1, wam
   jal  changeWAM
   ...
</small></pre><p>
Clearly a more efficient way to pass a large <large><code>struct</code></large>
<p>
Also, required if the function needs to update the original <large><code>struct</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Compiling C to MIPS</span></td><td align='right'><small>103/114</small></td></tr></table>
<p>
Using simplified C as an intermediate language
<ul>
<li> makes things easier for a human to prodcue MIPS code
<li> does not provide an automatic way of translating
<li> this is provided by a <em>compiler</em> (e.g. <large><code>dcc</code></large>)
</ul>
What does the compiler need to do to convert C to MIPS?
<ul>
<li> convert <large><code>#include</code></large> and <large><code>#define</code></large>
<li> <em>parse</em> code to check syntactically valid
<li> manage a list of <em>symbols</em> used in program
<li> decide how to represent data structures 
<li> allocate local variables to registers or stack
<li> map control structures to MIPS instructions
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>C Pre-processor</span></td><td align='right'><small>104/114</small></td></tr></table>
<p>
Maps C&rarr;C, performing various <em>substitutions</em>
<ul>
<li> <large><font color="#008800"><b><code>#include</code></b></font></large> <i>File</i>
<ul>
<li> replace <large><code>#include</code></large> by contents of file
<li> <large><code>"</code></large>name<large><code>.h"</code></large> ... uses named <i>File</i><large><code>.h</code></large>
<li> <large><code>&lt;</code></large>name<large><code>.h&gt;</code></large> ... uses <i>File</i><large><code>.h</code></large> in <large><code>/usr/include</code></large>
</ul>
<li> <large><font color="#008800"><b><code>#define</code></b></font></large> <i>Name</i> <i>Constant</i>
<ul>
<li> replace all occurences of symbol <i>Name</i> by <i>Constant</i>
<li> e.g <large><code>#define MAX 5</code></large> <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <large><code>char array[MAX]</code></large> &nbsp;&rarr;&nbsp; <large><code>char array[5]</code></large>
</ul>
<li> <large><font color="#008800"><b><code>#define</code></b></font></large> <i>Name</i><large><font color="#008800"><b><code>(</code></b></font></large><i>Params</i><large><font color="#008800"><b><code>)</code></b></font></large> <i>Expression</i>
<ul>
<li> replace <i>Name</i><large><code>(</code></large><i>Params</i><large><code>)</code></large> by <i>SubstitutedExpression</i>
<li> e.g. <large><code>#define max(x,y) ((x > y) ? x : y)</code></large> <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <large><code>a = max(b,c)</code></large> &nbsp;&rarr;&nbsp; <large><code>a = ((b > c) ? b : c)</code></large>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... C Pre-processor</span></td><td align='right'><small>105/114</small></td></tr></table>
<p>
More C pre-processor substitions
<p><pre>
<font color='#0000CC'><i>Before cpp</i></font>                <font color='#0000CC'><i>After cpp</i></font>

x = 5;                    x = 5;
<font color='#009900'>#if 0</font>                     x = x + 2;
x = x + 1;                printf("x=%d\n",x);
<font color='#009900'>#else</font>                     x = x * 2;
x = x + 2;
<font color='#009900'>#endif</font>
                          <font color='#0000CC'><i>Assuming ...</i></font>
<font color='#009900'>#ifdef DEBUG</font>              #define DEBUG 1
printf("x=%d\n",x);       <font color='#0000CC'><i>or</i></font>
<font color='#009900'>#endif</font>                    gcc -DDEBUG=1 ...
x = x * 2;
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>C Parser</span></td><td align='right'><small>106/114</small></td></tr></table>
<p>
Understands syntax of C language
<p>
Attempts to convert C program into <em>parse tree</em>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/compile/parse-small.png]" src="Pics/compile/parse-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Symbol Table Management</span></td><td align='right'><small>107/114</small></td></tr></table>
<p>
Compiler keeps track of names
<ul>
<li> scope, lifetime, locally/externally defined
<li> disambiguates e.g. &nbsp;<large><code>x</code></large> in <large><code>main()</code></large> &nbsp;vs &nbsp;<large><code>x</code></large> in <large><code>fun()</code></large>
<li> resolves symbols to specific locations (data/stack/registers)
<li> external symbols may remain unresolved until linking
<li> however, need to have a type for each external symbol
</ul>
Example:
<p><pre>
double fun(double x, int n);

int main(void) {
   int i;  double res;
   scanf("%d", &i);
   res = fun((float)i, 5);
   return 0;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Local Variables</span></td><td align='right'><small>108/114</small></td></tr></table>
<p>
Two choices for local variables
<ul>
<li> on the stack ... <font color='#009900'>+</font>persist for whole function, <font color='#CC0000'>-</font><large><code>lw</code></large>/<large><code>sw</code></large> needed in MIPS
<li> in a register ... <font color='#009900'>+</font>efficient, <font color='#CC0000'>-</font>not many, useful if var used in small scope
<ul>
<li> if need to persist across function calls, use <large><code>$s?</code></large> register
<li> if used in very localised scope, can use <large><code>$t?</code></large> register
</ul>
</ul>
Example:
<p><pre>
int sum(List L)
{
   if (L == NULL) return 0;
   int <font color='#009900'>first</font> = L->value;     <comment>// must be in $s?</comment>
   int <font color='#CC0000'>rest</font> = sum(L->next);  <comment>// can be in $t?</comment>
   return <font color='#009900'>first</font> + <font color='#CC0000'>rest</font>;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Expression Evaluation</span></td><td align='right'><small>109/114</small></td></tr></table>
<p>
Uses temporary (<large><code>$t?</code></large>) registers
<ul>
<li> even complex expressions don't generally need &gt; 3-4 registers
</ul>
Example:
<p><pre>
   <font color='#0000CC'>x = ((y+3) * (z-2) * x) / 4;</font>

   lw   $t0, y
   addi $t0, $t0, 3    <comment># t0 = y + 3</comment>
   lw   $t1, z
   addi $t1, $t1, -2   <comment># t1 = z - 2</comment>
   mul  $t0, $t0, $t1  <comment># t0 = t0 * t1</comment>
   lw   $t1, x
   mul  $t0, $t0, $t1  <comment># t0 = t0 * x</comment>
   li   $t1, 4
   div  $t0, $t0, $t1  <comment># t0 = t0 / 4</comment>
</pre><p>
Complex boolean expressions handled by short-circuit evaluation.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Mapping Control Structures</span></td><td align='right'><small>110/114</small></td></tr></table>
<p>
Use templates, e.g.
<p><pre>
<font color='#0000CC'>while (<i>Cond</i>) { <i>Stat1</i>; <i>Stat2</i>; ... }</font>

loop:
   <comment>MIPS code to check <i>Cond</i>; result in $t0</comment>
   beqz $t0, end_loop
   <comment>MIPS code for <i>Stat1</i></comment>
   <comment>MIPS code for <i>Stat2</i></comment>
   <comment>MIPS code for <i>...</i></comment>
   j    loop
end_loop:
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Mapping Control Structures</span></td><td align='right'><small>111/114</small></td></tr></table>
<p>
Template for <large><code>if...else if... else</code></large>
<p><pre>
<font color='#0000CC'>if (<i>Cond1</i>) <i>Stat1</i> else if (<i>Cond2</i>) <i>Stat2</i> else <i>Stat3</i></font>

if:
   <comment>MIPS code to check <i>Cond1</i>; result in $t0</comment>
   beqz $t0, else1
   <comment>MIPS code for <i>Stat1</i></comment>
   j    end_if
else1:
   <comment>MIPS code to check <i>Cond2</i>; result in $t0</comment>
   beqz $t0, else2
   <comment>MIPS code for <i>Stat2</i></comment>
   j    end_if
else2:
   <comment>MIPS code for <i>Stat3</i></comment>
end_if:
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'> Argc and Argv</span></td><td align='right'><small>112/114</small></td></tr></table>
<p>
The real MIPS machine has no idea about <large><code>argc</code></large> and <large><code>argv</code></large>
<p>
SPIM runs under Linux, and needs to interact with environment
<p>
So, the initialisation code (that invokes <large><code>main</code></large>) sets them up:
<p><pre>
    lw    $a0 0($sp)   # argc 
    addiu $a1 $sp 4    # argv 
    ...
    jal   main 
    nop 
    li    $v0 10 
    syscall            # syscall 10 (exit) 
</pre><p>
<p><br>
<small>
Note: we are ignoring <large><code>envp</code></large> (environment pointer)
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  Argc and Argv</span></td><td align='right'><small>113/114</small></td></tr></table>
<p>
What the main program receives:
<p><div class='center'>
<img alt="[Diagram:Pics/mips/argc-argv-small.png]" src="Pics/mips/argc-argv-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  Argc and Argv</span></td><td align='right'><small>114/114</small></td></tr></table>
<p>
Code to print the program's name (<large><code>argv[0]</code></large>):
<p><pre>
   # assume argc is $s0, argv is $s1
   addi   $t0, $s1, 0    <comment># &argv[0]</comment>
   lw     $a0, ($t0)     <comment># argv[]</comment>
   li     $v0, 4
   syscall
</pre><p>
Code to print the first cmd-line arg (<large><code>argv[1]</code></large>)
<p><pre>
   # assume argc is $s0, argv is $s1
   addi   $t0, $s1, 4    <comment># &argv[4]</comment>
   lw     $a0, ($t0)     <comment># argv[]</comment>
   li     $v0, 4
   syscall
</pre><p>
<p><hr><p>
<small><small>Produced: 2 Apr 2018</small></small>
</body>
</html>
