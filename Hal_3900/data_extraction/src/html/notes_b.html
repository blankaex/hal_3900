<html>
<head>
<title>B: Memory and Data Representation</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>Course Notes B: Memory and Data Representation</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>The C View of Data</span></td><td align='right'><small>1/56</small></td></tr></table>
<p>
A C program sees data as a collection of <em>variables</em>
<p><pre>
int <font color='#CC0000'>g</font> = 2;

int main(void)
{
    int   <font color='#CC0000'>i</font>;
    int   <font color='#CC0000'>v</font>[5]
    char *<font color='#CC0000'>s</font> = "Hello";
    int  *<font color='#CC0000'>n</font> = malloc(sizeof(int));
    ...
}
</pre><p>
<br>
Each variable has a number of properties (e.g. name, type, size)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>2/56</small></td></tr></table>
<p>
Variables are examples of <em>computational objects</em>
<p>
Each computational object has
<ul>
<li> a <em>location</em> in memory
<li> a <em>value</em> &nbsp; <small>(ultimately just a bit-string)</small>
<li> a <em>name</em> &nbsp; <small>(unless created by <large><code>malloc()</code></large>)</small>
<li> a <em>type</em>, which determines ...
<ul>
<li> its <em>size</em> &nbsp; <small>(in units of whole bytes, <large><code>sizeof</code></large>)</small>
<li> how to <em>interpret</em> its value
<li> what <em>operations</em> apply to the value
</ul>
<li> a <em>scope</em> &nbsp; <small>(where it's visible within the program)</small>
<li> a <em>lifetime</em> &nbsp; <small>(during which part of program execution it exists)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>3/56</small></td></tr></table>
<p>
C allocates data objects to various well-defined
regions of memory<br>during program execution
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/regions-small.png]" src="Pics/memory/regions-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>4/56</small></td></tr></table>
<p>
The <em>global data</em> area contains
<ul>
<li> global variables, static variables, string constants
<li> objects persist for entire duration of program execution
</ul>
The <em>heap</em> contains
<ul>
<li> objects created by <large><code>malloc</code></large>, <large><code>calloc</code></large>, ...
<li> objects persist in heap until explicitly <large><code>free</code></large>'d
</ul>
The <em>stack</em> contains
<ul>
<li> a small region (<em>frame</em>) for each active function
<li> frames contain local variables and parameters
<li> a frame is created when a function is called
<li> the frame is removed when the function returns
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... The C View of Data</span></td><td align='right'><small>5/56</small></td></tr></table>
<p>
Example of runtime stack during call to <large><code>h()</code></large>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/stack-frames-small.png]" src="Pics/memory/stack-frames-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>The Physical View of Data</span></td><td align='right'><small>6/56</small></td></tr></table>
<p>
Memory = indexed array of bytes
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/byte-array-small.png]" src="Pics/memory/byte-array-small.png">
</div><p>
<p>
Indexes are "memory addresses" (a.k.a. pointers)
<p>
Data can be fetched in chunks of 1,2,4,8 bytes
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory</span></td><td align='right'><small>7/56</small></td></tr></table>
<p>
Also called: RAM, main memory, primary storage, ...
<p>
Technology: semiconductor-based
<p>
Distinguishing features
<ul>
<li> relatively large (e.g. 2<sup>28</sup> bytes)
<li> any byte can be fetched with same cost
<li> cost of fetching 1,2,4,8 bytes is small (ns)
</ul>
<p>
Two properties related to data persistence
<ul>
<li> <em>volatile</em> (e.g. DRAM) ... data lost when powered off
<li> <em>non-volatile</em> (e.g. EEPROM) ... data stays when powered off
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory</span></td><td align='right'><small>8/56</small></td></tr></table>
<p>
When addressing objects in memory
<ul>
<li> any byte address can be used to fetch 1-byte object
<li> byte address for <i>N</i>-byte object must be divisible by <i>N</i>
</ul>
Data is fetched into <i>N</i>-byte CPU registers for use
<p>
Data bytes in registers may be in different order to memory, e.g.
<p><div class='center'>
<img alt="[Diagram:Pics/memory/byte-order-small.png]" src="Pics/memory/byte-order-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory</span></td><td align='right'><small>9/56</small></td></tr></table>
<p>
Memories can be categorised as <em>big-endian</em> or <em>little-endian</em>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/endian-small.png]" src="Pics/memory/endian-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Data Representation</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Data Representation</span></td><td align='right'><small>11/56</small></td></tr></table>
<p>
Ultimately, memory allows you to
<ul>
<li> load bit-strings of sizes 1,2,4,8 bytes
<li> from <i>N</i>-byte boundary addresses
<li> into registers in the CPU
</ul>
What you are presented with is a string of 8,16,32,64 bits
<p>
Need to <em>interpret</em> this bit-string as a meaningful value
<p>
<em>Data representations</em> provide a way of assigning meaning to bit-strings
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Character Data</span></td><td align='right'><small>12/56</small></td></tr></table>
<p>
Character data has several possible representations (encodings)
<p>
The two most common:
<ul>
<li> ASCII (ISO 646)
<ul>
<li> 7-bit values, using lower 7-bits of a byte <small>(top bit always zero)</small>
<li> can encode roman alphabet, digits, punctuation, control chars
</ul>
<li> UTF-8 (Unicode) 
<ul>
<li> 8-bit values, with ability to extend to multi-byte values
<li> can encode all human languages plus other symbols
<p>
(e.g. &nbsp;<big>&Sqrt; &nbsp; &Sum; &nbsp;  &forall; &nbsp; &Exists; </big> &nbsp; or <img src="Pics/misc/emoji-small.png"> )
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>ASCII Character Encoding</span></td><td align='right'><small>13/56</small></td></tr></table>
<p>
Uses values in the range <large><code>0x00</code></large> to <large><code>0x7F</code></large> (0..127)
<p>
Characters partitioned into sequential groups
<ul>
<li> control characters (0..31) ... e.g. <large><code>'\0'</code></large>, <large><code>'\n'</code></large>
<li> punctuation chars (32..47,91..96,123..126)
<li> digits (48..57) ... <large><code>'0'</code></large>..<large><code>'9'</code></large>
<li> upper case alphabetic (65..90) ... <large><code>'A'</code></large>..<large><code>'Z'</code></large>
<li> lower case alphabetic (97..122) ... <large><code>'a'</code></large>..<large><code>'z'</code></large>
</ul>
In C, can map between char and ascii code by e.g. <large><code>((int)'a')</code></large>
<p>
Sequential nature of groups allow for e.g. <large><code>(ch - '0')</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... ASCII Character Encoding</span></td><td align='right'><small>14/56</small></td></tr></table>
<p>
Hexademical ASCII char table <small>(from &nbsp;<large><code>man 7 ascii</code></large>)</small>
<pre style="font-size:75%">
00 nul   01 soh   02 stx   03 etx   04 eot   05 enq   06 ack   07 bel
08 bs    09 ht    0a nl    0b vt    0c np    0d cr    0e so    0f si
10 dle   11 dc1   12 dc2   13 dc3   14 dc4   15 nak   16 syn   17 etb
18 can   19 em    1a sub   1b esc   1c fs    1d gs    1e rs    1f us
20 sp    21  !    22  "    23  #    24  $    25  %    26  &    27  '
28  (    29  )    2a  *    2b  +    2c  ,    2d  -    2e  .    2f  /
30  0    31  1    32  2    33  3    34  4    35  5    36  6    37  7
38  8    39  9    3a  :    3b  ;    3c  <    3d  =    3e  >    3f  ?
40  @    41  A    42  B    43  C    44  D    45  E    46  F    47  G
48  H    49  I    4a  J    4b  K    4c  L    4d  M    4e  N    4f  O
50  P    51  Q    52  R    53  S    54  T    55  U    56  V    57  W
58  X    59  Y    5a  Z    5b  [    5c  \    5d  ]    5e  ^    5f  _
60  `    61  a    62  b    63  c    64  d    65  e    66  f    67  g
68  h    69  i    6a  j    6b  k    6c  l    6d  m    6e  n    6f  o
70  p    71  q    72  r    73  s    74  t    75  u    76  v    77  w
78  x    79  y    7a  z    7b  {    7c  |    7d  }    7e  ~    7f del
</pre>
<p>
<large><code>0x0a</code></large> = <large><code>'\n'</code></large>, &nbsp; <large><code>0x20</code></large> = <large><code>' '</code></large>, &nbsp; <large><code>0x09</code></large> = <large><code>'\t'</code></large>, &nbsp; but note no <large><code>EOF</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unicode</span></td><td align='right'><small>15/56</small></td></tr></table>
<p>
Widely-used standard for expressing "writing systems"
<ul>
<li> not all writing systems use a small set of discrete symbols
</ul>
Basically, a 32-bit representation of a wide range of symbols
<ul>
<li> around 140K symbols, covering 140 different languages
</ul>
Using 32-bits for <i>every</i> symbol would be too expensive
<ul>
<li> e.g. standard roman alphabet + punctuation needs only 7-bits
</ul>
More compact character encodings have been developed (e.g. UTF-8)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>UTF-8 Character Encoding</span></td><td align='right'><small>16/56</small></td></tr></table>
<p>
UTF-8 uses a variable-length encoding as follows
<p>
<div class='center'>
<table border="1" cellpadding="5" cellspacing="0">
<tr>
 <td><b>#bytes</b></td>
 <td><b>#bits</b></td>
 <td><b>Byte 1</b></td>
 <td><b>Byte 2</b></td>
 <td><b>Byte 3</b></td>
 <td><b>Byte 4</b></td>
</tr>
<tr>
 <td>1</td><td>7</td><td><large><code>0xxxxxxx</code></large></td><td>-</td><td>-</td><td>-</td>
</tr>
<tr>
 <td>2</td><td>11</td><td><large><code>110xxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td>-</td><td>-</td>
</tr>
<tr>
 <td>3</td><td>16</td><td><large><code>1110xxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td>-</td>
</tr>
<tr>
 <td>4</td><td>21</td><td><large><code>11110xxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td><td><large><code>10xxxxxx</code></large></td>
</tr>
</table>
</div>
<p>
The 127 1-byte codes are compatible with ASCII
<p>
The 2048 2-byte codes include most Latin-script alphabets
<p>
The 65536 3-byte codes include most Asian languages
<p>
The 2097152 4-byte codes include symbols and emojis and ...
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... UTF-8 Character Encoding</span></td><td align='right'><small>17/56</small></td></tr></table>
<p>
UTF-8 examples
<p>
<div class='center'>
<table border="1" cellpadding="5" cellspacing="0">
<tr>
 <td><b>ch</b></td>
 <td><b>unicode</b></td>
 <td><b>bits</b></td>
 <td><b>simple binary</b></td>
 <td><b>UTF-8 binary</b></td>
</tr>
<tr>
 <td>$</td>
 <td>U+0024</td>
 <td>7</td>
 <td><tt><font color='#CC0000'>010 0100</font></tt></td>
 <td><tt>0<font color='#CC0000'>0100100</font></tt></td>
</tr>
<tr>
 <td>&cent;</td>
 <td>U+00A2</td>
 <td>11</td>
 <td><tt><font color='#009900'>000 10</green<font color='#CC0000'>10 0010</font></tt></td>
 <td><tt>110<font color='#009900'>00010</font> 10<font color='#CC0000'>100010</font></tt></td>
</tr>
<tr>
 <td>&#x20AC;</td>
 <td>U+20AC</td>
 <td>16</td>
 <td><tt><font color='#0000CC'>0010</font> <font color='#009900'>0000 10</font><font color='#CC0000'>10 1100</font></tt></td>
 <td><tt>1110<font color='#0000CC'>0010</font> 10<font color='#009900'>000010</font> 10<font color='#CC0000'>101100</font></tt></td>
</tr>
<tr>
 <td><big>&#x10348;</big></td>
 <td>U+10348</td>
 <td>21</td>
 <td><tt><font color='#996600'>0 00</font><font color='#0000CC'>01 0000</font> <font color='#009900'>0011 01</font><font color='#CC0000'>00 1000</font></tt></td>
 <td><tt>11110<font color='#996600'>000</font> 10<font color='#0000CC'>010000</font> 10<font color='#009900'>001101</font> 10<font color='#CC0000'>001000</font></tt></td>
</tr>
</table>
</div>
<p>
Unicode strings can be manipulated in C (e.g. "<img src="Pics/misc/annyong-small.png">")
<p>
Like other C strings, they are terminated by a 0 byte (i.e. <large><code>'\0'</code></large>)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... UTF-8 Character Encoding</span></td><td align='right'><small>18/56</small></td></tr></table>
<p>
Unicode constants in C strings ...
<p>
The following two notations work in some contexts
<ul>
<li> <large><font color="#008800"><b><code>\u</code></b></font></large><i>HexDigits</i> ... insert Unicode code value
<li> <large><font color="#008800"><b><code>\x</code></b></font></large><i>2HexDigits</i> ... insert individual bytes
</ul>
Examples:
<p><pre>
u"abc<font color='#CC0000'>\u21AB</font>def"
"abc<font color='#CC0000'>\xE2\x86\xAB</font>def"
</pre><p>
The red sequences produce 3 bytes and 1 Unicode symbol.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Numeric Data</span></td><td align='right'><small>19/56</small></td></tr></table>
<p>
Numeric data comes in two major forms
<ul>
<li> integer ... subset (range) of the mathematical integers
<li> floating point ... subset of the mathematical real numbers
</ul>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/numbers-small.png]" src="Pics/memory/numbers-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Integer Constants</span></td><td align='right'><small>20/56</small></td></tr></table>
<p>
Three ways to write integer constants in C
<ul>
<li> <large><code>42</code></large> ... signed decimal &nbsp;(<large><code>0</code></large>..<large><code>9</code></large>)
<li> <large><code><font color='#CC0000'>0x</font>2A</code></large> ... unsigned hexadecimal &nbsp;(<large><code>0</code></large>..<large><code>F</code></large>)
<li> <large><code><font color='#CC0000'>0</font>52</code></large> ... signed octal &nbsp;(<large><code>0</code></large> ..<large><code>7</code></large>)
</ul>
Variations
<ul>
<li> <large><code>123U</code></large> ... <large><code>unsigned int</code></large> value &nbsp; <small>(typically 32 bits)</small>
<li> <large><code>123L</code></large> ... <large><code>long int</code></large> value &nbsp; <small>(typically 64 bits)</small>
<li> <large><code>123S</code></large> ... <large><code>short int</code></large> value &nbsp; <small>(typically 16 bits)</small>
</ul>
Invalid constants lie outside the range for their type, e.g.
<ul>
<li> <large><code>4294967296</code></large>, &nbsp; <large><code>-1U</code></large>, &nbsp; <large><code>666666S</code></large>, &nbsp; <large><code>078</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unsigned integers</span></td><td align='right'><small>21/56</small></td></tr></table>
<p>
The <large><font color="#008800"><b><code>unsigned int</code></b></font></large> data type
<ul>
<li> commonly 32 bits, storing values in the range 0 .. 2<sup>32</sup>-1
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/unsigned-int-small.png]" src="Pics/memory/unsigned-int-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unsigned integers</span></td><td align='right'><small>22/56</small></td></tr></table>
<p>
Value interpreted as binary number
<p>
E.g. consider an 8-bit unsigned int
<p>
<large><code>01001101</code></large> &nbsp;=&nbsp; 2<sup>6</sup> + 2<sup>3</sup> + 2<sup>2</sup> + 2<sup>0</sup> &nbsp;=&nbsp; 64 + 8 + 4 + 1 &nbsp;=&nbsp; 77
<p>
Addition is bitwise with carry
<p><pre>
  00000001     00000001     01001101     11111111
+ 00000010   + 00000011   + 00001011   + 00000001
  --------     --------     --------     --------
  00000011     00000100     01011000     00000000
</pre><p>
Most machines will also flag the <em>overflow</em> in the fourth example
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Signed integers</span></td><td align='right'><small>23/56</small></td></tr></table>
<p>
The <large><font color="#008800"><b><code>int</code></b></font></large> data type
<ul>
<li> commonly 32 bits, storing values in the range -2<sup>31</sup> .. 2<sup>31</sup>-1
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/signed-int-small.png]" src="Pics/memory/signed-int-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>24/56</small></td></tr></table>
<p>
Several possible representations for negative values
<ul>
<li> signed magnitude ... first bit is sign, rest are magnitude
<li> ones complement ... form <i>-N</i> by inverting all bits in <i>N</i>
<li> twos complement ... form <i>-N</i> by inverting <i>N</i> and adding 1
</ul>
In all representations, +ve numbers have 0 in leftmost bit
<p>
Examples: representations of (8-bit) -5  (where 5 is <large><code>00000101</code></large>)
<ul>
<li> <large><code><font color='#CC0000'>1</font>0000101</code></large> ... signed magnitude
<li> <large><code>11111010</code></large> ... ones complement
<li> <large><code>11111011</code></large> ... twos complement
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>25/56</small></td></tr></table>
<p>
<em>Signed magnitude</em>: Easy to form <i>-X</i> from <i>X</i> ... OR in high-order bit
<p>
A problem (using 8-bit <large><code>int</code></large>s) ...
<ul>
<li> what do these numbers represent? &nbsp;<large><code>00000000</code></large>, &nbsp;<large><code>10000000</code></large>
</ul>
Two zeroes ... one positive, one negative
<p>
Another problem: &nbsp;<i>x + -x &ne; 0</i> (mostly) with simple addition
<p><pre>
  00000011  3     00101010  42      01111111  127
+ 10000011 -3   + 10101010 -42    + 11111111 -127
  --------        --------          --------
  10000110 !0     11010100  !0      01111110   !0
</pre><p>
To fix requires extra hardware in ALU
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>26/56</small></td></tr></table>
<p>
<em>Ones complement</em>: Easy to form <i>-X</i> from <i>X</i> ... NEG all bits
<p>
A problem (using 8-bit <large><code>int</code></large>s) ...
<ul>
<li> what do these numbers represent? &nbsp;<large><code>00000000</code></large>, &nbsp;<large><code>11111111</code></large>
</ul>
Two zeroes ... one positive, one negative
<p>
At least &nbsp;<i>x + -x</i> is equal to one of the zeroes with simple addition
<p><pre>
  00000011  3     00101010  42      01111111
+ 11111100 -3   + 11010101 -42    + 10000000
  --------        --------          --------
  11111111 !0     11111111  !0      11111111 -0
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signed integers</span></td><td align='right'><small>27/56</small></td></tr></table>
<p>
<em>Twos complement</em>: to form <i>-X</i> from <i>X</i> ... NEG all bits, then add 1
<p>
Now have only one representation for zero (<large><code>00000000</code></large>)
<ul>
<li> <large><code>-0</code></large> &nbsp;=&nbsp; <large><code>~00000000+1</code></large> &nbsp;=&nbsp; <large><code>11111111+1</code></large> &nbsp;=&nbsp; <large><code>00000000</code></large>
</ul>
Only one zero value. &nbsp; Also, <i>-(-x)</i> = <i>x</i>
<p>
Even better, &nbsp;<i>x + -x = 0</i> in all cases with simple addition
<p><pre>
  00000011  3     00101010  42      01111111
+ 11111101 -3   + 11010110 -42    + 10000001
  --------        --------          --------
  00000000  0     00000000   0      00000000  0
</pre><p>
Always produces an "overflow" bit, but can ignore this
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Pointers</span></td><td align='right'><small>28/56</small></td></tr></table>
<p>
Pointers represent memory addresses/locations
<ul>
<li> number of bits depends on memory size, but typically 32-bits
<li> data pointers reference addresses in <em>data</em>/<em>heap</em>/<em>stack</em> regions
<li> function pointers reference addresses in <em>code</em> region
</ul>
Many kinds of pointers, one for each data type, but
<ul>
<li> <large><code>sizeof(int *)</code></large> &nbsp;=&nbsp; <large><code>sizeof(char *)</code></large> <br>
	=&nbsp; <large><code>sizeof(double *)</code></large> &nbsp;=&nbsp; <large><code>sizeof(struct X *)</code></large>
</ul>
Pointer <em>values</em> must be appropriate for data type, e.g.
<ul>
<li> <large><code>(char *)</code></large> ... can reference any byte address
<li> <large><code>(int *)</code></large> ... must have &nbsp;<i>addr</i> <large><code>%4 == 0</code></large>
<li> <large><code>(double *)</code></large> ... must have &nbsp;<i>addr</i> <large><code>%8 == 0</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Pointers</span></td><td align='right'><small>29/56</small></td></tr></table>
<p>
Can "move" from object to object by <em>pointer arithmetic</em>
<p>
For any pointer <i>T</i><large><code> *p;</code></large>, &nbsp;<large><code>p++</code></large> increases <large><code>p</code></large> by <large><code>sizeof(</code></large><i>T</i> <large><code>)</code></large>
<p>
Examples (assuming 16-bit pointers):
<p><pre>
char   *p = 0x6060;  p++;  assert(p == 0x6061)
int    *q = 0x6060;  q++;  assert(q == 0x6064)
double *r = 0x6060;  r++;  assert(r == 0x6068)
</pre><p>
A common (efficient) paradigm for scanning a string
<p><pre>
char *s = "a string";
char *c;
<comment>// print a string, char-by-char</comment>
for (c = s; *c != '\0'; c++) {
   printf("%c", *c);
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Floating Point Numbers</span></td><td align='right'><small>30/56</small></td></tr></table>
<p>
Floating point numbers model a (tiny) subset of <big>&reals;</big>
<ul>
<li> many real values don't have exact representation &nbsp;<small>(e.g. 1/3)</small>
<li> results of calculations may contain small inaccuracies 
</ul>
<em>Precision</em> categorises how close to exact
<ul>
<li> numbers close to zero have higher precision (more accurate)
<li> numbers further from zero have lower precision (less accurate)
</ul>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/real-line-small.png]" src="Pics/memory/real-line-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>31/56</small></td></tr></table>
<p>
C has two floating point types
<ul>
<li> <large><font color="#008800"><b><code>float</code></b></font></large> ... typically 32-bit quantity  <small>(lower precision, narrower range)</small>
<li> <large><font color="#008800"><b><code>double</code></b></font></large> ... typically 64-bit quantity <small>(higher precision, wider range)</small>
</ul>
Literal floating point values: &nbsp;<large><code>3.14159</code></large>, &nbsp;<large><code>1.0/3</code></large>, &nbsp;<large><code>1.0e-9</code></large>
<p>
Display via printf
<p><pre>
printf("%<i>W</i>.<i>P</i>f", (float)2.17828)
printf("%<i>W</i>.<i>P</i>lf", (double)2.17828)
</pre><p>
<tt><i>W</i></tt> gives total width (blank padded),
<tt><i>P</i></tt> gives #digits after dec point
<p><pre>
printf("%10.4lf", (double)2.718281828459);
<comment>displays &bbrk;&bbrk;&bbrk;&bbrk;2.7183</comment>
printf("%20.20lf", (double)4.0/7);
<comment>displays 0.57142857142857139685</comment>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>32/56</small></td></tr></table>
<p>
IEEE 754 standard ...
<ul>
<li> scientific notation with <em>fraction</em> <i>F</i> and <em>exponent</em> <i>E</i>
<li> numbers have form <i>F &times; 2<sup>E</sup></i>, where both <i>F</i> and <i>E</i> can be -ve
<li> <large><code>INFINITY</code></large> = representation for <big>&infin;</big> and <big>-&infin;</big> (e.g. 1.0/0)
<li> <large><code>NAN</code></large> = representation for invalid value NaN  (e.g. sqrt(-1.0))
<li> 32-bit single-precision, &nbsp; 64-bit double precision
</ul>
Fraction part is <em>normalised</em> &nbsp;<small>(i.e. 1.2345&times;10<sup>2</sup> rather than 123.45)</small>
<p>
Example of normalising in binary:
<ul>
<li> <large><code>1010.1011</code></large> &nbsp;is normalized as&nbsp; <large><code>1.0101011&times;2<sup>011</sup></code></large>
<li> <large><code>1010.<font color='#009900'>1011</font></code></large> = 10 + <font color='#009900'>11</font>/16 = 10.6875
<li> <large><code>1.<font color='#009900'>0101011</font>&times;2<sup>011</sup></code></large> = (1 + <font color='#009900'>43</font>/128) * 2<sup>3</sup> = 1.3359375 * 8 = 10.6875
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>33/56</small></td></tr></table>
<p>
Internal structure of floating point values
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/float-rep-small.png]" src="Pics/memory/float-rep-small.png">
</div><p>
<p>
More complex than <large><code>int</code></large> because <i>1.dddd e dd</i>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>34/56</small></td></tr></table>
<p>
Details of internal structure
<ul>
<li> fraction part is always <large><code>1.</code></large><i>bbbbbbbb</i>; &nbsp;don't store <large><code>1</code></large>
<li> exponent is offset relative to a baseline <i>-2<sup>b-1</sup>-1</i>, &nbsp;<small><i>b</i> = #exponent bits</small>
</ul>
Ranges of values for 32-bit single-precision float:
<p>
<div class='center'>
<table border="1" cellpadding="5" cellspacing="0">
<tr><td><b>Component</b></td><td><b>Min Value</b></td><td><b>Max Value</b></td></tr>
<tr><td>exponent</td>
 <td><large><code>00000000</code></large> = -127</td>
 <td><large><code>11111111</code></large> = 128</td>
</tr>
<tr><td>fraction</td>
 <td><large><code>00...00</code></large> = 0</sup></td>
 <td><large><code>11...11</code></large> = 2<sup>-1</sup>+2<sup>-2</sup>+...+2<sup>-24</sup></td>
</tr>
</table>
<p>
<large><code>00...00</code></large> = 24 zero bits, <large><code>11...11</code></large> = 24 one bits
</div>
Ranges of values for 64-bit double-precision float:
<p>
<div class='center'>
<table border="1" cellpadding="5" cellspacing="0">
<tr><td><b>Component</b></td><td><b>Min Value</b></td><td><b>Max Value</b></td></tr>
<tr><td>exponent</td>
 <td><large><code>00000000000</code></large> = -2047</td>
 <td><large><code>11111111111</code></large> = 2048</td>
</tr>
<tr><td>fraction</td>
 <td><large><code>00...00</code></large> = 0</sup></td>
 <td><large><code>11...11</code></large> = 2<sup>-1</sup>+2<sup>-2</sup>+...+2<sup>-51</sup></td>
</tr>
</table>
<p>
<large><code>00...00</code></large> = 24 zero bits, <large><code>11...11</code></large> = 24 one bits
</div>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Floating Point Numbers</span></td><td align='right'><small>35/56</small></td></tr></table>
<p>
Example <small>(single-precision)</small>:
<p><pre>
150.75 = 10010110.11
         <comment>// normalise fraction, compute exponent</comment>
       = 1.<font color='#0000CC'>001011011</font> &times; 2<sup><font color='#009900'>7</font></sup>
         <comment>// determine sign bit,</comment>
         <comment>// map fraction to 24 bits,</comment>
         <comment>// map exponent relative to baseline</comment>
       = <font color='#CC0000'>0</font><font color='#009900'>100000110</font><font color='#0000CC'>001011011</font>000000000000000
</pre><p>
where <font color='#CC0000'>red</font> is sign bit, <font color='#009900'>green</font> is exponent, <font color='#0000CC'>blue</font> is fraction
<p>
Note:
<ul>
<li> the baseline (aka bias) is 127, the exponent is 2<sup>7</sup>
<li> so, in the exponent, we store 127+7 = 134 = <large><code>10000110</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Arrays</span></td><td align='right'><small>36/56</small></td></tr></table>
<p>
Arrays are defined to have <i>N</i> elements, each of type <i>T</i>
<p>
Examples:
<p><pre>
int    a[100];    <comment>// array of 10 ints</comment>
char   str[256];  <comment>// array of 256 chars</comment>
double vec[100];  <comment>// array of 100 doubles</comment>
</pre><p>
Elements are laid out adjacent in memory
<p><div class='center'>
<img alt="[Diagram:Pics/memory/array-in-mem-small.png]" src="Pics/memory/array-in-mem-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Arrays</span></td><td align='right'><small>37/56</small></td></tr></table>
<p>
Assuming an array declaration like &nbsp;<i>Type</i><large><code> v[</code></large><i>N </i><large><code>]</code></large> ...
<ul>
<li> individual array elements are accessed via indices 0..<i>N-1</i>
<li> total amount of space allocated to array <i>N</i> &times; <large><code>sizeof(</code></large><i>Type </i><large><code>)</code></large>
</ul>
Name of array gives address of first element &nbsp;(e.g. <large><code>v</code></large> = <large><code>&v[0]</code></large>)
<p>
Name of array can be treated as a pointer to element type <i>Type</i>
<p>
Array indexing can be treated as &nbsp;<large><code>v[i]</code></large> &cong; <large><code>*(v+i)</code></large>
<p>
If have pointer to first element, can use it just like an array
<p>
Strings are just arrays of <large><code>char</code></large> with a <large><code>'\0'</code></large> terminator
<ul>
<li> constant strings have <large><code>'\0'</code></large> added automatically
<li> string buffers must allow for element to hold <large><code>'\0'</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Arrays</span></td><td align='right'><small>38/56</small></td></tr></table>
<p>
When arrays are "passed" to a function, actually pass <large><code>&a[0]</code></large>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/string-param-small.png]" src="Pics/memory/string-param-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Arrays</span></td><td align='right'><small>39/56</small></td></tr></table>
<p>
Arrays can be created automatically or via <large><code>malloc()</code></large>
<p><pre>
int main(void)
{
    char str1[9] = "a string";
    char *str2;  <comment>// no array object yet</comment>

    str2 = malloc(20*sizeof(char));
    strcpy(str2, str);
    printf("&str1=%p, str1=%s\n", str1, str1);
    printf("&str2=%p, str2=%s\n", str2, str2);

    free(str2);
    return 0;
}
</pre><p>
Two separate arrays (different &amp;'s), but have same contents
<p>
<small>(except for the unitialised parts of the arrays)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Structs</span></td><td align='right'><small>40/56</small></td></tr></table>
<p>
Structs are defined to have a number of components
<ul>
<li> each component has a <i>Name</i>&nbsp; and a <i>Type</i>
</ul>
Example:
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-student-small.png]" src="Pics/memory/struct-student-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs</span></td><td align='right'><small>41/56</small></td></tr></table>
<p>
Internal layout of <large><code>struct</code></large> components determined by compiler
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-student2-small.png]" src="Pics/memory/struct-student2-small.png">
</div><p>
<p>
Each name maps to a byte offset within the <large><code>struct</code></large>
<p>
<small>E.g. in first example <large><code>id</code></large> = offset 0, <large><code>given</code></large> = offset 4, <large><code>family</code></large> = offset 54, etc.</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Structs</span></td><td align='right'><small>42/56</small></td></tr></table>
<p>
To ensure alignment, internal "padding" may be needed
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-pad-small.png]" src="Pics/memory/struct-pad-small.png">
</div><p>
<p>
Padding wastes space; re-order fields to minimise waste.
<p>
<large><code>clang</code></large> has <large><code>-Wpadded</code></large> to warn about padding in <large><code>struct</code></large>s
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exercise 1: Struct Alternatives</span></td><td align='right'><small>43/56</small></td></tr></table>
<p>
Consider these two possible representations of Nodes in a linked list of strings:
<p><div class='center'>
<img alt="[Diagram:Pics/memory/node-structs-small.png]" src="Pics/memory/node-structs-small.png">
</div><p>
Show how they would be (a) defined, (b) initialised. How large is each?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Variable-length Structs</span></td><td align='right'><small>44/56</small></td></tr></table>
<p>
<large><code>Struct</code></large>s can contain pointers to dynamic objects
<p>
But we can also "embed" one dynamic object in a malloc'd <large><code>struct</code></large>
<ul>
<li> define the dynamic object as the last component
<li> malloc() more space than the <large><code>struct</code></large> requires
<li> to make the final component as large as required
</ul>
Example:
<p><pre>
struct _vstruct {
   int  length;
   char chars[1]; <comment>// array whose real length</comment>
                  <comment>// is calculated when malloc'ing</comment>
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Variable-length Structs</span></td><td align='right'><small>45/56</small></td></tr></table>
<p>
Amount of memory allocated to <large><code>struct</code></large> is determined dynamically:
<p><div class='center'>
<img alt="[Diagram:Pics/memory/var-struct-small.png]" src="Pics/memory/var-struct-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Bit-wise Structs</span></td><td align='right'><small>46/56</small></td></tr></table>
<p>
For fine-grained control over layout of fields in <large><code>struct</code></large>s
<ul>
<li> C allows programmers to specify <large><code>struct</code></large>s bit-wise
</ul>
Bit-field <large><code>struct</code></large>s ...
<ul>
<li> specify unnamed <font color='#009900'>components</font> using standard types
<li> specify named individual <font color='#CC0000'>bit fields</font> in each component
</ul>
Example:
<p><pre>
struct _bit_fields {
   <font color='#009900'>unsigned int</font> first_bit    : <font color='#CC0000'>1</font>,
                next_7_bits  : <font color='#CC0000'>7</font>,
                last_24_bits : <font color='#CC0000'>24</font>;
};
</pre><p>
Has one component and three bit fields within that component.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Bit-wise Structs</span></td><td align='right'><small>47/56</small></td></tr></table>
<p>
Two ways of declaring bit fields:
<p><pre>
struct _bit_fields {
   unsigned int first_bit    : 1,
                next_7_bits  : 7,
                last_24_bits : 24;
};
<comment>OR</comment>
struct _bit_fields {
   unsigned int first_bit    : 1;
   unsigned int next_7_bits  : 7;
   unsigned int last_24_bits : 24;
};
</pre><p>
In both cases, <large><code>sizeof(struct _bit_fields)</code></large> is 4 bytes.
<p>
First way makes it clearer that a single <large><code>unsigned int</code></large> is used.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Bit-wise Structs</span></td><td align='right'><small>48/56</small></td></tr></table>
<p>
Another example (graphics objects):
<p><pre>
struct _object { <comment>// comprised of two 32-bit words</comment>
   unsigned int  red    : 5,  <comment>// 5 bits for red</comment>
                 blue   : 5,  <comment>// 5 bits for blue</comment>
                 green  : 5,  <comment>// 5 bits for green</comment>
                 pad    : 1,  <comment>// 1 bit to pad to short</comment>
                 ident  : 16; <comment>// 16 bits for object ID</comment>
   unsigned int  height : 6,  <comment>// 6 bits for object height</comment>
                 width  : 6,  <comment>// 6 bits for object width</comment>
                 xcoord : 9,  <comment>// 9 bits for x-coordinate</comment>
                 ycoord : 9;  <comment>// 9 bits for y-coordinate</comment>
};

struct _object oval;
...
oval.red = 4; oval.blue = 31; oval.green = 15;
oval.height = 5; oval.width = 15;
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Bit-wise Structs</span></td><td align='right'><small>49/56</small></td></tr></table>
<p>
The graphics object would be stored in memory as:
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/bit-fields-small.png]" src="Pics/memory/bit-fields-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Bit-wise Structs</span></td><td align='right'><small>50/56</small></td></tr></table>
<p>
Bit-fields provide an alternative to bit operators and masks:
<p><pre><small>
typedef unsigned int uint;         struct _privs {
typedef uint privs;                   unsigned int
#define OWNER_READ  (1 &lt;< 8)             owner_read  : 1,
#define OWNER_WRITE (1 &lt;< 7)             owner_write : 1,
#define OWNER_EXEC  (1 &lt;< 6)             owner_exec  : 1,
...                                      ...
#define OTHER_WRITE (1 &lt;< 1)             other_write : 1,
#define OTHER_EXEC  (1 &lt;< 0)             other_exec  : 1;
unsigned int myPrivs;              } myPrivs;

<comment>// give owner execute permission on file</comment>
myPrivs |= OWNER_EXEC;             myPrivs.owner_exec = 1;

<comment>// prevent others from writing on file</comment>
myPrivs &= ~OTHER_WRITE;           myPrivs.other_write = 0;

<comment>// check whether file is readable to all</comment>
open = myPrivs & OTHER_READ;       open = myPrivs.other_read;
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unions</span></td><td align='right'><small>51/56</small></td></tr></table>
<p>
Unions allow programmers to specify multiple interpretations for a single piece of memory.
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/union-view-small.png]" src="Pics/memory/union-view-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unions</span></td><td align='right'><small>52/56</small></td></tr></table>
<p>
Example of defining a <large><code>union</code></large> type (cf. <large><code>struct</code></large>):
<p><pre>
union _alltypes {
    int   intval;
    char  strval[4];
    char  charval;
    float floatval;
};

union _alltypes myUnion;
</pre><p>
<large><code>myUnion</code></large> is a single 4-byte memory object
<p>
Programmers can specify how to interpret bits using field names.
<p>
<small>
In the example above, all components are coincidentally the same size (4 bytes)
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unions</span></td><td align='right'><small>53/56</small></td></tr></table>
<p>
Difference between a <large><code>struct</code></large> and a <large><code>union</code></large>
<p><pre>
struct _s {            union _u {
   int   x;               int   x;
   float y;               float y;
} svar;                } uvar;
</pre><p>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/memory/struct-vs-union-small.png]" src="Pics/memory/struct-vs-union-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unions</span></td><td align='right'><small>54/56</small></td></tr></table>
<p>
General syntax for defining <large><code>union</code></large> types and variables:
<p><pre>
union <i>Tag</i> {
   <i>Type<sub>1</sub></i>  <i>Member<sub>1</sub></i>;
   <i>Type<sub>2</sub></i>  <i>Member<sub>2</sub></i>;
   <i>Type<sub>3</sub></i>  <i>Member<sub>3</sub></i>;
   ...
} uvar;
</pre><p>
<large><code><i>Type</i></code></large> can be any C type; <large><code><i>Member</i></code></large> names must be distinct
<p>
<large><code>sizeof(</code></large><i>Union</i><large><code>)</code></large> is the size of the largest member
<p>
<large><code>&uvar.<i>Member<sub>1</sub></i> == &uvar.<i>Member<sub>2</sub></i> == &uvar.<i>Member<sub>3</sub></i> ...</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unions</span></td><td align='right'><small>55/56</small></td></tr></table>
<p>
Common use of <large><code>union</code></large> types: "generic" variables
<p><pre>
#define IS_INT   1
#define IS_FLOAT 2
#define IS_STR   3

struct _generic {
   int   vartype;
   union { int ival; char *sval; float fval; };
};

struct _generic myVar;
<comment>// treat myVar as an integer</comment>
myVar.vartype = IS_INT;
myVar.ival    = 42;
printf("%d\n", myVar.ival);
<comment>// now treat myVar as a float</comment>
myVar.vartype = IS_FLOAT;
myVar.fval    = 3.14159;
printf("%0.5f\n", myVar.fval);
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Enumerated Types</span></td><td align='right'><small>56/56</small></td></tr></table>
<p>
Enumerated types allow programmers to define a set of distinct named values
<p>
<p><pre>
typedef enum { RED, YELLOW, BLUE } PrimaryColours;

typedef enum { LOCAL, INTL } StudentType;
</pre><p>
The names are assigned consecutive <large><code>int</code></large> values, starting from 0
<p>
Above <large><code>PrimaryColors</code></large> type is equivalent to
<p><pre>
#define RED    0
#define YELLOW 1
#define BLUE   2
</pre><p>
Variables of type <large><code>enum...</code></large> are effectively <large><code>unsigned int</code></large>s.
<p><hr><p>
<small><small>Produced: 1 Mar 2018</small></small>
</body>
</html>
