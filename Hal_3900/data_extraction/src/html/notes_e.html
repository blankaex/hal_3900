<html>
<head>
<title>E: Operating System Components</title>
<link href='notes.css' rel='stylesheet' type='text/css'>
</head>
<body>
<p><span class='title'>E: Operating System Components</span><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Storage Management</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Storage Management</span></td><td align='right'><small>2/143</small></td></tr></table>
<p>
Computer systems have <em>bulk</em>, <em>persistent</em> storage devices
<p>
<p><div class='center'>
<img alt="[Diagram:Pics//opsys/hardware1-small.png]" src="Pics//opsys/hardware1-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Disks</span></td><td align='right'><small>3/143</small></td></tr></table>
<p>
HDD = Hard Disk Drive
<p>
HDDs have the following characteristics:
<ul>
<li> magnetic medium, arranged in concentric <em>tracks</em>
<li> usually multiple surfaces for storing data
<li> rotates at very high speed (e.g. 7200rpm)
<li> each track divided into fixed size <em>sectors</em>
<ul>
<li> outer tracks have more sectors than inner tracks
</ul>
<li> read/write head which can read/write one sector at-a-time
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/filesys/disk2-small.png]" src="Pics/filesys/disk2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Disks</span></td><td align='right'><small>4/143</small></td></tr></table>
<p>
To access data on disk (one sector at-a-time)
<ul>
<li> head moves to track <small>(mechanical motion)</small>
<li> head waits for sector to rotate under head <small>(mechanical)</small>
<li> read/write data from/to disk surface <small>(electronic)</small>
</ul>
Disk access costs:
<ul>
<li> seek time (move to track) in range 0ms .. 12ms 
<li> rotational latency (wait for sector) in range 2ms .. 4ms
<li> data transfer ... typically 200 MB/s <small>(relatively small)</small>
<li> Overall: tens of milliseconds for a single access
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Disks</span></td><td align='right'><small>5/143</small></td></tr></table>
<p>
Typical (and historical) measures of HDDs:
<ul>
<li> capacity ... 4TB ... available storage 3.5TB
<li> size ... 2.5/3cm, &nbsp; volume ... 34cm<sup>3</sup>, &nbsp; weight ... 60g
<li> speed ... ~20ms to find sector, &nbsp; &lt; 1ms to read sector
</ul>
Compare to 1958
<ul>
<li> capacity ... 3MB ... available storage 2.5MB
<li> size ... 1.5m, &nbsp; volume ... 2m<sup>3</sup>, &nbsp; weight ... 900kg
<li> speed ... ~600ms to find sector, &nbsp; 5ms to read sector
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Disks</span></td><td align='right'><small>6/143</small></td></tr></table>
<p>
Disks are block-oriented devices
<ul>
<li> all data transfers read/write fixed number of bytes
<li> even if only one byte is required
<li> typical transfer size 512 bytes .. 4096 bytes
</ul>
OS views data on disk as logical blocks
<ul>
<li> each block comprised of one or more sectors
<li> sectors for block arranged to minimse head movement/latency
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>SSDs</span></td><td align='right'><small>7/143</small></td></tr></table>
<p>
SSD = solid-state drive
<p>
SSDs are fully-electronic devices that can store data persistenly
<ul>
<li> don't have mechanical delays that HDDs do (R/W much faster)
<li> better thermal performance that HDDs (e.g. no fans needed)
<li> controller more complex/spohisticated than HDD controller
<li> relatively expensive per byte of storage (compared to HDDs)
<li> limited number of read/writes on each block before failure
<li> data "leaks" over time (over years ... but worse than HDDs)
<li> writing requires erase-then-overwrite
<li> susceptible to elector-magnetic fluctations (e.g. power-outs)
</ul>
Useful comparison between HDD and SSD on
<a href="https://en.wikipedia.org/wiki/Solid-state_drive">Wikipedia</a>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... SSDs</span></td><td align='right'><small>8/143</small></td></tr></table>
<p>
OSs can view SSDs like HDDs
<ul>
<li> block-oriented devices but much faster than HDDs (e.g. 0.1ms)
<li> but limited number (10<sup>5</sup>) of erases on each block before failure
<li> easier to access logical blocks (access to multiple SSD blocks)
<li> less fragmentation problems than HDDs
</ul>
Many SSDs are packaged with similar form-factor to HDD
<ul>
<li> drop-in, high-speed replacement for HDD
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Operating Systems and Storage</span></td><td align='right'><small>9/143</small></td></tr></table>
<p>
Operating System manages data stored on bulk storage devices
<ul>
<li> provides an abstract view of devices
<li> hiding details of device control and data transfer
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>File Systems</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File Systems</span></td><td align='right'><small>11/143</small></td></tr></table>
<p>
<em>File systems</em> provide a mechanism for managing <em>stored data</em>:
<ul>
<li> typically on a disk device <small>(or, nowadays, on SSD)</small>
<li> allocating chunks of space on the device to <em>files</em>
<ul>
<li> where a file is viewed as a sequence of bytes
</ul>
<li> allowing access to files by <em>name</em> and with <em>access rights</em>
<li> arranging access to files via <em>directories</em> (folders)
<li> maintaining information about files/directories (<em>meta-data</em>)
<li> dealing with damage on the storage device ("bad blocks")
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unix/Linux File System</span></td><td align='right'><small>12/143</small></td></tr></table>
<p>
Unix/Linux file system is tree-structured
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/unix-fs-small.png]" src="Pics/opsys/unix-fs-small.png">
</div><p>
<small>(We say it's "tree structured", but symlinks actually make it into a graph)</small>
<p>
Processes have a notion of their location within the file system
<ul>
<li> <em>current working directory</em> &nbsp; (CWD)
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux File System</span></td><td align='right'><small>13/143</small></td></tr></table>
<p>
The file system is used to access various types of objects:
<ul>
<li> files, directories (folders), devices, processes, sockets, ...
</ul>
Objects are referenced via a <em>path</em>  &nbsp;<small>(...<large><code>/x/y/z/</code></large>...)</small>
<p>
Paths can be
<ul>
<li> <em>absolute</em> &nbsp;<small>(full path from root)</small>
<p>
e.g. <large><code><font color='#CC0000'>/</font>usr/include/stdio.h</code></large>, &nbsp;<large><code><font color='#CC0000'>/</font>home/jas/cs1521/</code></large>
<li> <em>relative</em> &nbsp;<small>(path starts from CWD)</small>
<p>
e.g. <large><code>../../another/path/prog.c</code></large>, &nbsp;<large><code>./a.out</code></large>, &nbsp;<large><code>a.out</code></large>
</ul>
<br>
Q: Why do we have to run <large><code>a.out</code></large> as <large><code>./a.out</code></large>?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux File System</span></td><td align='right'><small>14/143</small></td></tr></table>
<p>
Unix defines a range of file-system-related types:
<ul>
<li> <large><font color="#008800"><b><code>off_t</code></b></font></large> ... offsets within files
<ul>
<li> typically, <large><code>long</code></large> and signed to allow backward refs
</ul>
<li> <large><font color="#008800"><b><code>size_t</code></b></font></large> ... number of bytes in some object
<ul>
<li> unsigned, since objects can't have negative size
</ul>
<li> <large><font color="#008800"><b><code>ssize_t</code></b></font></large> ... sizes of read/written blocks
<ul>
<li> like <large><code>size_t</code></large>, but signed to allow for error values
</ul>
<li> <large><font color="#008800"><b><code>struct stat</code></b></font></large> ... file system object metadata
<ul>
<li> stores information about file, but stores no content
<li> requires <large><code>ino_t</code></large>, <large><code>dev_t</code></large>, <large><code>time_t</code></large>, <large><code>uid_t</code></large>, ...
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux File System</span></td><td align='right'><small>15/143</small></td></tr></table>
<p>
Metadata for file system objects is stored in <em>inodes</em>
<ul>
<li> physical location on storage device of file data
<li> file type <small>(regular file, directory, ...)</small>, file size <small>(bytes/blocks)</small>
<li> ownership, access permissions, timestamps <small>(create/access/update)</small>
</ul>
Each file system volume has a table of inodes in a known location
<p>
Note: an inode does not contain the name of the file
<p>
Access to a file by name requires a <em>directory</em>
<ul>
<li> where a directory is effectively a list of (name,inode) pairs
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux File System</span></td><td align='right'><small>16/143</small></td></tr></table>
<p>
Access to files by name proceeds as ...
<ul>
<li> open directory and scan for <i>name</i>
<li> if not found, "No such file or directory"
<li> if found as (<i>name</i>,<large><code>ino</code></large>), access inode table <large><code>inodes[ino]</code></large>
<li> collect file metadata and ...
<ul>
<li> check file access permissions given current user/group
<ul>
<li> if don't have required access, "Permission denied"
</ul>
<li> collect information about file's location and size
<li> update access timestamp
</ul>
<li> use physical location to access device and read/write file's data
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File System Operations</span></td><td align='right'><small>17/143</small></td></tr></table>
<p>
Unix presents a uniform interface to file system objects
<ul>
<li> functions/syscalls manipulate objects as a <em>stream of bytes</em>
<li> accessed via a <em>file descriptor</em> <small>(index into a system table)</small>
</ul>
Some common operations:
<ul>
<li> <large><code>open()</code></large> ... open a file system object, returning a file descriptor
<li> <large><code>close()</code></large> ... stop using a file descriptor
<li> <large><code>read()</code></large> ... read some bytes into a buffer from a file descriptor
<li> <large><code>write()</code></large> ... write some bytes from a buffer to a file descriptor
<li> <large><code>lseek()</code></large> ... move to a specified offset within a file
<li> <large><code>stat()</code></large> ... get meta-data about a file system object
<li> <large><code>mount()</code></large> ... place a filesystem on a device
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'><large><code>open()</code></large> / <large><code>close()</code></large></span></td><td align='right'><small>18/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int open(char *</code></b></font></large><i>Path</i><large><font color="#008800"><b><code>, int</code></b></font></large> <i>Flags</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> attempt to open an object at <i>Path</i>, according to <i>Flags</i>
<li> flags (defined in <large><code>&lt;fcntl.h&gt;</code></large>)
<ul>
<li> <large><code>O_RDONLY</code></large> ... open object for reading
<li> <large><code>O_WRONLY</code></large> ... open object for writing
<li> <large><code>O_APPEND</code></large> ... open object for writing at end
<li> <large><code>O_RDWR</code></large> ... open object for reading and writing
<li> <large><code>O_CREAT</code></large> ... create object if doesn't exist
</ul>
<li> flags can be combined e.g. <large><code>(O_WRONLY|O_CREAT)</code></large>
<li> if successful, return file descriptor <small>(small +ve <large><code>int</code></large>)</small>
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... <large><code>open()</code></large> / <large><code>close()</code></large></span></td><td align='right'><small>19/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int close(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> attempt to release an open file descriptor
<li> if this is the last reference to object, release its resources
<li> if successful, return 0
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
</ul>
Could be unsuccessful if <i>FileDesc</i> is not an open file descriptor
<p>
<small>
An aside: removing an object e.g. via <large><code>rm</code></large>
<ul>
<li> removes the object's entry from a directory
<li> but the inode and data persist until
<ul>
<li> all processes accessing the object <large><code>close()</code></large> their handle
<li> all references to the inode from other directories are removed
</ul>
<li> after this, the inode and the blocks on storage device are recycled
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... <large><code>open()</code></large> / <large><code>close()</code></large></span></td><td align='right'><small>20/143</small></td></tr></table>
<p>
Example using <large><code>open()</code></large> and <large><code>close()</code></large>
<p><pre>
<comment>// count lines</comment>
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;error.h&gt;
#include &lt;errno.h&gt;

char buf[1000];  int n, nl = 0;
int fd = open("myFile", O_RDONLY);
if (fd < 0)
   error(errno,errno,"Can't open %s","myFile");
while ((n = read(fd, buf, 1000)) > 0) {
   for (int i = 0; i < n; i++)
      if (buf[i] = '\n') nl++;
}
close(fd);
...
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'> <large><code>read()</code></large> / <large><code>write()</code></large></span></td><td align='right'><small>21/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>ssize_t read(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>, void *</code></b></font></large><i>Buffer</i><large><font color="#008800"><b><code>, size_t</code></b></font></large> <i>Count</i><large><font color="#008800"><b><code>)</code></b></font></large>
<p>
<ul>
<li> attempt to read <i>Count</i> bytes from <i>FileDesc</i> into <i>Buffer</i>
<li> if "successful", return number of bytes actually read (<i>NRead</i>)
<li> if currently positioned at end of file, return 0
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
<li> does not check whether <i>Buffer</i> contains enough space
<li> advances the file offset by <i>NRead</i>
<li> does not treat <large><code>'\n'</code></large> as special
</ul>
<p>
<br>
<small>
Once a file is <large><code>open()</code></large>'d ...
<ul>
<li> the "current position" in the file is maintained as part of the fd entry
<li> the "current position" is modified by <large><code>read()</code></large>, <large><code>write()</code></large> and <large><code>lseek()</code></large>
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  <large><code>read()</code></large> / <large><code>write()</code></large></span></td><td align='right'><small>22/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>ssize_t write(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>, void *</code></b></font></large><i>Buffer</i><large><font color="#008800"><b><code>, size_t</code></b></font></large> <i>Count</i><large><font color="#008800"><b><code>)</code></b></font></large>
<p>
<ul>
<li> attempt to write <i>Count</i> bytes from <i>Buffer</i> onto <i>FileDesc</i>
<li> if "successful", return number of bytes actually written (<i>NWritten</i>)
<li> if unsuccessful, return -1 and set <large><code>errno</code></large>
<li> does not check whether <i>Buffer</i> has <i>Count</i> bytes of data
<li> advances the file offset by <i>NWritten</i> bytes
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/write-small.png]" src="Pics/opsys/write-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  <large><code>read()</code></large> / <large><code>write()</code></large></span></td><td align='right'><small>23/143</small></td></tr></table>
<p>
Functions from <large><code>stdio.h</code></large> tend to be <large><code>char</code></large>-oriented
<p>
File-descriptor-based system calls deal with byte sequences
<ul>
<li> bytes can be interpreted as <large><code>char</code></large>, <large><code>int</code></large>, <large><code>struct</code></large>, etc
<li> so, many kinds of objects can be <large><code>read()</code></large> or <large><code>write()</code></large> <font color='#CC0000'>**</font>
</ul>
Allows programmers to manipulate files of data items, e.g.
<ul>
<li> list of <large><code>double</code></large> values read from sensor device
<li> collection of <large><code>Student</code></large> records
</ul>
<p><br>
<small>
<font color='#CC0000'>**</font> you cannot save/restore pointer values using <large><code>write()</code></large>/<large><code>read()</code></large>
<ul>
<li> because they refer to memory addresses within a process instance
<li> and a different process instance might already have used those addresses
</ul>
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  <large><code>read()</code></large> / <large><code>write()</code></large></span></td><td align='right'><small>24/143</small></td></tr></table>
<p>
Files of <i>records</i> can be produced by
<ul>
<li> either, <large><code>write()</code></large>ing chunks of bytes from <large><code>struct</code></large> objects
<li> or, printing formatted text representation of <large><code>struct</code></large> data
</ul>
The latter approach is a form of <em>serialisation</em>
<p>
For the <large><code>write()</code></large> approach:
<ul>
<li> no need to worry about formatting issues
<li> writes entire structure, even if string buffers half empty
<li> can <large><code>lseek()</code></large> to <i>i<sup>th</i> struct via <i>i*sizeof(StructType)</i>
</ul>
For the printing approach:
<ul>
<li> produces files that are human-readable
<li> only uses as many bytes as required from string buffers
<li> can access structures only sequentially <small>(unless using padding)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  <large><code>read()</code></large> / <large><code>write()</code></large></span></td><td align='right'><small>25/143</small></td></tr></table>
<p>
Example of <large><code>write()</code></large>ing records vs <large><code>printf()</code></large>ing records
<p><pre>
typedef struct _student {
    int id; char name[99]; float wam;
} Student;
int infd, outfd; <comment>// file descriptors</comment>
FILE *inf, *outf; <comment>// file pointers</comment>

Student stu;  <comment>... set values in stu.id, etc ...</comment>

<font color='#009900'>write</font>(outfd, &stu, sizeof(struct _student));
  <comment>vs</comment>
<font color='#009900'>fprintf</font>(outf, "%d:%s:%f\n",
             stu.id, stu.name, stu.wam);

<font color='#009900'>read</font>(infd, &stu, sizeof(Student));
  <comment>vs</comment>
<font color='#009900'>fscanf</font>(inf, "%d:[^:]:%f\n", <comment>// maybe?</comment>
            &(stu.id), &(stu.name), &(stu.wam));
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'> <large><code>seek()</code></large></span></td><td align='right'><small>26/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>off_t lseek(int</code></b></font></large> <i>FileDesc</i><large><font color="#008800"><b><code>, off_t</code></b></font></large> <i>Offset</i><large><font color="#008800"><b><code>, int</code></b></font></large> <i>Whence</i><large><font color="#008800"><b><code>)</code></b></font></large>
<p>
<ul>
<li> set the "current position" of the <i>FileDesc</i>
<li> <i>Offset</i> is in units of bytes, and can be negative
<li> <i>Whence</i> can be one of ...
<ul>
<li> <large><code>SEEK_SET</code></large> ... set file position to <i>Offset</i> from start of file
<li> <large><code>SEEK_CUR</code></large> ... set file position to <i>Offset</i> from current position
<li> <large><code>SEEK_END</code></large> ... set file position to <i>Offset</i> from end of file
</ul>
<li> seeking beyond end of file leaves a gap which reads as 0's
<li> seeking back beyond start of file sets position to start of file
</ul>
<br>
Example: &nbsp;<large><code>lseek(fd, 0, SEEK_END);</code></large>  &nbsp;&nbsp; <small>(move to end of file)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>...  <large><code>seek()</code></large></span></td><td align='right'><small>27/143</small></td></tr></table>
<p>
Example:
<p><pre>
<comment>// move around the file</comment>
#include &lt;unistd.h&gt;
...
<comment>... assume fd is file desc open for reading ...</comment>
lseek(fd, 0, SEEK_SET);  <comment>// go to start of file</comment>
lseek(fd, 0, SEEK_END);  <comment>// go to end of file</comment>
lseek(fd, -20, SEEK_CUR);  <comment>// go back 20 bytes</comment>
lseek(fd, 100, SEEK_SET);  <comment>// go to 100 bytes from start</comment>
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'> <large><code>stat()</code></large></span></td><td align='right'><small>28/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int stat(char *</code></b></font></large><i>FileName</i><large><font color="#008800"><b><code>, struct stat *</code></b></font></large><i>StatBuf</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> stores meta-data associated with <i>FileName</i> into <i>StatBuf</i>
<li> information includes
<ul>
<li> inode number, file type + access mode, owner, group
<li> size in bytes, storage block size, allocated blocks
<li> time of last access/modification/status-change
</ul>
<li> returns -1 and sets <large><code>errno</code></large> if meta-data not accessible
<li> if <large><code>FileName</code></large> is a symbolic link, returns info on referenced file
</ul>
<large><font color="#008800"><b><code>int fstat(int </code></b></font></large><i>FileDesc</i><large><font color="#008800"><b><code>, struct stat *</code></b></font></large><i>StatBuf</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> same as <large><code>stat()</code></large> but gets data via an open file descriptor
</ul>
<large><font color="#008800"><b><code>int lstat(char *</code></b></font></large><i>FileName</i><large><font color="#008800"><b><code>, struct stat *</code></b></font></large><i>StatBuf</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> same as <large><code>stat()</code></large> but doesn't follow symbolic links
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Links</span></td><td align='right'><small>29/143</small></td></tr></table>
<p>
File system <em>links</em> allow multiple paths to access the same data
<p>
Hard links
<ul>
<li> multiple directory entries referencing the same inode
<li> the two entries must be on the same filesystem
</ul>
Symbolic links (symlinks)
<ul>
<li> a file containing the path name of another file
<li> opening the symlink opens the file being referenced
</ul>
Example:
<p><pre>
-rw-r----- 2 cs1521 46 Sep 10 22:28 fileA
-rw-r----- 2 cs1521 46 Sep 10 22:28 fileB
lrwxrwxrwx 1 cs1521  5 Sep 10 22:29 fileC -> fileA
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Links</span></td><td align='right'><small>30/143</small></td></tr></table>
<p>
File <large><code>stat</code></large> structure:
<p><pre>
struct stat {
   dev_t     st_dev;     <comment>// ID of device containing file</comment>
   ino_t     st_ino;     <comment>// inode number</comment>
   mode_t    st_mode;    <comment>// file type + permissions</comment>
   nlink_t   st_nlink;   <comment>// number of hard links</comment>
   uid_t     st_uid;     <comment>// user ID of owner</comment>
   gid_t     st_gid;     <comment>// group ID of owner</comment>
   dev_t     st_rdev;    <comment>// device ID (if special file)</comment>
   off_t     st_size;    <comment>// total size, in bytes</comment>
   blksize_t st_blksize; <comment>// blocksize for file system I/O</comment>
   blkcnt_t  st_blocks;  <comment>// number of 512B blocks allocated</comment>
   time_t    st_atime;   <comment>// time of last access</comment>
   time_t    st_mtime;   <comment>// time of last modification</comment>
   time_t    st_ctime;   <comment>// time of last status change</comment>
};
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Links</span></td><td align='right'><small>31/143</small></td></tr></table>
<p>
The <large><code>st_mode</code></large> is a bit-string containing some of:
<p><pre><small>
S_IFLNK    0120000   symbolic link
S_IFREG    0100000   regular file
S_IFBLK    0060000   block device
S_IFDIR    0040000   directory
S_IFCHR    0020000   character device
S_IFIFO    0010000   FIFO

S_IRUSR    0000400   owner has read permission
S_IWUSR    0000200   owner has write permission
S_IXUSR    0000100   owner has execute permission

S_IRGRP    0000040   group has read permission
S_IWGRP    0000020   group has write permission
S_IXGRP    0000010   group has execute permission

S_IROTH    0000004   others have read permission
S_IWOTH    0000002   others have write permission
S_IXOTH    0000001   others have execute permission
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Links</span></td><td align='right'><small>32/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mkdir(char *</code></b></font></large><i>PathName</i><large><font color="#008800"><b><code>, mode_t</code></b></font></large> <i>Mode</i><large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> create a new directory called <i>PathName</i> with mode <i>Mode</i>
<li> if <i>PathName</i> is e.g. <large><code>a/b/c/d</code></large>
<ul>
<li> all of the directories <large><code>a</code></large>, <large><code>b</code></large> and <large><code>c</code></large> must exist
<li> directory <large><code>c</code></large> must be writeable to the caller
<li> directory <large><code>d</code></large> must not already exist
</ul>
<li> the new directory contains two initial entries
<ul>
<li> <large><font color="#008800"><b><code>.</code></b></font></large> is a reference to itself
<li> <large><font color="#008800"><b><code>..</code></b></font></large> is a reference to its parent directory
</ul>
<li> returns 0 if successful, returns -1 and sets <large><code>errno</code></large> otherwise
</ul>
<br>
Example: &nbsp;<large><code>mkdir("newDir", 0755);</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Links</span></td><td align='right'><small>33/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int fsync(int</code></b></font></large> <i>FileDesc</i><large><font color="#008800"><b><code>)</code></b></font></large> 
<ul>
<li> ensure that data associated with <i>FileDesc</i> is written to storage
</ul>
<br>
Unix/Linux makes heavy use of buffering
<ul>
<li> data "written" to a file is initially stored in memory buffers
<li> eventually, it makes its way onto permanent storage device
<li> <large><code>fsync()</code></large> forces this to happen <i>now</i>
</ul>
<br>
Writing to permanent storage is typically an expensive operation
<ul>
<li> <large><code>fsync()</code></large> is normally called just once at process exit
</ul>
<br>
<small>
Note also: <large><code>fflush()</code></large> forces stdio buffers to be copied to kernel buffers
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Links</span></td><td align='right'><small>34/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int mount(char *</code></b></font></large><i>Source</i><large><font color="#008800"><b><code>, char *</code></b></font></large><i>Target</i><large><font color="#008800"><b><code>,
char *</code></b></font></large><i>FileSysType</i><large><font color="#008800"><b><code>, <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
unsigned long</code></b></font></large> <i>Flags</i><large><font color="#008800"><b><code>, void *</code></b></font></large>data<large><font color="#008800"><b><code>)</code></b></font></large>
<ul>
<li> file systems normally exist on permanent storage devices
<li> <large><code>mount</code></large> attaches a file system to a specific location in the file hierarchy
<li> <i>Source</i> is often a storage device (e.g. <large><code>/dev/disk</code></large>)
<li> <i>Source</i> contains a file system (inode table, data chunks)
<li> <i>Target</i> (aka <em>mount point</em>) is a path in the file hierarchy
<li> <i>FileSysType</i> specifies a particular layout/drivers
<li> <i>Flags</i> specify various properties of the filesys <small>(e.g. read-only)</small>
</ul>
<br>
Example: &nbsp;<large><code>mount("/dev/disk5","/usr","ext3",MS_RDONLY,...)</code></large>
<p>
<small>(use <large><code>disk5</code></large> to hold the <large><code>/usr</code></large> file system as read-only ext3-type)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>File System Summary</span></td><td align='right'><small>35/143</small></td></tr></table>
<p>
Operating systems provide a <em>file system</em>
<ul>
<li> as an abstraction over physical storage devices (e.g. disks)
<li> providing named access to chunks of related data (files)
<li> providing access (sequential/random) to the contents of files
<li> allowing files to be arranged in a hierarchy of directories
<li> providing control over access to files and directories
<li> managing other meta-data associated with files <small>(size, location, ...)</small>
</ul>
<br>
Operating systems also manage other resources
<ul>
<li> memory, &nbsp;processes, &nbsp;processor time, &nbsp;i/o devices, &nbsp;networking, ...
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Memory Management</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory</span></td><td align='right'><small>37/143</small></td></tr></table>
<p>
Systems typically contain 4-16GB of volatile RAM
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware2-small.png]" src="Pics/opsys/hardware2-small.png">
</div><p>
Plus other smaller faster cache memory
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Processes</span></td><td align='right'><small>38/143</small></td></tr></table>
<p>
A <em>process</em> is an active computation, consisting of
<ul>
<li> RAM: code (read-only), data (read/write)
<li> Registers: program counter (PC) and other registers
<li> other management info, discussed later
</ul>
Multiple processes can be <em>active</em> simulataneously
<ul>
<li> typically not all loaded in RAM at once
<li> processes can be suspended (waiting)
<li> restoring a process: load code, data, registers
</ul>
Each process wants a view that it is the only one on the system
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory Management</span></td><td align='right'><small>39/143</small></td></tr></table>
<p>
Operating system provides a view of memory for individual processes
<p><div class='center'>
<img alt="[Diagram:Pics/memory/regions-small.png]" src="Pics/memory/regions-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>40/143</small></td></tr></table>
<p>
On a system with e.g. 1 CPU, 1 memory and 100's of processes
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-horde-small.png]" src="Pics/opsys/process-horde-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>41/143</small></td></tr></table>
<p>
The good-old-days ... one process/computation at a time
<ul>
<li> the process can use the entire memory
<li> addresses within process code are absolute
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/one-process-small.png]" src="Pics/opsys/one-process-small.png">
</div><p>
Or, if the process did not need the entire memory
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/one-small-process-small.png]" src="Pics/opsys/one-small-process-small.png">
</div><p>
Easy to implement by initialising <large><code>$sp</code></large> to <large><code>psize-4</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>42/143</small></td></tr></table>
<p>
Two processes loaded into memory at once
<ul>
<li> addreses in proc1 are absolute
<li> <b>all</b> addresses in proc2 need to be interpreted relative to <large><code>p1size</code></large>
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/two-process-small.png]" src="Pics/opsys/two-process-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>43/143</small></td></tr></table>
<p>
When <large><code>proc1</code></large> is loaded ...
<ul>
<li> copy code+data to memory, starting at address 0
<li> set stack pointer to <large><code>p1size-4</code></large>
</ul>
How to sort out <large><code>proc2</code></large> addresses? <small>(which assumes start addr = 0)</small>
<ul>
<li> "fix" them when process code+data is loaded
<ul>
<li> replace each address in code by <i>addr</i>+<large><code>p1size</code></large>
</ul>
<li> "map" addresses during execution
<ul>
<li> after a memory address is computed in machine code
<li> incremement it by <large><code>p1size</code></large> before accessing memory
<li> requires extra hardware <small>(holding <large><code>proc2</code></large>'s start address)</small>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>44/143</small></td></tr></table>
<p>
Consider a scenario with multiple processes loaded in memory:
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process-small.png]" src="Pics/opsys/multi-process-small.png">
</div><p>
If we do on-the-fly address mapping, we need to ...
<ul>
<li> remember <i>base</i> address for each process (process table)
<li> when process (re)starts, load <i>base</i> into mapping hardware
<li> interpret every address <i>addr</i> in program as <i>base</i>+<i>addr</i>
</ul>
Each process sees its own address space as [0 .. psize-1]
<ul>
<li> process can be loaded anywhere in memory without change
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>45/143</small></td></tr></table>
<p>
Consider the same scenario, but now we want to add a new process
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process2-small.png]" src="Pics/opsys/multi-process2-small.png">
</div><p>
The new process doesn't fit in any of the unused slots
<p>
Could move some process to make a single large slot
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process3-small.png]" src="Pics/opsys/multi-process3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>46/143</small></td></tr></table>
<p>
Alternative strategy: split new process memory over two regions
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process2-small.png]" src="Pics/opsys/multi-process2-small.png">
</div><p>
<p>
becomes
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/multi-process4-small.png]" src="Pics/opsys/multi-process4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>47/143</small></td></tr></table>
<p>
Implications for splitting process memory across physical memory
<ul>
<li> each chunk of process address space has its own <i>base</i>
<li> each chunk of process address space has its own <i>size</i>
<li> each chunk of process address space has its own <i>mem</i>ory location
</ul>
Need a table of process/address information to manage this, e.g.
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/proc-table-small.png]" src="Pics/opsys/proc-table-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>48/143</small></td></tr></table>
<p>
Under this scheme, address mapping calculation is complicated
</ul>
<p><pre>
Address processToPhysical(pid, addr)
{
   Chunk chunks[] = getChunkInfo(pid);
   for (int i = 0; i < nChunks(pid); i++) {
      Chunk *c = &chunks[i];
      if (addr >= c->base && addr < c->base+c->size)
         break;
   }
   uint offset = addr - c->base;
   return c->mem + offset;
}
</pre><p>
The above mapping <i>must</i> be done in hardware to be efficient.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>49/143</small></td></tr></table>
<p>
Address mapping would be simpler if all chunks were same size
<ul>
<li> call each chunk of address space a <em>page</em>
<li> all pages are the same size <i>P</i> (<i>PageSize</i> )
<li> process memory is spread across &nbsp;&lceil;<i>ProcSize</i>/<i>P</i> &rceil;&nbsp; pages
<li> page <i>i</i> has addresses <i>A</i> in range &nbsp;<i>i*P</i> &le; A &lt; <i>(i+1)*P</i>
</ul>
Also leads to a simpler address mapping table:
<ul>
<li> each process has an array of page entries
<li> each page entry contains start address of one chunk
<li> can compute index of relevant page entry by (<i>A / P</i> )
<li> can compute offset within page by (<i>A % P</i> )
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management</span></td><td align='right'><small>50/143</small></td></tr></table>
<p>
Example of simple mapping table:
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/proc-table2-small.png]" src="Pics/opsys/proc-table2-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory Management Review</span></td><td align='right'><small>51/143</small></td></tr></table>
<p>
Reminder: process addresses &harr; physical addresses
<ul>
<li> process has (virtual) address space 0..N-1 bytes
<li> memory has (physical) address space 0..M-1 bytes
<li> both address spaces partitioned in P byte pages
<li> process address space contains K = &lceil;N/P&rceil; <em>pages</em>
<li> memory address space has L = &lceil;M/P&rceil; <em>frames</em>
</ul>
Mapping:
<ul>
<li> takes address (Vaddr) in process address space
<li> returns address (Paddr) in memory address space
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Address Mapping</span></td><td align='right'><small>52/143</small></td></tr></table>
<p>
Mapping from process address to physical address:
<p><pre>
Address processToPhysical(pid, Vaddr)
{
   PageInfo pages[] = getPageInfo(pid);
   uint pageno = Vaddr / PageSize;  <comment><tiny>// int div</tiny></comment>
   uint offset = Vaddr % PageSize;
   return pages[pageno].mem + offset;
}
</pre><p>
<br>
Computation of <large><code>pageno</code></large>,<large><code>offset</code></large> is efficient if <i>Pagesize == 2<sup>n</sup></i>
<p><br>
Note that we assume <large><code>PageInfo</code></large> entries with more information ....
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Address Mapping</span></td><td align='right'><small>53/143</small></td></tr></table>
<p>
Page table entries typically do not store physical address
<ul>
<li> to save space, just store frame number F
<li> compute physical address via (P * F + Offset)
</ul>
If P == 2<sup>n</sup>, then address mapping becomes
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/addr-mapping-small.png]" src="Pics/opsys/addr-mapping-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Virtual Memory</span></td><td align='right'><small>54/143</small></td></tr></table>
<p>
A side-effect of this type of virtual&rarr;physical address mapping
<ul>
<li> don't need to load all of process's pages up-front
<li> start with a small memory "footprint" <small>(e.g. <large><code>main</code></large> + stack top)</small>
<li> load new process address pages into memory <i>as needed</i>
<li> grow up to the size of the (available) physical memory
</ul>
The strategy of ...
<ul>
<li> dividing process memory space into fixed-size pages
<li> on-demand loading of process pages into physical memory
</ul>
is called <em>virtual memory</em>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>55/143</small></td></tr></table>
<p>
Pages/frames are typically 512B .. 8KB in size
<p>
In a 4GB memory, would have &cong;4 million &times; 1KB frames
<p>
Each frame can hold one page of process address space
<p>
Leads to a memory layout like this <small>(with <i>L</i> total pages of physical memory):</small>
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/all-pages-small.png]" src="Pics/opsys/all-pages-small.png">
</div><p>
When a process completes, all of its frames are released for re-use
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>56/143</small></td></tr></table>
<p>
How to arrange mapping process address &rarr; physical address?
<p>
Consider a per-process page table, e.g.
<ul>
<li> each page table entry (PTE) contains
<ul>
<li> page status ... Loaded, IsModified, NotLoaded
<li> frame number of page (if Loaded)
<li> ... maybe others ... <small>(e.g. last accessed time)</small>
</ul>
<li> we need <big>&lceil;</big><i>ProcSize</i> /<i>PageSize</i><big>&rceil;</big> entries in this table
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>57/143</small></td></tr></table>
<p>
Example of page table for one process:
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-pages2-small.png]" src="Pics/opsys/process-pages2-small.png">
</div><p>
<br>
Timestamps show when page was loaded.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>58/143</small></td></tr></table>
<p>
Virtual address to physical address mapping <small>(more detail)</small>:
<p><pre><small>
typedef struct {char status, uint frameNo, ...} PageData;

PageData *AllPageTables[maxProc];
    <comment>// one entry for each process</comment>

Address processToPhysical(pid, Vaddr)
{
   PageData *PageTable = AllPageTables[pid];
   uint pageno = PageNumberFrom(Vaddr);
   uint offset = OffsetFrom(Vaddr);
   if (PageTable[pageno].status != Loaded) {
      <comment>// load page into free frame</comment>
      <comment>// set PageTable[pageno]</comment>
   }
   uint frame = PageTable[pageno].frameNo;
   return frame * P + offset;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>An Aside: Working Sets</span></td><td align='right'><small>59/143</small></td></tr></table>
<p>
Consider a new process commencing execution ...
<ul>
<li> initially has zero pages loaded
<li> load page containing code for <large><code>main()</code></large>
<li> load page for <large><code>main()</code></large>'s stack frame
<li> load other pages when process references address within page
</ul>
Do we ever need to load all process pages at once?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... An Aside: Working Sets</span></td><td align='right'><small>60/143</small></td></tr></table>
<p>
From observations of running programs ...
<ul>
<li> in any given window of time,<br>
	a process is likely to access only a small subset of its pages
</ul>
Known as the <em>working set</em> model &nbsp; <small>(cf <em>locality of reference</em>)</small>
<p>
Only need to hold, at a given time, the process's working set of pages
<p>
Implications:
<ul>
<li> if each process has a relatively small working set,<br>
	can hold pages for many active processes in memory at same time
<li> if only need to hold some of process's pages in memory,<br>
	process address space can be larger than physical memory
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Virtual Memory</span></td><td align='right'><small>61/143</small></td></tr></table>
<p>
We say that we "load" pages into physical memory
<p>
But where are they loaded from?
<ul>
<li> code is loaded from the executable file stored on disk
<li> global data is also initially loaded from here
<li> dynamic (heap, stack) data is created in memory
</ul>
<br>
Consider a process whose address space exceeds physical memory
<p>
The pages of dynamic data not currently in use
<ul>
<li> may need to be removed temporarily from memory &nbsp;<small>(see later)</small>
<li> thus would also be saved on disk and restored from disk
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>62/143</small></td></tr></table>
<p>
We can imagine that a process's address space ...
<ul>
<li> exists on disk for the duration of the process's execution
<li> and only some parts of it are in memory at any given time
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-pages-small.png]" src="Pics/opsys/process-pages-small.png">
</div><p>
<p>
Transferring pages between disk&harr;memory is <b>very</b> expensive
<ul>
<li> need to ensure minimal reading from / writing to disk
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>63/143</small></td></tr></table>
<p>
Per-process page table, allowing for some pages to be not loaded
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/page-table3-small.png]" src="Pics/opsys/page-table3-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory</span></td><td align='right'><small>64/143</small></td></tr></table>
<p>
Recall the address mapping process with per-process page tables
<p><pre><small>
Address processToPhysical(pid, Vaddr)
{
   PageData *PageTable = AllPageTables[pid];
   uint pageno = PageNumberFrom(Vaddr);
   uint offset = OffsetFrom(Vaddr);
   if (PageTable[pageno].status != Loaded) {
      <comment>// load page into free frame</comment>
      <comment>// set PageTable[pageno]</comment>
   }
   uint frame = PageTable[pageno].frameNo;
   return frame * P + offset;
}
</small></pre><p>
What to do if the page is not loaded?
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Page Faults</span></td><td align='right'><small>65/143</small></td></tr></table>
<p>
Requesting a non-loaded page generates a <em>page fault</em>.
<p>
One approach to handling a page fault ...
<ul>
<li> find a free (unused) page frame in memory and use that
</ul>
<p><pre>
   <comment>// load page into a free frame ...</comment>
   else {
      frameno    = getFreeFrame();
      p->frameNo = frameno;
      p->status  = Loaded;
   }
</pre><p>
Assumes that we have a way of quickly identifying free frames
<p>
Commonly handled via a <em>free list</em>
<p>
<small>
Reminder: frames allocated to a process become <i>free</i> when process exits
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Faults</span></td><td align='right'><small>66/143</small></td></tr></table>
<p>
What happens if there are currently no free page frames
<p>
What does <large><code>getFreeFrame()</code></large> do?
<p>
Possibilities:
<ul>
<li> <em>suspend</em> the requesting process until a page is freed
<li> <em>replace</em> one of the currently loaded/used pages
</ul>
Suspending requires the process manager to
<ul>
<li> maintain a (priority) queue of processes waiting for pages
<li> dequeue and schedule the first process on queue when page freed
</ul>
Will discuss process queues further in next section.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Page Replacement</span></td><td align='right'><small>67/143</small></td></tr></table>
<p>
What happens when a page is replaced?
<ul>
<li> if it's been modified since loading, save to disk ** <br>
   <small>(in the disk-based virtual memory space of the running process)</small>
<li> grab its frame number and give it to the requestor
</ul>
How to decide which frame should be replaced?
<ul>
<li> define a "usefulness" measure for each frame
<li> grab the frame with lowest usefulness
   <small>(e.g. priority queue?)</small>
</ul>
<br>
** we need a flag to indicate whether a page is modified
<p><pre>
#define NotLoaded   0x00000000
#define Loaded      0x00000001
#define IsModified  0x00000002
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Replacement</span></td><td align='right'><small>68/143</small></td></tr></table>
<p>
Factors to consider in deciding which page to replace
<ul>
<li> best page is one that won't be used again by its process
<li> prefer pages that are read-only &nbsp;<small>(no need to write to disk)</small>
<li> prefer pages that are unmodified &nbsp;<small>(no need to write to disk)</small>
<li> prefer pages that are used by only one process &nbsp;<small>(see later)</small>
</ul>
OS can't predict whether a page will be required again by its process
<p>
But we do know whether it has been used recently <small>(if we record this)</small>
<p>
Useful heuristic: <em>LRU replacement</em>
<ul>
<li> a page not used recently may not be needed again soon
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Replacement</span></td><td align='right'><small>69/143</small></td></tr></table>
<p>
Factors for choosing best page to replace are <i>heuristic</i>
<p>
What happens if ...
<ul>
<li> we replace a page which is soon used again
<li> this causes us to replace another page
<li> and the second page is soon used again ......
</ul>
<em>Thrashing</em> = constantly swapping pages in and out of memory
<p>
The working set model plus LRU helps avoid <em>thrashing</em>
<ul>
<li> recently used page is likely to be used again soon
<li> not recently used page is unlikely to be used again soon
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Page Replacement</span></td><td align='right'><small>70/143</small></td></tr></table>
<p>
LRU is one replacement strategy. Others include:
<p>
<em>First-in-first-out</em> (FIFO)
<ul>
<li> page frames are entered into a queue when loaded
<li> page replacement uses the frame from the front of the queue
</ul>
<em>Clock sweep</em>
<ul>
<li> uses a reference bit for each frame, updated when page is used
<li> maintains a circular list of allocated frames
<li> uses a "clock hand" which iterates over page frame list
<ul>
<li> skipping and resetting reference bit in all referenced pages
</ul>
<li> page replacement uses first-found unreferenced frame
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Virtual Memory </span></td><td align='right'><small>71/143</small></td></tr></table>
<p>
Page tables (PTs) revisited ...
<ul>
<li> a virtual address space with <i>K</i> pages needs <i>K</i> PT entries
<li> since <i>K</i> may be large, do not want to store whole PT
<li> especially since working set tells us <i>n</i> &ll; <i>K</i> needed at once
</ul>
One possibility: PT with <i>n</i> < <i>K</i> entries and hashing
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/page-table4-small.png]" src="Pics/opsys/page-table4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory </span></td><td align='right'><small>72/143</small></td></tr></table>
<p>
Alternative strategy: multi-level page tables
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/page-table5-small.png]" src="Pics/opsys/page-table5-small.png">
</div><p>
<br>
<small>
Effective because not all pages in virtual address space are required <br>
(e.g. the pages between the top of the heap and the bottom of the stack)
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Virtual Memory </span></td><td align='right'><small>73/143</small></td></tr></table>
<p>
Virtual memory allows sharing of read-only pages (e.g. library code)
<ul>
<li> several processes include same frame in virtual address space
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/shared-pages-small.png]" src="Pics/opsys/shared-pages-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Cache Memory</span></td><td align='right'><small>74/143</small></td></tr></table>
<p>
<em>Cache memory</em> = small*, fast memory* close to CPU
<p>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware3-small.png]" src="Pics/opsys/hardware3-small.png">
</div><p>
<p><br>
Small = MB,  &nbsp; Fast = 5 &times; RAM
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Cache Memory</span></td><td align='right'><small>75/143</small></td></tr></table>
<p>
Cache memory
<ul>
<li> holds parts of RAM that are (hopefully) heavily used
<li> transfers data to/from RAM in blocks (<em>cache blocks</em>)
<li> memory reference hardware first looks in cache
<ul>
<li> if required address is there, use its contents
<li> if not, get it from RAM and put in cache
<li> possibly replacing an existing cache block
</ul>
<li> replacement strategies have similar issues to virtual memory
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory Management Hardware</span></td><td align='right'><small>76/143</small></td></tr></table>
<p>
Address translation is very important/frequent
<ul>
<li> provide specialised hardware (MMU) to do it efficiently
<li> sometimes located on CPU chip, sometimes separate
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware4-small.png]" src="Pics/opsys/hardware4-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory Management Hardware</span></td><td align='right'><small>77/143</small></td></tr></table>
<p>
TLB = translation lookaside buffer
<ul>
<li> lookup table containing (virtual,physical) address pairs
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/TLB-small.png]" src="Pics/opsys/TLB-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Process Management</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Processes</span></td><td align='right'><small>79/143</small></td></tr></table>
<p>
A <em>process</em> is an instance of an executing program
<p>
Multiple processes are "active" simultaneously
<ul>
<li> <em>multi-tasking</em> provided by all modern operating systems
</ul>
The OS provides each process with
<ul>
<li> control-flow independence
<small>
<ul>
<li> each process executes as if the only process running on the machine
</ul>
</small>
<li> private address space
<small>
<ul>
<li> each process has its own address space (M bytes, addressed 0..M-1)
</ul>
</small>
</ul>
Process management is a critical OS functionality
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Processes</span></td><td align='right'><small>80/143</small></td></tr></table>
<p>
Control-flow independence <small>("I am the only process, and I run until I finish")</small>
<p>
In reality, there are multiple processes running on the machine
<ul>
<li> each process uses the CPU until <em>pre-empted</em> or exits
<li> then another process uses the CPU until it too is pre-empted
<li> eventually, the first process will get another run on the CPU
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/processes-small.png]" src="Pics/opsys/processes-small.png">
</div><p>
Overall impression: three programs running simultaneously
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Processes</span></td><td align='right'><small>81/143</small></td></tr></table>
<p>
What can cause a process to be pre-empted?
<ul>
<li> it runs "long enough" and the OS replaces it by a waiting process
<li> it attempts to perform a long-duration task, like i/o
</ul>
On pre-emption ...
<ul>
<li> the process's entire dynamic state must be saved (incl PC)
<li> the process is flagged as temporarily suspended
<li> it is placed on a process (priority) queue for re-start
</ul>
On resuming, the state is restored and the process starts at saved PC
<p><br>
Overall impression: I ran until I finished all my computation
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Process Management</span></td><td align='right'><small>82/143</small></td></tr></table>
<p>
How does the OS manage multiple simultaneous processes?
<p>
<em>Context</em> = collection of information for one process
<ul>
<li> static information: program code and data
<li> dynamic state: heap, stack, registers, program counter
<li> OS-supplied state: environment variables, stdin, stdout
</ul>
<em>Context switch</em>
<ul>
<li> save context for one process
<li> restore context for another process
</ul>
Handled by OS in privileged mode.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process Management</span></td><td align='right'><small>83/143</small></td></tr></table>
<p>
<em>Process control block</em> = where OS records info about each process
<ul>
<li> identifier: unique process ID
<li> status: &nbsp;running, &nbsp;ready, &nbsp;suspended, &nbsp;dead
<li> state: registers (including PC)
<li> privileges: owner, group
<li> if suspended, event being waited for
<li> memory management info: (reference to) page table
<li> accounting: CPU time used, amount of I/O done
<li> I/O: open file descriptors
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Unix/Linux Processes</span></td><td align='right'><small>84/143</small></td></tr></table>
<p>
Environment for processes running on Unix/Linux systems
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/unix-process-env-small.png]" src="Pics/opsys/unix-process-env-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>85/143</small></td></tr></table>
<p>
Unix provides a range of tools for manipulating processes
<p>
Commands:
<ul>
<li> <large><font color="#008800"><b><code>sh</code></b></font></large> ... for creating processes via object-file name
<li> <large><font color="#008800"><b><code>ps</code></b></font></large>, <large><font color="#008800"><b><code>w</code></b></font></large>, <large><font color="#008800"><b><code>top</code></b></font></large> ... show process information
<li> <large><font color="#008800"><b><code>kill</code></b></font></large> ... send a signal to a process
</ul>
System calls:
<ul>
<li> <large><font color="#008800"><b><code>fork()</code></b></font></large> ... create a new child process <small>(copy of current process)</small>
<li> <large><font color="#008800"><b><code>execve()</code></b></font></large> ... convert one process into another
<li> <large><font color="#008800"><b><code>wait()</code></b></font></large> ... wait for state change in child process
<li> <large><font color="#008800"><b><code>kill()</code></b></font></large> ... send a signal to a process
<li> <large><font color="#008800"><b><code>_exit()</code></b></font></large> ... terminate an executing process <small>(after clean up)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>86/143</small></td></tr></table>
<p>
Information associated with processes (PCB):
<ul>
<li> <large><code>pid</code></large> ...process id, unique among current processes
<li> <large><code>ruid</code></large>, <large><code>euid</code></large> ... real and effective user id
<li> <large><code>rgid</code></large>, <large><code>egid</code></large> ... real and effective group id
<li> current working directory
<li> accumulated execution time (user/kernel)
<li> user file descriptor table
<li> information on how to react to signals
<li> pointer to process page table
<li> process state ... running, suspended, asleep, etc.
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Unix/Linux Processes</span></td><td align='right'><small>87/143</small></td></tr></table>
<p>
Process info is split across process table entry and user structure
<p>
<em>Process table</em> = kernel data structure describing all processes
<ul>
<li> memory-resident since very heavily used
<li> contains info as described above for PCB
<li> content of PCB entry critical for scheduler
</ul>
<em>User structure</em> = kernel data structure describing run-time state
<ul>
<li> holds info not needed when process swapped out
<li> e.g. execution state <small>(registers, signal handlers, file descriptors, ...)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Process-related System Calls</span></td><td align='right'><small>88/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>pid_t fork(void)</code></b></font></large>
<ul>
<li> requires &nbsp;<large><code>#include &lt;unistd.h&gt;</code></large>
<li> creates new process by duplicating the calling process
<li> new process is the <em>child</em>, calling process is the <em>parent</em>
<li> child has a different process ID (pid) to the parent
<li> in the child, <large><code>fork()</code></large> returns 0
<li> in the parent, <large><code>fork()</code></large> returns the pid of the child
<li> if the system call fails, <large><code>fork()</code></large> returns -1
<li> child inherits copies of parent's address space and open fd's
</ul>
Typically, the child pid is a small increment over the parent pid
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>89/143</small></td></tr></table>
<p>
Minimal example for <large><code>fork()</code></large>:
<p><pre>
#include &lt;stdio.h&gt;
<font color='#000099'>#include &lt;unistd.h&gt;</font>

int main(void)
{
   pid_t pid;
   pid = <font color='#000099'>fork()</font>;
   if (pid != 0)
      printf("I am the parent.\n");
   else
      printf("I am the child.\n");
   return 0;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>90/143</small></td></tr></table>
<p>
Every process in Unix/Linux is allocated a process ID
<ul>
<li> a +ve integer, unique among currently executing processes
<li> with type <large><font color="#008800"><b><code>pid_t</code></b></font></large> &nbsp; <small>(defined in &lt;unistd.h&gt;)</small>
<li> process 0 is the <em>scheduler</em> &nbsp;<small>(part of kernel)</small>
<li> process 1 is <large><code>init</code></large> &nbsp;<small>(for starting/stopping the system)</small>
<li> low-numbered processes are typically system-related
<li> regular processes have PID in the range 300 .. MaxPid &nbsp;<small>(e.g. 2<sup>16</sup>)</small>
</ul>
Processes are also collected into <em>process groups</em>
<ul>
<li> each group is associated with a unique PGID
<li> groups allow distribution of signals to a set of related processes
<li> one important application: job control &nbsp;(control-Z)
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>91/143</small></td></tr></table>
<p>
Getting information about a process ...
<p>
<large><font color="#008800"><b><code>pid_t getpid()</code></b></font></large>
<ul>
<li> requires &nbsp;<large><code>#include &lt;sys/types.h&gt;</code></large>
<li> returns the process ID of the current process
</ul>
<large><font color="#008800"><b><code>pid_t getppid()</code></b></font></large>
<ul>
<li> requires &nbsp;<large><code>#include &lt;sys/types.h&gt;</code></large>
<li> returns the parent process ID of the current process
</ul>
</ul>
For more details: &nbsp;<large><code>man 2 getpid</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>92/143</small></td></tr></table>
<p>
Processes belong to <em>process groups</em>
<ul>
<li> a signal can be sent to all processes in a process group
</ul>
<large><font color="#008800"><b><code>pid_t getpgid(pid_t pid)</code></b></font></large>
<ul>
<li> returns the process group ID of specified process
<li> if <large><code>pid</code></large> is zero, use get PGID of current process
</ul>
<large><font color="#008800"><b><code>int setpgid(pid_t pid, pid_t pgid)</code></b></font></large>
<ul>
<li> set the process group ID of specified process
</ul>
Both return -1 and set <large><code>errno</code></large> on failure.
<p>
For more details: &nbsp;<large><code>man 2 getpgid</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>93/143</small></td></tr></table>
<p>
Minimal example for <large><code>getpid()</code></large>:
<p><pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
<font color='#000099'>#include &lt;sys/types.h&gt;</font>

int main(void)
{
   pid_t pid;
   pid = fork();
   if (pid != 0)
      printf("I am the parent (%d)\n", <font color='#000099'>getpid()</font>);
   else
      printf("I am the child (%d)\n", <font color='#000099'>getpid()</font>);
   return 0;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>94/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>pid_t waitpid(pid_t pid, int *status, int options)</code></b></font></large>
<ul>
<li> pause current process until process <tt>pid</tt> changes state 
<ul>
<li> where state changes include finishing, stopping, re-starting, ...
</ul>
<li> ensures that child resources are released on exit
<li> special values for <large><code>pid</code></large> ...
<ul>
<li> if <large><code>pid</code></large> = -1, wait on any child process
<li> if <large><code>pid</code></large> = 0, wait on any child in process group
<li> if <large><code>pid</code></large> &gt; 0, wait on the specified process
</ul>
</ul>
<large><font color="#008800"><b><code>pid_t wait(int *status)</code></b></font></large>
<ul>
<li> equivalent to <large><code>waitpid(-1, &status, 0)</code></large>
<li> pauses until one of the child processes terminates
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>95/143</small></td></tr></table>
<p>
More on <large><font color="#008800"><b><code>waitpid(pid, &status, options)</code></b></font></large>
<ul>
<li> <large><code>status</code></large> is set to hold info about <large><code>pid</code></large>
<ul>
<li> e.g. exit status if <large><code>pid</code></large> terminated
<li> macros allow precise determination of state change <br>
	<small>(e.g. <large><code>WIFEXITED(</code></large><i>status</i><large><code>)</code></large>, &nbsp; <large><code>WCOREDUMP(</code></large><i>status</i><large><code>)</code></large>)</small>
</ul>
<li> <large><code>options</code></large> provide variations in <large><code>waitpid()</code></large> behaviour
<ul>
<li> default: wait for child process to terminate
<li> <large><code>WNOHANG</code></large>: return immediately if no child has exited
<li> <large><code>WCONTINUED</code></large>: return if a stopped child has been restarted
</ul>
</ul>
For more information: &nbsp;<large><code>man 2 waitpid</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>96/143</small></td></tr></table>
<p>
Minimal example for <large><code>wait()</code></large>:
<p><pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
<font color='#000099'>#include &lt;sys/wait.h&gt;</font>

int main(void)
{
   pid_t pid;
   pid = fork();
   if (pid != 0) {
      <font color='#000099'>wait(NULL);</font>
      printf("I am the parent.\n");
   }
   else
      printf("I am the child.\n");
   return 0;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>97/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int kill(pid_t <i>ProcID</i>, int <i>SigID</i>)</code></b></font></large>
<ul>
<li> requires &nbsp;<large><code>#include &lt;signal.h&gt;</code></large>
<li> send signal <large><code><i>SigID</i></code></large> to process <large><code><i>ProcID</i></code></large>
<li> various signals <small>(POSIX)</small> e.g.
<ul>
<li> <large><code>SIGHUP</code></large> ... hangup detected on controlling terminal/process
<li> <large><code>SIGINT</code></large> ... interrupt from keyboard (control-C)
<li> <large><code>SIGKILL</code></large> ... kill signal &nbsp; <small>(e.g. <large><code>kill -9</code></large>)</small>
<li> <large><code>SIGILL</code></large> ... illegal instruction
<li> <large><code>SIGFPE</code></large> ... floating point exception <small>(e.g. divide by zero)</small>
<li> <large><code>SIGSEGV</code></large> ... invalid memory reference
<li> <large><code>SIGPIPE</code></large> ... broken pipe <small>(no processes reading from pipe)</small>
</ul>
<li> if successful, return 0; &nbsp; on error, return -1 and set <large><code>errno</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>98/143</small></td></tr></table>
<p>
Minimal example for <large><code>kill()</code></large>:
<p><pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
<font color='#000099'>#include &lt;signal.h&gt;</font>

int main(void)
{
   pid_t pid;
   pid = fork();
   if (pid != 0) {
      printf("I am the parent.\n");
      <font color='#000099'>kill(pid, SIGKILL)</font>;
   }
   else
      printf("I am the child.\n");
   return 0;
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>99/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>void _exit(int status)</code></b></font></large>
<ul>
<li> terminates current process
<li> closes any open file descriptors
<li> a <large><code>SIGCHLD</code></large> signal is sent to parent
<li> returns <large><code>status</code></large> to parent (via <large><code>wait()</code></large>)
<li> any child processes are inherited by scheduler (pid=1)
<li> termination may be delayed waiting for i/o to complete
</ul>
<br>
<small>
On final exit, process's process table and page table entries are removed
</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>100/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>void exit(int status)</code></b></font></large>
<ul>
<li> terminates current process
<li> triggers any functions registered as &nbsp; <large><code>on_exit()</code></large>
<li> flushes stdio buffers; closes open <large><code>FILE *</code></large>'s
<li> then behaves like <large><code>_exit()</code></large>
</ul>
<br>
Related function: &nbsp;<large><font color="#008800"><b><code>void abort(void)</code></b></font></large>
<ul>
<li> generates <large><code>SIGABRT</code></large> signal &nbsp;<small>(normally terminates process)</small>
<li> closes and flushes stdio streams
<li> used by the <large><code>assert()</code></large> macro
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>101/143</small></td></tr></table>
<p>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/misc/zombie-small.jpg]" src="Pics/misc/zombie-small.jpg">
</div><p>
<p>
<div class='center'>
<small>Zombie Process?</small>
<br>
<span style="font-size:12pt">Photo credit: kenny Louie, Flickr.com</span>
</div>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>102/143</small></td></tr></table>
<p>
When a process finishes, sends <large><code>SIGCHLD</code></large> signal to parent
<p>
<em>Zombie process</em> = a process which has exited but signal not handled
<ul>
<li> all processes become zombie until <large><code>SIGCHLD</code></large> handled
<li> parent may be delayed e.g. slow i/o, but usually resolves quickly
<li> bug in parent that ignores <large><code>SIGCHLD</code></large> creates long-term zombies
<li> note that zombies occupy a slot in the process table
</ul>
<em>Orphan process</em> = a process whose parent has exited
<ul>
<li> when parent exits, orphan is assigned pid=1 as its parent
<li> pid=1 always handles <large><code>SIGCHLD</code></large> when process exits
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>103/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int execve(char *<i>Path</i>, char *<i>Argv</i>[], char *<i>Envp</i>[])</code></b></font></large>
<ul>
<li> replaces current process by executing <large><code><i>Path</i></code></large> object
<ul>
<li> <large><code><i>Path</i></code></large> must be an executable, binary or script <small>(starting with <large><code>#!</code></large>)</small>
</ul>
<li> passes arrays of strings to new process
<ul>
<li> both arrays terminated by a <large><code>NULL</code></large> pointer element
<li> <large><code><i>envp</i>[]</code></large> contains strings of the form <large><code>key=value</code></large>
</ul>
<li> much of the state of the original process is lost, e.g.
<ul>
<li> new virtual address space is created, signal handlers reset, ...
</ul>
<li> new process inherits open file descriptors from original process
<li> on error, returns -1 and sets <large><code>errno</code></large>
<li> if successful, does not return
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process-related System Calls</span></td><td align='right'><small>104/143</small></td></tr></table>
<p>
On Unix, processes create new different processes via:
<p><pre>
pid_t pid = fork(); 
if (pid != 0)
   <comment>// parent ...</comment>
   wait(NULL); <comment>// wait for child to complete</comment>
else {
   <comment>// child ...</comment>
   char *cmd = "/x/y/z"; <comment>// name of executable</comment>
   char **args;
   ... <comment>// set up command-line arguments</comment>
   char **env;
   ... <comment>// set up environment varables</comment>

   <font color='#000099'>execve(cmd, args, env)</font>; <comment>// child is transformed</comment>
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Process Control Flow</span></td><td align='right'><small>105/143</small></td></tr></table>
<p>
When a process is executing ...
<ul>
<li> fetch instruction from memory[PC]; &nbsp; PC++
<li> decode and execute instruction
<ul>
<li> if jump-type instruction, PC = new address
<li> if regular instruction, carry out operation
</ul>
<li> repeat above
</ul>
This type of regular control flow is produced by the process
<p>
Regular control flow can be interrupted &rArr; <em>exceptional control flow</em>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process Control Flow</span></td><td align='right'><small>106/143</small></td></tr></table>
<p>
<em>Exceptional events</em> are
<ul>
<li> "unexpected" conditions occuring during program execution
<li> which require some form of immediate action &nbsp;<small>(maybe just quit)</small>
</ul>
<p>
Two types of exceptional events
<ul>
<li> <em>exceptions</em> ... from <font color='#CC0000'>conditions within</font> an executing program
<ul>
<li> often, fatal to continued execution of program
</ul>
<li> <em>interrupts</em> ... from <font color='#CC0000'>events external</font> to the program
<ul>
<li> often, require some action and then execution can continue
</ul>
</ul>
Typically cause a <em>signal</em> to be sent to a process
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process Control Flow</span></td><td align='right'><small>107/143</small></td></tr></table>
<p>
Effect of exceptions/interrupts on control flow
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/exception-small.png]" src="Pics/opsys/exception-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Process Control Flow</span></td><td align='right'><small>108/143</small></td></tr></table>
<p>
<em>System calls</em> typically operate via exceptions (traps)
<ul>
<li> process makes system call (e.g. <large><code>fork()</code></large>)
<li> generates an exception which
<ul>
<li> transfers control to system call handler (in privileged mode)
<li> carries out system-level operations <small>(e.g. modify process table)</small>
<li> then returns control to the process (in user mode)
</ul>
</ul>
Effect is like a normal function call (<large><code>jal</code></large> ... <large><code>jr</code></large>)
<p>
Critical difference is transfer to system space (privileged mode)
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Signals</span></td><td align='right'><small>109/143</small></td></tr></table>
<p>
Signals can be generated from a variety of sources
<ul>
<li> from another process via <large><code>kill()</code></large>
<li> from the operating system <small>(e.g. timer)</small>
<li> from within the process <small>(e.g. system call)</small>
<li> from a fault in the process <small>(e.g. div-by-zero)</small>
<li> from a device <small>(e.g. disk read completes)</small>
</ul>
<br>
Processes can define how they want to handle signals
<ul>
<li> using the <large><font color="#008800"><b><code>signal()</code></b></font></large> library function &nbsp; <small>(simple)</small>
<li> using the <large><font color="#008800"><b><code>sigaction()</code></b></font></large> system call &nbsp; <small>(powerful)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signals</span></td><td align='right'><small>110/143</small></td></tr></table>
<p>
Signals from internal process activity, e.g.
<ul>
<li> <large><code>SIGILL</code></large> ... illegal instruction &nbsp;&nbsp; <small>(Term by default)</small>
<li> <large><code>SIGABRT</code></large> ... generated by <large><code>abort()</code></large> &nbsp;&nbsp; <small>(Core by default)</small>
<li> <large><code>SIGFPE</code></large> ... floating point exception &nbsp;&nbsp; <small>(Core by default)</small>
<li> <large><code>SIGSEGV</code></large> ... invalid memory reference &nbsp;&nbsp; <small>(Core by default)</small>
</ul>
<p>
Signals from external process events, e.g.
<ul>
<li> <large><code>SIGINT</code></large> ... interrupt from keyboard &nbsp;&nbsp; <small>(Term by default)</small>
<li> <large><code>SIGPIPE</code></large> ... broken pipe &nbsp;&nbsp; <small>(Term by default)</small>
<li> <large><code>SIGCHLD</code></large> ... child process stopped or died &nbsp;&nbsp; <small>(Ignored by default)</small>
<li> <large><code>SIGTSTP</code></large> ... stop typed at tty (control-Z) &nbsp;&nbsp; <small>(Stop by default)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signals</span></td><td align='right'><small>111/143</small></td></tr></table>
<p>
Processes can choose to ignore most signals.
<p>
If not ignored, signals can be handled in several default ways
<ul>
<li> Term ... terminate the process
<li> Core ... terminate the process, dump core
<li> Stop ... stop the process
<li> Cont ... continue the process if currently stopped
</ul>
Or you can write your own <em>signal handler</em>
<p>
See &nbsp; <large><code>man 7 signal</code></large> &nbsp; for details of signals and default handling.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Signal Handlers</span></td><td align='right'><small>112/143</small></td></tr></table>
<p>
<em>Signal Handler</em> = a function invoked in response to a signal
<ul>
<li> knows which signal it was invoked by
<li> needs to ensure that invoking signal <small>(at least)</small> is blocked
<li> carries out appropriate action; may return
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/processes/signal-small.png]" src="Pics/processes/signal-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signal Handlers</span></td><td align='right'><small>113/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>SigHnd signal(int <i>SigID</i>, SigHnd <i>Handler</i>)</code></b></font></large>
<ul>
<li> define how to handle a particular signal
<li> requires <large><code>&lt;signal.h&gt;</code></large> &nbsp;&nbsp; <small>(library function, not syscall)</small>
<li> <large><code><i>SigID</i></code></large> is one of the OS-defined signals
<ul>
<li> <small>e.g. <large><code>SIGHUP</code></large>, <large><code>SIGCHLD</code></large>, <large><code>SIGSEGV</code></large>, ... but not <large><code>SIGKILL</code></large>, <large><code>SIGSTOP</code></large></small>
</ul>
<li> <large><code><i>Handler</i></code></large> can be one of ...
<ul>
<li> <large><code>SIG_IGN</code></large> ... ignore signals of type <large><code><i>SigID</i></code></large>
<li> <large><code>SIG_DFL</code></large> ... use default handler for <large><code><i>SigID</i></code></large>
<li> a user-defined function to handle <large><code><i>SigID</i></code></large> signals
</ul>
<li> note: &nbsp;<large><font color="#008800"><b><code>typedef void (*SigHnd)(int);</code></b></font></large>
<li> returns previous value of signal handler, or <large><code>SIG_ERR</code></large>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signal Handlers</span></td><td align='right'><small>114/143</small></td></tr></table>
<p>
How to define and install a signal handler function:
<p><pre><small>
void myHandler(int sigID)
{
   <comment>// we don't normally put</comment>
   <comment>// printf() in a signal handler</comment>
   printf("Caught SIGINT\n");
   exit(0);
}

int main(int argc, char **argv)
{
   if (<font color='#000099'>signal(SIGINT, myHandler)</font> == SIG_ERR) {
      printf("Can't set signal handler\n");
      exit(1);
   }
   sleep(3); <comment>// wait for signal</comment>
   printf("No signal received\n");
   return 0;
}
</small></pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signal Handlers</span></td><td align='right'><small>115/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int sigaction(int <i>sigID</i>,<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;struct sigaction *<i>newAct</i>,<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;struct sigaction *<i>oldAct</i>)</code></b></font></large>
<ul>
<li> <large><code><i>sigID</i></code></large> is one of the OS-defined signals
<ul>
<li> <small>e.g. <large><code>SIGHUP</code></large>, <large><code>SIGCHLD</code></large>, <large><code>SIGSEGV</code></large>, ... but not <large><code>SIGKILL</code></large>, <large><code>SIGSTOP</code></large></small>
</ul>
<li> <large><code><i>newAct</i></code></large> defines how signal should be handled
<li> <large><code><i>oldAct</i></code></large> saves a copy of how signal was handled
<li> if <large><code><i>newAct</i>.sa_handler == SIG_IGN</code></large>, signal is ignored
<li> if <large><code><i>newAct</i>.sa_handler == SIG_DFL</code></large>, default handler is used
<li> on success, returns 0; &nbsp;on error, returns -1 and sets <large><code>errno</code></large>
</ul>
<br>
For much more information: &nbsp;<large><code>man 2 sigaction</code></large>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signal Handlers</span></td><td align='right'><small>116/143</small></td></tr></table>
<p>
Details on <large><font color="#008800"><b><code>struct sigaction</code></b></font></large> ...
<ul>
<li> <large><font color="#008800"><b><code>void (*sa_handler)(int)</code></b></font></large>
<ul>
<li> pointer to a handler function, or <large><code>SIG_IGN</code></large> or <large><code>SIG_DFL</code></large>
</ul>
<li> <large><font color="#008800"><b><code>void (*sa_sigaction)(int, siginfo_t *, void *)</code></b></font></large>
<ul>
<li> pointer to handler function; used if <large><code>SA_SIGINFO</code></large> flag is set
<li> allows more context info to be passed to handler
</ul>
<li> <large><font color="#008800"><b><code>sigset_t sa_mask</code></b></font></large>
<ul>
<li> a mask, where each bit specifies a signal to be blocked
</ul>
<li> <large><font color="#008800"><b><code>int sa_flags</code></b></font></large>
<ul>
<li> flags to modify how signal is treated <br>
&nbsp;&nbsp;&nbsp; <small>(e.g. don't block signal in its own handler)</small>
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Signal Handlers</span></td><td align='right'><small>117/143</small></td></tr></table>
<p>
Details on <large><font color="#008800"><b><code>siginfo_t</code></b></font></large> ...
<ul>
<li> <large><font color="#008800"><b><code>si_signo</code></b></font></large> ... signal being handled
<li> <large><font color="#008800"><b><code>si_errno</code></b></font></large> ... any <large><code>errno</code></large> value associated with signal
<li> <large><font color="#008800"><b><code>si_pid</code></b></font></large> ... process ID of sending process
<li> <large><font color="#008800"><b><code>si_uid</code></b></font></large> ... user ID of owner of sending process
<li> <large><font color="#008800"><b><code>si_status</code></b></font></large> ... exit value for process termination
<li> etc. etc. etc.
</ul>
<br>
For more details: &nbsp;<large><code>bits/types/siginfo_t.h</code></large>&nbsp; <small>(system-dependent)</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Interrupts</span></td><td align='right'><small>118/143</small></td></tr></table>
<p>
<em>Interrupts</em> are signals which
<ul>
<li> cause normal process execution to be suspended
<li> an <em>interrupt handler</em> then carries out tasks related to interrupt
<li> control is then returned to the original process
</ul>
Example (input/output):
<ul>
<li> process requests data from disk <small>(will take 100ms)</small>
<li> if process can do other work not related to requested data
<ul>
<li> keep executing ...
</ul>
<li> when data fetched from disk, process is interrupted
<li> handler places data in a buffer for access by process
<li> in-memory computation resumes
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Interrupts</span></td><td align='right'><small>119/143</small></td></tr></table>
<p>
Example (process pre-emption):
<ul>
<li> process runs for a while (normal control flow)
<li> receives a timer signal from the O/S
<li> process is suspended and its state is saved
<li> process is eventually added to <i>runnable</i> queue
<li> removed from front of queue and state restored
<li> process continues from where it was suspended
</ul>
<br>
Different to first example; has no effect on process state
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Interrupts</span></td><td align='right'><small>120/143</small></td></tr></table>
<p>
Interrupts are frequently associated with input/output
<ul>
<li> in-memory computations are very fast (<i>ns</i>)
<li> input/output operations are very slow (<i>ms</i>)
</ul>
<br>
Can't afford for a process to <i>wait</i> for i/o
<ul>
<li> suspend and place on "waiting for i/o" queue
<li> when i/o complete, move process to "runnable" queue
<li> eventually, process resumes, with new data available
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Exceptions</span></td><td align='right'><small>121/143</small></td></tr></table>
<p>
Above exceptions are low-level, system ones.
<p>
Alternative notion of <em>exceptions</em>:
<ul>
<li> unexpected conditions which arise during computation
<li> unexpected but <i>not</i> unanticipated &nbsp; <small>(robust code)</small>
</ul>
Examples:
<p><pre>
if ((p = malloc(sizeof(<i>Type</i>))) == NULL)
   ...

if (scanf("%d", &n) != 1)
   ...

avg = (n != 0) sum/n : 0;
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Exceptions</span></td><td align='right'><small>122/143</small></td></tr></table>
<p>
Such exceptions require handling in context of computation
<p>
Example:
<ul>
<li> <large><code>create()</code></large> a data structure using multiple <large><code>malloc()</code></large>s
<li> part-way through function, one <large><code>malloc()</code></large> fails
<li> if abandoning <large><code>create()</code></large>, need to clean up previous <large><code>malloc()</code></large>s
<li> if terminating the entire process, no need to clean up
</ul>
<br>
Many programming languages have special mechanisms for this
<p><pre>
try { <i>SomeCode</i> } catch { <i>HandleFailuresInCode</i> }
</pre><p>
C does not have generic exception handling; roll your own.
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Multi-tasking</span></td><td align='right'><small>123/143</small></td></tr></table>
<p>
<em>Multi-tasking</em> = multiple processes are "active" at the same time
<ul>
<li> processes are not necessarily <i>executing</i> simultaneously
<ul>
<li> although this could happen if there are multiple CPUs
</ul>
<li> more likely, have a mixture of processes
<ul>
<li> some are <em>blocked</em> waiting on a signal (e.g. i/o completion)
<li> some are <em>runnable</em> (ready to execute)
<li> one is running (on each CPU)
</ul>
</ul>
Aims to give the appearance of multiple simultaneous processes
<ul>
<li> by switching process after one runs for a defined <em>time slice</em>
<li> after timer counts down, current process is <em>pre-empted</em>
<li> a new process is selected to run by the system <em>scheduler</em>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Process States</span></td><td align='right'><small>124/143</small></td></tr></table>
<p>
How process state changes during execution ...
<p><br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/process-states-small.png]" src="Pics/opsys/process-states-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Scheduling</span></td><td align='right'><small>125/143</small></td></tr></table>
<p>
<em>Scheduling</em> = selecting which process should run next
<ul>
<li> processes are organised into <em>priority queue(s)</em>
<ul>
<li> where "highest" priority process is always at head of queue
</ul>
<li> priority determined by multiple factors, e.g.
<ul>
<li> system processes have higher priority than user processes
<li> longer-running processes might have lower priority
<li> memory-intensive processes might have lower priority
<li> processes can also suggest their own priority
</ul>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Scheduling</span></td><td align='right'><small>126/143</small></td></tr></table>
<p>
Linux process scheduler ...
<ul>
<li> is priority-based &nbsp;<small>(priority queue of processes)</small>
<li> Linux process priorities are values in range -20..139
<li> lower values represent higher priority
<li> factors in determining priority
<ul>
<li> user processes have lower priority than system processes
<li> processes have <em>nice</em>ness value <small>-20 (highest) .. +20 (lowest)</small>
<li> recent CPU time usage by the process
</ul>
<li> scheduler chooses highest priority process from runnable
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Scheduling</span></td><td align='right'><small>127/143</small></td></tr></table>
<p>
Abstract view of the OS scheduler
<p><pre>
onTimerInterrupt()
{
   save state of currently executing process
   newPID = dequeue(runnableProcesses)
   setup state of newPID
   - make process's Page Table active
   - load pages in working set
   - load process's registers
   transfer control to newPID
   - leave kernel mode
   - set PC to saved PC from process
}
</pre><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='section'>Device Management</span></td><td align='right'></td></tr></table>
<p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Device Management</span></td><td align='right'><small>129/143</small></td></tr></table>
<p>
<br>
<p><div class='center'>
<img alt="[Diagram:Pics/opsys/hardware5-small.png]" src="Pics/opsys/hardware5-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>I/O Devices</span></td><td align='right'><small>130/143</small></td></tr></table>
<p>
Input/Output (I/O) devices
<ul>
<li> allow programs to communicate with "the outside" world
<li> have significantly different characteristics to memory-based data
</ul>
Memory-based data
<ul>
<li> fast (ns) random access via (virtual) address
<li> transfer data in units of bytes, halfwords, words
</ul>
Device data
<ul>
<li> much slower (ms) access, random or sequential
<li> often, transfer data in <em>blocks</em> <small>(e.g. 128B, 512B, 4KB, ...)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... I/O Devices</span></td><td align='right'><small>131/143</small></td></tr></table>
<p>
Hard Disk characteristics:
<ul>
<li> address specified by track and sector &nbsp; <small>(s/t &cong; 200, s.size 512B)</small>
<li> access time (move to track + wait for sector + read block)
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/devices/disk-small.png]" src="Pics/devices/disk-small.png">
</div><p>
Typical cost: 10ms seek + 5ms latency + 0.1ms transfer
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... I/O Devices</span></td><td align='right'><small>132/143</small></td></tr></table>
<p>
Solid State Disk (SSD) characteristics:
<ul>
<li> high capacity (GB), high cost, reading faster than writing
<li> pages 512B..4KB, blocks 32..128 pages, R/W page-at-a-time
<li> pages updated by erase then write, &nbsp;limit on #updates
<li> avg read time 11&times;10<sup>-6</sup> sec, &nbsp; avg write time 15&times;10<sup>-6</sup> sec
</ul>
<p><div class='center'>
<img alt="[Diagram:Pics/devices/ssd-small.png]" src="Pics/devices/ssd-small.png">
</div><p>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... I/O Devices</span></td><td align='right'><small>133/143</small></td></tr></table>
<p>
Example: network transfer
<ul>
<li> destination specified by IP address, packet size < 1KB
<li> transfer time includes
<ul>
<li> d<sub>T</sub> transmission delay <small>... time to push data packet onto "the wire"</small>
<li> d<sub>P</sub> propagation delay <small>... time for packet to travel along "the wire"</small>
<li> d<sub>C</sub> processing delay <small>... time to check header, re-route to next node</small>
<li> d<sub>Q</sub> queueing delay <small>... time waiting on node before transmission</small>
<li> need to calculate for N hops, so &nbsp;&cong; N(d<sub>T</sub> + d<sub>P</sub> + d<sub>C</sub> + d<sub>Q</sub>)
</ul>
</ul>
Typical transfer time: 0.5ms (local ethernet), 200ms (internet), ...
<p>
Can check transmission times using the <large><code>ping</code></large> command
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... I/O Devices</span></td><td align='right'><small>134/143</small></td></tr></table>
<p>
Other types of devices ...
<ul>
<li> keyboard ... byte-by-byte input, often line-buffered
<li> screen ... pixel-array output, typically via GPU
<li> mouse ... transmit X,Y movement and button presses
<li> camera ... convert video signal, frame-by-frame, to digital stream
<li> microphone ... convert analog audio signal to digital stream
</ul>
<br>
<div class='center'>
<img src="Pics/misc/keyboard-small.png">
&nbsp;&nbsp; <img src="Pics/misc/monitor-small.png">
&nbsp;&nbsp; <img src="Pics/misc/webcam-small.png">
</div>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Device Drivers</span></td><td align='right'><small>135/143</small></td></tr></table>
<p>
Each type of device has its own unique access protocol
<ul>
<li> special control and data registers
<li> locations (buffers) for data to be read/written
</ul>
<em>Device drivers</em> = code chunks to control an i/o device
<ul>
<li> often written in assembler
<li> are core components of the operating system
</ul>
Typical protocol to manipulate devices
<ul>
<li> send request for operation <small>(e.g. read, write, get status)</small>
<li> receive interrupt when request is completed
</ul>
For more details: see COMP2121 or ELEC2142
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Memory-mapped I/O</span></td><td align='right'><small>136/143</small></td></tr></table>
<p>
<em>Memory-mapped input/output</em>
<ul>
<li> operating system defines special memory address
<li> user programs perform i/o by getting/putting data into memory
<li> virtual memory addresses are associated with
<ul>
<li> data buffers of i/o device
<li> control registers of i/o device
</ul>
</ul>
Advantages:
<ul>
<li> uses existing memory access logic cirucits &rArr; less hardware
<li> can use full range of CPU operations on device memory
<p>
<small>(cf. having limited set of special instructions to manipulate i/o devices)</small>
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Memory-mapped I/O</span></td><td align='right'><small>137/143</small></td></tr></table>
<p>
Example of using memory-mapped I/O.
<p>
Assume memory address of disk device is 0x80000200
<p><pre>
write:
   li  $t0, <i>CodeForWrite</i>
   sw  $t0, 0x80000200
   li  $t0, <i>LogicalBlockAddress</i>
   sw  $t0, 0x80000200
   li  $t0, <i>MemAddressOfData</i>
   sw  $t0, 0x80000200
</pre><p>
Transfers data from memory onto the disk at specified block.
<p><br>
<small>Disclaimer: Above code is not real MIPS/SPIM code. Illustrative only.</small>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Devices on Unix/Linux</span></td><td align='right'><small>138/143</small></td></tr></table>
<p>
Unix treats devices uniformly as byte-streams (like files).
<p>
Devices can be accessed via the file system under <tt>/dev</tt>, e.g.
<ul>
<li> <large><font color="#008800"><b><code>/dev/disk<i>N</i></code></b></font></large> ... (part of) a hard drive
<li> <large><font color="#008800"><b><code>/dev/tty<i>N</i></code></b></font></large> ... a terminal device
<li> <large><font color="#008800"><b><code>/dev/pty<i>N</i></code></b></font></large> ... a pseudo-terminal device
</ul>
Other interesting "devices" in <tt>/dev</tt>
<ul>
<li> <large><font color="#008800"><b><code>/dev/mem</code></b></font></large> ... the physical memory <small>(mostly protected)</small>
<li> <large><font color="#008800"><b><code>/dev/null</code></b></font></large> ... data sink or empty source
<li> <large><font color="#008800"><b><code>/dev/random</code></b></font></large> ... stream of pseudo-random numbers
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Devices on Unix/Linux</span></td><td align='right'><small>139/143</small></td></tr></table>
<p>
Two standard types of "device files" ...
<p>
<em>Character devices</em> &nbsp; <small>(aka character special files)</small>
<ul>
<li> provide <i>unbuffered</i> direct access to hardware devices
<li> programmers interact with device by writing individual bytes
<li> do not necessarily provide byte-by-byte hardware i/o (e.g. disks)
</ul>
<em>Block devices</em> &nbsp; <small>(aka block special files)</small>
<ul>
<li> provide <i>buffered</i> access to hardware devices
<li> programmers interact with device by writing chunks of bytes
<li> data transferred to device via operating system buffers
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Devices on Unix/Linux</span></td><td align='right'><small>140/143</small></td></tr></table>
<p>
<large><font color="#008800"><b><code>int ioctl(int <i>FileDesc</i>, int <i>Request</i>, void *<i>Arg</i>)</code></b></font></large>
<ul>
<li> manipulates parameters of special files <small>(behind open <large><code><i>FileDesc</i></code></large>)</small>
<li> <large><code><i>Request</i></code></large> is a device-specific request code,
<li> <large><code><i>Arg</i></code></large> is either an integer modifier or pointer to data block
<li> requires &nbsp;<large><code>#include &lt;<i>sys</i>/ioctl.h&gt;</code></large>, returns 0 if ok, -1 if error
</ul>
<br>
Example: SCSI disk driver
<ul>
<li> <large><code>HDIO_GETGEO</code></large> ... get disk info in (heads,sectors,cylinders,...)
<li> <large><code>BLKGETSIZE</code></large> ... get device size in sectors
<li> in both cases, <large><code><i>Arg</i></code></large> is a pointer to an appropriate object
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Devices on Unix/Linux</span></td><td align='right'><small>141/143</small></td></tr></table>
<p>
Devices can be manipulated by <large><code>open()</code></large>, <large><code>read()</code></large>, <large><code>write()</code></large> ...
<p>
<large><font color="#008800"><b><code>int open(char *<i>PathName</i>, int <i>Flags</i>)</code></b></font></large>
<ul>
<li> attempts to open device <large><code><i>PathName</i></code></large> in mode <large><code><i>Flags</i></code></large>
<li> <large><code><i>Flags</i></code></large> can specify caching, async i/o, close on <large><code>exec()</code></large>, etc.
<li> returns file descriptor if ok, -1 (plus <large><code>errno</code></large>) if error
</ul>
<large><font color="#008800"><b><code>ssize_t read(int <i>FDesc</i>, void *<i>Buf</i>, size_t <i>Nbytes</i>)</code></b></font></large>
<ul>
<li> attempts to read <large><code><i>Nbytes</i></code></large> of data into <large><code><i>Buf</i></code></large> from <large><code><i>FDesc</i></code></large> 
<li> returns # bytes actually read, 0 at EOF, -1 (plus <large><code>errno</code></large>) if error
</ul>
<large><font color="#008800"><b><code>ssize_t write(int <i>FDesc</i>, void *<i>Buf</i>, size_t <i>Nbytes</i>)</code></b></font></large>
<ul>
<li> attempts to write <large><code><i>Nbytes</i></code></large> of data from <large><code><i>Buf</i></code></large> to <large><code><i>FDesc</i></code></large> 
<li> returns # bytes actually written, -1 (plus <large><code>errno</code></large>) if error
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='heading'>Buffered I/O</span></td><td align='right'><small>142/143</small></td></tr></table>
<p>
Devices are typically very slow compared to CPU speed
<p>
Using a <large><code>read()</code></large> from a device for each byte is inefficient
<ul>
<li> OS uses a collection of buffers to hold data from devices
<li> data is supplied to user programs normally from buffer
<li> sometimes (infrequently?) need to access device
</ul>
Assumption: many buffers, holding the current data working set
<p><br>
Note that <large><code>read()</code></large> accesses data via the OS buffers
<ul>
<li> it is slow because of the context switch each time it is called
</ul>
<p><hr><p>
<table width='100%' cellpadding='0'>
<tr valign='top'><td align='left'><span class='cont'>... Buffered I/O</span></td><td align='right'><small>143/143</small></td></tr></table>
<p>
The standard i/o library (<large><code>stdio.h</code></large>) provides buffered i/o
<ul>
<li> from tty-like devices, generally line buffered
<li> from disk-like devices (files), read/written in <large><code>BUFSIZ</code></large> chunks
<ul>
<li> via OS buffers, so may not need disk access each time
</ul>
<li> buffering hidden from user, who sees <large><code>getchar()</code></large>, <large><code>fgets()</code></large>, etc.
<li> buffer is allocated by <large><code>fopen()</code></large>, removed by <large><code>fclose()</code></large>
</ul>
The <large><code>FILE</code></large> object <small>(normally manipulated via a <large><code>FILE *</code></large> pointer)</small>
<ul>
<li> contains the buffer, <large><code>malloc</code></large>'d on <large><code>fopen()</code></large>
<li> contains current position within the buffer and file
<li> etc. etc.
</ul>
<p><hr><p>
<small><small>Produced: 29 Apr 2018</small></small>
</body>
</html>
