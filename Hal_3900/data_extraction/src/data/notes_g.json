{"grouped":[{"tags":["table"],"items":[{"text":"Parallelism/Concurrency"}]},{"tags":["table"],"items":[{"text":"Concurrency/Parallelism2/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency/Parallelism3/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency/Parallelism4/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency/Parallelism5/59"}]},{"tags":["table"],"items":[{"text":"Creating Concurrency6/59"}]},{"tags":["table"],"items":[{"text":"... Creating Concurrency7/59"}]},{"tags":["table"],"items":[{"text":"Linux/Unix Threads8/59"}]},{"tags":["table"],"items":[{"text":"... Linux/Unix Threads9/59"}]},{"tags":["table"],"items":[{"text":"... Linux/Unix Threads10/59"}]},{"tags":["table"],"items":[{"text":"... Linux/Unix Threads11/59"}]},{"tags":["table"],"items":[{"text":"Concurrency12/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency13/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency14/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency15/59"}]},{"tags":["table"],"items":[{"text":"Concurrency Control16/59"}]},{"tags":["table"],"items":[{"text":"... Concurrency Control17/59"}]},{"tags":["table"],"items":[{"text":"Producer-Consumer Problem18/59"}]},{"tags":["table"],"items":[{"text":"... Producer-Consumer Problem19/59"}]},{"tags":["table"],"items":[{"text":"... Producer-Consumer Problem20/59"}]},{"tags":["table"],"items":[{"text":"... Producer-Consumer Problem21/59"}]},{"tags":["table"],"items":[{"text":"... Producer-Consumer Problem22/59"}]},{"tags":["table"],"items":[{"text":"Semaphores23/59"}]},{"tags":["table"],"items":[{"text":"... Semaphores24/59"}]},{"tags":["table"],"items":[{"text":"... Semaphores25/59"}]},{"tags":["table"],"items":[{"text":"... Semaphores26/59"}]},{"tags":["table"],"items":[{"text":"... Semaphores27/59"}]},{"tags":["table"],"items":[{"text":"Message Passing28/59"}]},{"tags":["table"],"items":[{"text":"... Message Passing29/59"}]},{"tags":["table"],"items":[{"text":"... Message Passing30/59"}]},{"tags":["table"],"items":[{"text":"... Message Passing31/59"}]},{"tags":["table"],"items":[{"text":"... Message Passing32/59"}]},{"tags":["table"],"items":[{"text":"... Message Passing33/59"}]},{"tags":["table"],"items":[{"text":"Process Interaction"}]},{"tags":["table"],"items":[{"text":"Interacting Processes35/59"}]},{"tags":["table"],"items":[{"text":"... Interacting Processes36/59"}]},{"tags":["table"],"items":[{"text":"File Locking37/59"}]},{"tags":["table"],"items":[{"text":"... File Locking38/59"}]},{"tags":["table"],"items":[{"text":"Pipes39/59"}]},{"tags":["table"],"items":[{"text":"... Pipes40/59"}]},{"tags":["table"],"items":[{"text":"... Pipes41/59"}]},{"tags":["table"],"items":[{"text":"... Pipes42/59"}]},{"tags":["table"],"items":[{"text":"... Pipes43/59"}]},{"tags":["table"],"items":[{"text":"... Pipes44/59"}]},{"tags":["table"],"items":[{"text":"Message Queues45/59"}]},{"tags":["table"],"items":[{"text":"... Message Queues46/59"}]},{"tags":["table"],"items":[{"text":"... Message Queues47/59"}]},{"tags":["table"],"items":[{"text":"... Message Queues48/59"}]},{"tags":["table"],"items":[{"text":"... Message Queues49/59"}]},{"tags":["table"],"items":[{"text":"... Message Queues50/59"}]},{"tags":["table"],"items":[{"text":"... Message Queues51/59"}]},{"tags":["table"],"items":[{"text":"Sockets52/59"}]},{"tags":["table"],"items":[{"text":"... Sockets53/59"}]},{"tags":["table"],"items":[{"text":"... Sockets54/59"}]},{"tags":["table"],"items":[{"text":"... Sockets55/59"}]},{"tags":["table"],"items":[{"text":"... Sockets56/59"}]},{"tags":["table"],"items":[{"text":"... Sockets57/59"}]},{"tags":["table"],"items":[{"text":"... Sockets58/59"}]},{"tags":["table"],"items":[{"text":"... Sockets59/59"}]},{"tags":["list"],"items":[{"text":" e.g. multiple CPUs, one process on each CPU (MIMD) "},{"text":" e.g. data vector, one processor computes on each element (SIMD) "},{"text":" e.g. map-reduce: computation spread across multiple hosts "}]},{"tags":["list"],"items":[{"text":" e.g. single CPU, alternating between processes (time-slicing) "}]},{"tags":["list"],"items":[{"text":" mutliple identical processors "},{"text":" each given one element of a data structure from main memory "},{"text":" each performing same computation on that element "},{"text":" results copied back to main memory data structure "}]},{"tags":["list"],"items":[{"text":" manipulating very large data sets "},{"text":" on a large network of nodes (local or distributed) "}]},{"tags":["list"],"items":[{"text":" data distributed (shuffled) as (key,value) pairs "},{"text":" each node receives a set of pairs with common key(s) "}]},{"tags":["list"],"items":[{"text":" nodes perform calculation on received data items "},{"text":" and combine outputs from these calculations "}]},{"tags":["list"],"items":[{"text":" child executes concurrently with parent "},{"text":" inherits some state from parent (e.g. open fd's) "},{"text":" runs in its own address space "}]},{"tags":["list"],"items":[{"text":" process switching requires kernel intervention "},{"text":" each has a significant amount of state "},{"text":" process interaction requires system-level mechanisms "}]},{"tags":["list"],"items":[{"text":" processes are independent of each other; threads exist within a (parent) process "},{"text":" processes have own state; threads share parent process state "},{"text":" each process has own address space; all threads within a process share one address space "},{"text":" processes communicate via IPC mechanisms (see later); threads can communicate via shared memory "},{"text":" context-switching between processes is expensive; context-switching between threads is (relatively) cheap "}]},{"tags":["list"],"items":[{"text":" requires #include <pthread.h> "},{"text":" provides (opaque) pthread_t data type "},{"text":" functions on threads: create, identify, send signals, exit, ... "}]},{"tags":["list"],"items":[{"text":" creates a new thread with specified Attributes "},{"text":" thread info stored in *Thread "},{"text":" thread starts by executing Func() with Arg "},{"text":" returns 0 if OK, -1 otherwise and sets errno "}]},{"tags":["list"],"items":[{"text":" returns pthread_t for current thread "},{"text":" in some ways, analogous to getpid() "}]},{"tags":["list"],"items":[{"text":" compares two thread IDs "},{"text":" returns non-zero if same thread, 0 otherwise "}]},{"tags":["list"],"items":[{"text":" suspend execution until thread T terminates "},{"text":" pthread_exit() value is placed in *value_ptr "},{"text":" if T has already exited, does not wait "}]},{"tags":["list"],"items":[{"text":" terminate execution of thread, and do some cleaning up "},{"text":" stores a return value in *value_ptr "}]},{"tags":["list"],"items":[{"text":" each process runs to completion before next one starts "},{"text":" low throughput; not acceptable on multi-user systems "}]},{"tags":["list"],"items":[{"text":" if one process is delayed, others can run "},{"text":" if we have multiple CPUs, use all of them at once "}]},{"tags":["list"],"items":[{"text":" each process runs and completes its task "},{"text":" without any effect on the computation of other processes "}]},{"tags":["list"],"items":[{"text":" multiple processes accessing a shared resource "},{"text":" one process synchronizing with another for some computation "}]},{"tags":["list"],"items":[{"text":" nondeterminism ... same code, different runs, different results e.g. output on shared resource is jumbled e.g. input from shared resource is unpredictable "},{"text":" e.g. output on shared resource is jumbled "},{"text":" e.g. input from shared resource is unpredictable "},{"text":" deadlock ... a group of processes end up waiting for each other "},{"text":" starvation ... one process keeps missing access to resource "}]},{"tags":["list"],"items":[{"text":" e.g. output on shared resource is jumbled "},{"text":" e.g. input from shared resource is unpredictable "}]},{"tags":["list"],"items":[{"text":" each process attempts to withdraw($300, A) "}]},{"tags":["list"],"items":[{"text":" process 1 executes up to line 3, then swapped out "},{"text":" process 2 executes up to line 3, then swapped out "},{"text":" process 1 continues and reduces balance by $300 "},{"text":" process 2 continues and reduces balance by $300 "}]},{"tags":["list"],"items":[{"text":" provide correct sequencing of interactions between processes "},{"text":" coordinate semantically-valid access to shared resources "}]},{"tags":["list"],"items":[{"text":" shared memory based (e.g. semaphores) "},{"text":" message passing based (e.g. send/receive) "}]},{"tags":["list"],"items":[{"text":" available via special library functions, or "},{"text":" available via new language constructs "}]},{"tags":["list"],"items":[{"text":" uses shared variable, manipulated atomically "},{"text":" blocks if access unavailable, decrements once available "}]},{"tags":["list"],"items":[{"text":" processes communicate by sending/receiving messages "},{"text":" receiver can block waiting for message to arrive "},{"text":" sender may block waiting for message to be received synchronous message passing: sender waits for ACK of receipt asynchronous message passing: sender transmits and continues "},{"text":" synchronous message passing: sender waits for ACK of receipt "},{"text":" asynchronous message passing: sender transmits and continues "}]},{"tags":["list"],"items":[{"text":" synchronous message passing: sender waits for ACK of receipt "},{"text":" asynchronous message passing: sender transmits and continues "}]},{"tags":["list"],"items":[{"text":" have a buffer with slots for N items "},{"text":" a process that produces new items and puts them in the buffer "},{"text":" a process that consumes items from the buffer "},{"text":" a mechanism for a process to pause itself "},{"text":" a mechanism for signalling a process to wake up "}]},{"tags":["list"],"items":[{"text":" C checks nItems, finds zero, decides to pause "},{"text":" just before pausing, C is timed-out (different to paused) "},{"text":" P creates item, puts it in currently empty buffer "},{"text":" because buffer now has one item, P signals C "},{"text":" because C is not paused, signal is lost "},{"text":" C is resumed after time-out and pauses "},{"text":" P resumes and adds more items "},{"text":" eventually buffer fills and P pauses "},{"text":" each process is paused, waiting for signal from the other "}]},{"tags":["list"],"items":[{"text":" init(Sem, InitValue) set the initial value of semaphore Sem "},{"text":" set the initial value of semaphore Sem "},{"text":" wait(Sem) (also called P()) if current value of Sem > 0, decrement Sem and continue otherwise, block and wait until Sem value > 0 "},{"text":" if current value of Sem > 0, decrement Sem and continue "},{"text":" otherwise, block and wait until Sem value > 0 "},{"text":" signal(Sem) (also called V()) increment value of Sem, and continue "},{"text":" increment value of Sem, and continue "}]},{"tags":["list"],"items":[{"text":" set the initial value of semaphore Sem "}]},{"tags":["list"],"items":[{"text":" if current value of Sem > 0, decrement Sem and continue "},{"text":" otherwise, block and wait until Sem value > 0 "}]},{"tags":["list"],"items":[{"text":" increment value of Sem, and continue "}]},{"tags":["list"],"items":[{"text":" can be achieved via a FIFO queue (fair, but maybe not optimal) "}]},{"tags":["list"],"items":[{"text":" semaphores are updated atomically "},{"text":" so can't timeout in if (nItems == 0) pause() "}]},{"tags":["list"],"items":[{"text":" only one process at a time manipulates the buffer "},{"text":" allows multiple producers/consumers to interact correctly "}]},{"tags":["list"],"items":[{"text":" #include <semaphore.h>, giving sem_t "},{"text":" int sem_init(sem_t *Sem, int Shared, uint Value) create a semaphore object, and set initial value "},{"text":" create a semaphore object, and set initial value "},{"text":" int sem_wait(sem_t *Sem) (i.e. wait()) try to decrement; block if Sem == 0 "},{"text":" try to decrement; block if Sem == 0 "},{"text":" int sem_post(sem_t *Sem) (i.e. signal()) increment the value of semaphore Sem "},{"text":" increment the value of semaphore Sem "},{"text":" int sem_destroy(sem_t *Sem) free all memory associated with semaphore Sem "},{"text":" free all memory associated with semaphore Sem "}]},{"tags":["list"],"items":[{"text":" create a semaphore object, and set initial value "}]},{"tags":["list"],"items":[{"text":" try to decrement; block if Sem == 0 "}]},{"tags":["list"],"items":[{"text":" increment the value of semaphore Sem "}]},{"tags":["list"],"items":[{"text":" free all memory associated with semaphore Sem "}]},{"tags":["list"],"items":[{"text":" source process sends a message to a target process "},{"text":" target process uses message to invoke appropriate code "},{"text":" may send a reply message containing the computed result "}]},{"tags":["list"],"items":[{"text":" data is passed by copying value into a message (cf. parameters) "},{"text":" particularly effective for concurrent, distributed systems "}]},{"tags":["list"],"items":[{"text":" synchronous sender transmits message, waits for response familiar programming model; like a (remote) function call "},{"text":" sender transmits message, waits for response "},{"text":" familiar programming model; like a (remote) function call "},{"text":" asynchronous sender transmits message, continues with own task reponse arrival eventually interrupts original sender "},{"text":" sender transmits message, continues with own task "},{"text":" reponse arrival eventually interrupts original sender "}]},{"tags":["list"],"items":[{"text":" sender transmits message, waits for response "},{"text":" familiar programming model; like a (remote) function call "}]},{"tags":["list"],"items":[{"text":" sender transmits message, continues with own task "},{"text":" reponse arrival eventually interrupts original sender "}]},{"tags":["list"],"items":[{"text":" could occur on local processor, or across wide-area network "}]},{"tags":["list"],"items":[{"text":" MPI_Init(..) ... initialises message passing environment "},{"text":" MPI_Send(..) ... send a message (synchronous) "},{"text":" MPI_Recv(..) ... send a message (synchronous) "}]},{"tags":["list"],"items":[{"text":" goroutines ... concurrently executing \"functions\" "},{"text":" channels ... communication pipes between goroutines "},{"text":" select ... manage multiple channels "}]},{"tags":["list"],"items":[{"text":" signals: kill(), wait(), signal handlers "},{"text":" accessing the same resource (e.g. writing onto the same file) "},{"text":" pipes: stdout of process A goes into stdin of process B "},{"text":" message queues: passing data between each other "},{"text":" sockets: client-server style interaction "}]},{"tags":["list"],"items":[{"text":" two processes writing to same file \"simultaneously\" "},{"text":" order of output depends on actions of (opaque) scheduler "}]},{"tags":["list"],"items":[{"text":" controls access to shared files (note: files not fds) "},{"text":" possible operations LOCK_SH ... acquire shared lock LOCK_EX ... acquire exclusive lock LOCK_UN ... unlock LOCK_NB ... operation fails rather than blocking "},{"text":" LOCK_SH ... acquire shared lock "},{"text":" LOCK_EX ... acquire exclusive lock "},{"text":" LOCK_UN ... unlock "},{"text":" LOCK_NB ... operation fails rather than blocking "},{"text":" in blocking mode, flock() does not return until lock available "},{"text":" only works correctly if all processes accessing file use locks "},{"text":" return value: 0 in success, -1 on failure "}]},{"tags":["list"],"items":[{"text":" LOCK_SH ... acquire shared lock "},{"text":" LOCK_EX ... acquire exclusive lock "},{"text":" LOCK_UN ... unlock "},{"text":" LOCK_NB ... operation fails rather than blocking "}]},{"tags":["list"],"items":[{"text":" if file not locked or other shared locks, OK "},{"text":" if file has exclusive lock, blocked "}]},{"tags":["list"],"items":[{"text":" if file is not locked, OK "},{"text":" if any locks (shared or exclusive) on file, blocked "}]},{"tags":["list"],"items":[{"text":" flock() returns 0 if lock was acquired "},{"text":" flock() returns -1 if process would have been blocked "}]},{"tags":["list"],"items":[{"text":" producer process writes to byte stream (cf. stdout) "},{"text":" consumer process reads from same byte stream "}]},{"tags":["list"],"items":[{"text":" producer blocks when buffer full; consumer blocks when buffer empty "}]},{"tags":["list"],"items":[{"text":" open two file descriptors (to be shared by processes) "},{"text":" fd[0] is opened for reading; fd[1] is opened for writing "},{"text":" return 0 if OK, otherwise return -1 and sets errno "}]},{"tags":["list"],"items":[{"text":" fork() to create a child process "},{"text":" both processes have copies of fd[] "},{"text":" one can write to fd[1], the other can read from fd[0] "}]},{"tags":["list"],"items":[{"text":" set up a pipe between parent and child "},{"text":" exec() child to become a new process talking to parent "}]},{"tags":["list"],"items":[{"text":" analogous to fopen, except first arg is a command "},{"text":" Cmd is passed to shell for interpretation "},{"text":" returns FILE* which be read/written depending on Mode "},{"text":" returns NULL if can't establish pipe or invalid Cmd "}]},{"tags":["list"],"items":[{"text":" processes come initially from parent/child pair (fork) "},{"text":" connection established via shared file descriptions "}]},{"tags":["list"],"items":[{"text":" for unrelated processes to pass information "},{"text":" along a buffered channel shared by many processes "}]},{"tags":["list"],"items":[{"text":" MQ names look like \"/SomeCharacters \" (no slash chars) "}]},{"tags":["list"],"items":[{"text":" create a new message queue, or open existing one "},{"text":" Flags are like those for fopen() (e.g. O_RDONLY) "}]},{"tags":["list"],"items":[{"text":" finish accessing message queue MQ "},{"text":" the message queue continues to exist (cf. fclose()) "}]},{"tags":["list"],"items":[{"text":" adds message Msg to message queue MQ "},{"text":" Prio gives priority (determines order of messages on MQ) "},{"text":" if MQ is full ... blocks until MQ space available if O_NONBLOCK is set, fails and returns error "},{"text":" blocks until MQ space available "},{"text":" if O_NONBLOCK is set, fails and returns error "},{"text":" also, mq_timedsend() which waits for specified time if MQ full fails if still no space on MQ after timeout "},{"text":" waits for specified time if MQ full "},{"text":" fails if still no space on MQ after timeout "}]},{"tags":["list"],"items":[{"text":" blocks until MQ space available "},{"text":" if O_NONBLOCK is set, fails and returns error "}]},{"tags":["list"],"items":[{"text":" waits for specified time if MQ full "},{"text":" fails if still no space on MQ after timeout "}]},{"tags":["list"],"items":[{"text":" removes highest priority message from queue MQ "},{"text":" if *Prio is not NULL, receives message priority "},{"text":" if MQ is empty ... blocks until a message is added to MQ if O_NONBLOCK is set, fails and returns error "},{"text":" blocks until a message is added to MQ "},{"text":" if O_NONBLOCK is set, fails and returns error "},{"text":" if several processes blocked on mq_receive() oldest and highest priority process receives the message "},{"text":" oldest and highest priority process receives the message "}]},{"tags":["list"],"items":[{"text":" blocks until a message is added to MQ "},{"text":" if O_NONBLOCK is set, fails and returns error "}]},{"tags":["list"],"items":[{"text":" oldest and highest priority process receives the message "}]},{"tags":["list"],"items":[{"text":" assume that both processes are on the same host "}]},{"tags":["list"],"items":[{"text":" e.g. web servers, networked databases, networked message queues, ... "}]},{"tags":["list"],"items":[{"text":" commonly used to construct client-server systems "},{"text":" either locally (Unix domain) or network-wide (Internet domain) "},{"text":" server creates a socket, then ... binds to an address (local or network) listens for connections from clients "},{"text":" binds to an address (local or network) "},{"text":" listens for connections from clients "},{"text":" client creates a socket, then ... connects to the server using known address writes to server via socket (i.e. sends requests) reads from server via socket (i.e. receives responses) "},{"text":" connects to the server using known address "},{"text":" writes to server via socket (i.e. sends requests) "},{"text":" reads from server via socket (i.e. receives responses) "}]},{"tags":["list"],"items":[{"text":" binds to an address (local or network) "},{"text":" listens for connections from clients "}]},{"tags":["list"],"items":[{"text":" connects to the server using known address "},{"text":" writes to server via socket (i.e. sends requests) "},{"text":" reads from server via socket (i.e. receives responses) "}]},{"tags":["list"],"items":[{"text":" requires #include <sys/socket.h> "},{"text":" creates a socket, using ... Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"text":" Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) "},{"text":" AF_LOCAL ... on the local host (Unix domain) "},{"text":" AF_INET ... over the network (Internet domain) "},{"text":" Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"text":" SOCK_STREAM ... sequenced, reliable communications stream "},{"text":" SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"text":" Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"text":" many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"text":" returns a socket descriptor (small int) or -1 on error "}]},{"tags":["list"],"items":[{"text":" Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) "},{"text":" AF_LOCAL ... on the local host (Unix domain) "},{"text":" AF_INET ... over the network (Internet domain) "},{"text":" Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"text":" SOCK_STREAM ... sequenced, reliable communications stream "},{"text":" SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"text":" Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"text":" many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "}]},{"tags":["list"],"items":[{"text":" AF_LOCAL ... on the local host (Unix domain) "},{"text":" AF_INET ... over the network (Internet domain) "}]},{"tags":["list"],"items":[{"text":" SOCK_STREAM ... sequenced, reliable communications stream "},{"text":" SOCK_DGRAM ... connectionless, unreliable packet transfer "}]},{"tags":["list"],"items":[{"text":" many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "}]},{"tags":["list"],"items":[{"text":" associates an open socket with an address "},{"text":" for Unix Domain, address is a pathname in the file system "},{"text":" for Internet Domain, address is IP address + port number "}]},{"tags":["list"],"items":[{"text":" wait for connections on socket Sockfd "},{"text":" allow at most Backlog connections to be queued up "}]},{"tags":["list"],"items":[{"text":" sin_family ... domain: AF_UNIX or AF_INET "},{"text":" sin_port ... port number: 80, 443, etc. "},{"text":" sin_addr ... structure containing host address "},{"text":" sin_zero[8] ... padding "}]},{"tags":["list"],"items":[{"text":" Sockfd has been created, bound and is listening "},{"text":" blocks until a connection request is received "},{"text":" sets up a connection between client/server after connect() "},{"text":" places information about the requestor in Addr "},{"text":" returns a new socket descriptor, or -1 on error "}]},{"tags":["list"],"items":[{"text":" connects the socket Sockfd to address Addr "},{"text":" assumes that Addr contains a process listening appropriately "},{"text":" returns 0 on success, or -1 on error "}]}],"block":[{"tags":["paragraph"],"text":"G: Parallelism/Concurrency"},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Parallelism/Concurrency "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Concurrency/Parallelism2/59 "},{"tags":["paragraph"],"text":" Parallelism = multiple computations executed simultaneously "},{"tags":["paragraph"],"text":" Both parallelism and concurrency need to deal with synchronisation. "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency/Parallelism3/59 "},{"tags":["paragraph"],"text":" Example of SIMD parallel processing (e.g. GPU) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" But not totally independent: need to synchronise on completion "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency/Parallelism4/59 "},{"tags":["paragraph"],"text":" Map-reduce is a programming model for "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency/Parallelism5/59 "},{"tags":["paragraph"],"text":" Canonical example: compute word frequencies "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Creating Concurrency6/59 "},{"tags":["paragraph"],"text":" One method for creating concurrent tasks: "},{"tags":["paragraph"],"text":" fork() creates a new (child) process "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Creating Concurrency7/59 "},{"tags":["paragraph"],"text":" Alternative mechanism for concurrent tasks: threads "},{"tags":["paragraph"],"text":" Difference between threads and processes "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Linux/Unix Threads8/59 "},{"tags":["paragraph"],"text":" pThreads = POSIX implementation of threads "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Linux/Unix Threads9/59 "},{"tags":["paragraph"],"text":" int pthread_create(pthread_t *Thread, pthread_attr_t *Attr, void *(*Func)(void *), void *Arg) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Linux/Unix Threads10/59 "},{"tags":["paragraph"],"text":" pthread_t pthread_self(void) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Linux/Unix Threads11/59 "},{"tags":["paragraph"],"text":" int pthread_join(pthread_t T, void **value_ptr) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Concurrency12/59 "},{"tags":["paragraph"],"text":" The alternative to concurrency ... sequential execution "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency13/59 "},{"tags":["paragraph"],"text":" In reality, processes are often not independent "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency14/59 "},{"tags":["paragraph"],"text":" Example of problematic concurrency ... bank withdrawal: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Scenario: two processes, one account A, initial balance $500 "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency15/59 "},{"tags":["paragraph"],"text":" Restatement of program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Possible outcome of scenario: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Concurrency Control16/59 "},{"tags":["paragraph"],"text":" Concurrency control aims to "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Concurrency Control17/59 "},{"tags":["paragraph"],"text":" Shared memory approach: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Producer-Consumer Problem18/59 "},{"tags":["paragraph"],"text":" Classic example for concurrency control issues "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Producer-Consumer Problem19/59 "},{"tags":["paragraph"],"text":" Data objects shared by two processes: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Functions on buffer (simplified view): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Producer-Consumer Problem20/59 "},{"tags":["paragraph"],"text":" Producer process (P): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Producer-Consumer Problem21/59 "},{"tags":["paragraph"],"text":" Consumer process (C): "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Producer-Consumer Problem22/59 "},{"tags":["paragraph"],"text":" A possible scenario (assumes signals only reach paused processes) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Semaphores23/59 "},{"tags":["paragraph"],"text":" Semaphore operations: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Semaphores24/59 "},{"tags":["paragraph"],"text":" Using semaphores for the producer-consumer problem: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" The mutex semaphore ensures that "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Semaphores25/59 "},{"tags":["paragraph"],"text":" Using semaphores for the producer-consumer problem (cont) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Semaphores26/59 "},{"tags":["paragraph"],"text":" Using semaphores for the producer-consumer problem (cont) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Semaphores27/59 "},{"tags":["paragraph"],"text":" Semaphores on Linux/Unix ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Message Passing28/59 "},{"tags":["paragraph"],"text":" Message passing = a method for invoking computations "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Passing29/59 "},{"tags":["paragraph"],"text":" Message passing systems can be ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Passing30/59 "},{"tags":["paragraph"],"text":" Message passing architecture "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Passing31/59 "},{"tags":["paragraph"],"text":" A standard message passing framework (MPI) has been defined "},{"tags":["paragraph"],"text":" Bindings exist for many languages (e.g. C, C++, Java, Python, ...) "},{"tags":["paragraph"],"text":" Other languages have message passing built in "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Passing32/59 "},{"tags":["paragraph"],"text":" Example of message passing with language support: Google's Go "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Passing33/59 "},{"tags":["paragraph"],"text":" Bank withdrawal example using Go: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" For more info on Go, see https://tour.golang.org/ "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Process Interaction "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Interacting Processes35/59 "},{"tags":["paragraph"],"text":" Processes can interact via "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Interacting Processes36/59 "},{"tags":["paragraph"],"text":" Example of problematic process interaction: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":" Could control access to file via semaphores "},{"tags":["paragraph"],"text":" An alternative (less general) mechanism: file locking "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" File Locking37/59 "},{"tags":["paragraph"],"text":" int flock(int FileDesc, int Operation) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... File Locking38/59 "},{"tags":["paragraph"],"text":" If a process tries to acquire a shared lock ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Pipes39/59 "},{"tags":["paragraph"],"text":" A common style of process interaction (communication) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" A pipe provides buffered i/o between producer and consumer "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Pipes40/59 "},{"tags":["paragraph"],"text":" int pipe(int fd[2]) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Pipes41/59 "},{"tags":["paragraph"],"text":" Creating a pipe ... "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Pipes42/59 "},{"tags":["paragraph"],"text":" Example: setting up a pipe "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Pipes43/59 "},{"tags":["paragraph"],"text":" A common pattern in pipe usage "},{"tags":["paragraph"],"text":" FILE *popen(char *Cmd, char *Mode) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Pipes44/59 "},{"tags":["paragraph"],"text":" Example of popen() "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Message Queues45/59 "},{"tags":["paragraph"],"text":" Pipes operate between two processes on same host "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Queues46/59 "},{"tags":["paragraph"],"text":" Message queue architecture "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Queues47/59 "},{"tags":["paragraph"],"text":" Requires #include <mqueue.h>, giving mqd_t "},{"tags":["paragraph"],"text":" mqd_t mq_open(char *Name, int Flags) "},{"tags":["paragraph"],"text":" int mq_close(mqd_t *MQ) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Queues48/59 "},{"tags":["paragraph"],"text":" int mq_send(mqd_t MQ, char *Msg, int Size, uint Prio) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Queues49/59 "},{"tags":["paragraph"],"text":" int mq_receive(mqd_t MQ, char *Msg, int Size, uint *Prio) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Queues50/59 "},{"tags":["paragraph"],"text":" Pseudo-code showing structure of a MQ server program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Message Queues51/59 "},{"tags":["paragraph"],"text":" Pseudo-code showing structure of a MQ client program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Sockets52/59 "},{"tags":["paragraph"],"text":" Inter-process communication (IPC) mechanisms considered so far "},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets53/59 "},{"tags":["paragraph"],"text":" Socket = an end-point of an IPC channel "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets54/59 "},{"tags":["paragraph"],"text":" int socket(int Domain, int Type, int Protocol) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets55/59 "},{"tags":["paragraph"],"text":" int bind(int Sockfd, SockAddr *Addr, socklen_t AddrLen) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets56/59 "},{"tags":["paragraph"],"text":" SockAddr = struct sockaddr_in "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets57/59 "},{"tags":["paragraph"],"text":" int accept(int Sockfd, SockAddr *Addr, socklen_t *AddrLen) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets58/59 "},{"tags":["paragraph"],"text":" Pseudo-code showing structure of a simple client program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" (See http://www.linuxhowtos.org/C_C++/socket.htm) "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" ... Sockets59/59 "},{"tags":["paragraph"],"text":" Pseudo-code showing structure of a server program: "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" "},{"tags":["paragraph"],"text":""},{"tags":["paragraph"],"text":" Produced: 2 May 2018 "}]}