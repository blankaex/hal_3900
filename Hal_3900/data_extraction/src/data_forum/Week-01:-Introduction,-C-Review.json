{"posts":[null,{"tags":[{"name":"Forums"},{"name":"Tutorials"},{"name":"Week 01: Introduction, C Review"}],"question":" The answer to Q5 states that 'Constant strings are located in the Data region of memory'. Is this correct? I read that they are stored in the 'Text' region of memory which is read-only hence why they can't be modified and therefore given the name 'Constant'. Strings stored as arrays on the other hand can be modified and so are stored in the 'Data' section of memory which is writable. ","answers":[" Interesting question. Constant string values are certainly \"read-only\", but they don't seem to be in the \"text\" area, if you believe the output from the following program: #include &lt;stdio.h&gt; extern char etext, edata, end; char buf[100]; int i1 = 5; const int i2 = 7; int main(void) { int *i = &amp;i2; char *s = \"abc\"; printf(\"s@%p\\n\",s); printf(\"i1@%p\\n\",&amp;i1); printf(\"i2@%p\\n\",&amp;i2); printf(\"buf@%p\\n\",buf); printf(\"etext@%p\\n\",&amp;etext); printf(\"edata@%p\\n\",&amp;edata); printf(\"end@%p\\n\",&amp;end); // s[0] = 'b'; produces a runtime error // i2 = 5; produces a compiler error return 0; } When I run this on a CSE server, it tells me that s and i2 are located just above the top of the text region ( etext ). The buf and i1 variables are located a little higher in the memory. My take: there is a read-only region at the bottom of the data area where immutable objects are placed. To find out about etext , edata , and end , try the command man etext ",[" Thanks John, I added the extext, edata and end variables to my code below: #include &lt;stdio.h&gt; extern char etext, edata, end; char *s1 = \"abc\"; char a1[4] = \"abc\"; void func1(void); int main (void) { char *s2 = \"xyz\"; char s3 = 'b'; printf(\"etext@%p\\n\",&amp;etext); printf(\"edata@%p\\n\",&amp;edata); printf(\"end@%p\\n\",&amp;end); printf (\"---------------------------------\\n\"); printf (\"Address of s1 pointer is %p\\n\", &amp;s1); printf (\"Address of s1 element 0 is %p\\n\", &amp;s1[0]); printf (\"Data in s1 element 0 is %c\\n\", s1[0]); printf (\"Address of s1 element 1 is %p\\n\", &amp;s1[1]); printf (\"Data in s1 element 1 is %c\\n\", s1[1]); printf (\"Address of s1 element 2 is %p\\n\", &amp;s1[2]); printf (\"Data in s1 element 2 is %c\\n\", s1[2]); printf (\"Address of s1 element 3 is %p\\n\", &amp;s1[3]); printf (\"Data in s1 element 3 is %c\\n\", s1[3]); printf (\"---------------------------------\\n\"); printf (\"Address of s2 is %p\\n\", &amp;s2); printf (\"Address of s2 is %p\\n\", &amp;s2[1]); printf (\"Address of s2 is %p\\n\", &amp;s2[2]); printf (\"Address of s2 is %p\\n\", &amp;s2[3]); printf (\"---------------------------------\\n\"); printf (\"Address of s3 is %p\\n\", &amp;s3); printf (\"Data in s3 is %c\\n\", s3); printf (\"---------------------------------\\n\"); printf (\"Address of a1 is %p\\n\", &amp;a1); printf (\"Data in a1 is %s\\n\", a1) printf (\"Address of a1 element 0 is %p\\n\", &amp;a1[0]); printf (\"Data in a1 element 0 is %c\\n\", a1[0]); printf (\"Address of a1 element 1 is %p\\n\", &amp;a1[1]); printf (\"Data in a1 element 1 is %c\\n\", a1[1]); printf (\"Address of a1 element 2 is %p\\n\", &amp;a1[2]); printf (\"Address of a1 element 3 is %p\\n\", &amp;a1[3]); func1(); } void func1(void){ static int i = 1; printf (\"Address of i is %p\\n\", &amp;i); } When I ran it it got the following: etext@0x8048828 edata@0x804a02c end@0x804a030 --------------------------------- Address of s1 pointer is 0x804a020 Data in s1 pointer is 0x8048830 Address of s1 element 0 is 0x8048830 Data in s1 element 0 is a Address of s1 element 1 is 0x8048831 Data in s1 element 1 is b Address of s1 element 2 is 0x8048832 Data in s1 element 2 is c Address of s1 element 3 is 0x8048833 Data in s1 element 3 is --------------------------------- Address of s2 is 0xffce003c Data in s2 is 0x8048834 Address of s2 is 0x8048834 Address of s2 is 0x8048835 Address of s2 is 0x8048836 Address of s2 is 0x8048837 --------------------------------- Address of s3 is 0xffce003b Data in s3 is b --------------------------------- Address of a1 is 0x804a024 Data in a1 is abc Address of a1 element 0 is 0x804a024 Data in a1 element 0 is a Address of a1 element 1 is 0x804a025 Data in a1 element 1 is b Address of a1 element 2 is 0x804a026 Data in a1 element 2 is c Address of a1 element 3 is 0x804a027 Data in a1 element 3 is --------------------------------- Address of i is 0x804a028 So I could see that the address of the elements of s1 (global string constant) and a1 (global char array) seemed to be in different locations. Where as the location of the s1 and s2 (local string constant) were located next to each other. Comparing these memory addresses to etext, edata and end it looks like the strings, whether they be string constant (s1, s2) or array (a1) are stored in the data area but definitely s1/s2 are stored separate to a1. The actual pointer addresses of s1 and a2 are next to each other, as is the rest of the data of a2 but the memory location that s1 points to is in a seperate area of memory, the same area s2 points to. Does this align with what you saw? Thanks ",[" Yes. And this is a nice exploration of the problem. ",[" Thanks for confirming John. "]]]]},{"tags":[{"name":"Forums"},{"name":"Tutorials"},{"name":"Week 01: Introduction, C Review"}],"question":" Can we have the official solution for Tutorial and Lab? Sometimes, I felt hard to understand the tutor's explanation. ","answers":[" I'll put up solutions to the tute exercises. If you find that your tutor is difficult to understand, ask them to explain again, but differently. "]}]}