{"posts":[null,{"tags":[{"name":"Forums"},{"name":"Lab Classes"},{"name":"Week 08: A Minimal Shell"}],"question":" i was trouble shooting my code and so changed teh compiler to dcc and it raised a seg fault with line 35 where the skeleton code loops through envp[i], what's going on? ","answers":[" Hi Robert, i just ran the supplied code under dcc and it worked fine. check if you have edited anything before the start of the loop in main. And maybe just to be sure, re-download a new copy and copy across the execute function and the loop body. ",[" actually no, it still messes up with dcc but executes exactly how it is supposed to with gcc "]]},{"tags":[{"name":"Forums"},{"name":"Lab Classes"},{"name":"Week 08: A Minimal Shell"}],"question":" I can't quite work out why a loop of mine doesn't seem to execute those lines in the the function after the loop ends. Having played around with it, the following loop seems to execute properly (note that the condition is just fore testing): int i = 0; for ( i=0; i&lt;9 ; i++ ){ printf (\"%d\\n\", i); } printf(\"---ending execute\\n\"); The above code produces the following: 0 1 2 3 4 5 6 7 8 ---ending execute However when I add one line to the loop to print the path the line \"---ending execute\" after the loop no longer prints. Also, the loop only increments to 6 and not 8 as per the loop condition: int i = 0; for ( i=0; i&lt;9 ; i++ ){ printf (\"%d element in path is %s\\n\", i, path[i]); printf (\"%d\\n\", i); } printf(\"---ending execute\\n\"); This outputs: 0 element in path is /import/glass/4/z5200681/bin-pc.i86.linux 0 1 element in path is /import/glass/4/z5200681/bin 1 2 element in path is /usr/local/bin 2 3 element in path is /usr/bin 3 4 element in path is /bin 4 5 element in path is (null) 5 6 element in path is (null) 6 Interestingly when I change path[i] to path[2] the loops starts working again. int i = 0; for ( i=0; i&lt;9 ; i++ ){ printf (\"%d element in path is %s\\n\", i, path[2]); printf (\"%d\\n\", i); } printf(\"---ending execute\\n\"); This outputs: 0 element in path is /usr/local/bin01 element in path is /usr/local/bin12 element in path is /usr/local/bin23 element in path is /usr/local/bin34 element in path is /usr/local/bin45 element in path is /usr/local/bin56 element in path is /usr/local/bin67 element in path is /usr/local/bin78 element in path is /usr/local/bin8---ending execute Can anyone provide any input as to why this happens as it seems utterly strange to me? Thanks ","answers":[" Why are you using (i &lt; 9) as the loop condition? Do you know for sure that there are 9 elements in path[]? I have no idea why the second loop terminates after 7 iterations, but the fact that the last few iterations even work (and show null) is pure luck. If you use path[2] rather than path[i], it's hardly surprising that it runs for 9 iterations. Why are you surprised? ",[" As mentioned, the condition (i&lt;9) was just for testing. I was having some trouble with the correct condition, which has since been resolved, but as part of the troubleshooting I wanted to simplify my condition to check the operation of the loop. This is what led me to the above question - I wasn't sure why a printf statement would cause the loop to fail and actually it seems cause the child process to crash as the \"--ending execute\" line after the loop would not print whenever trying to print path[i] for values of i above 6. I understand that in this case maybe there is no path[7] or greater, but I wouldn't think trying to print that string would have broken the loop. I thought at worst it may just print random data. When i gets to 5 and 6 i still prints something for: printf (\"%d element in path is %s\\n\", i, path[i]);&lt;span class=\"redactor-invisible-space\"&gt;&lt;/span&gt; specifically: 5 element in path is (null) 6 element in path is (null) even though path[5] and path[6] are NULL. I am not sure what is different about values of i above this which would actually cause the loop to break. I understand it may not print anything meaningful but I was surprised the loop if not the entire process broke as my understanding was the index i was a number of bytes past the start of the array.I also would have thought if it did try and access memory it wasn't allowed to it would have output an error of some sort to stdout but there has never been one. Thanks "]]},{"tags":[{"name":"Forums"},{"name":"Lab Classes"},{"name":"Week 08: A Minimal Shell"}],"question":" Permission denied Hi, I'm working on CSE machine. But I get Permission denied when used execve. So what should I do to avoid this? Thank you in advance! ","answers":[" It's possible that your parameters to execve() are not right ... despite the message about Executing /bin/ls . You might want to print the values of the arguments that you're actually passing to execve() or use gdb to help you check them. "]},{"tags":[{"name":"Forums"},{"name":"Lab Classes"},{"name":"Week 08: A Minimal Shell"}],"question":" In the Makefile, I think it should be -std=gnu99 instead of c99. If you compile it with c99, it gives an implicit declartion of strdup ","answers":[]},{"tags":[{"name":"Forums"},{"name":"Lab Classes"},{"name":"Week 08: A Minimal Shell"}],"question":" Hi! I wonder why command \"cd\" does not work in my-shell? Is it due to \"cd\" is not in the directory \"/bin\"? And if so, is it possible to achieve this goal? Thanks! ","answers":[" Good question ... and to be resolved in Assignment 2. \"cd\" is a special command built-into the shell. It needs to be built in because it changes the state of the shell. Programs that you execute via execve() run as separate processes and do not affect the shell's internal state. You can achieve this via chdir() . Read the manual entry. ",[" Got it. Thanks! "]]}]}