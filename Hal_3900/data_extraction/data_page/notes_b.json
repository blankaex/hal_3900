{"grouped":[{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"The C View of Data 1/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... The C View of Data 2/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... The C View of Data 3/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... The C View of Data 4/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... The C View of Data 5/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"The Physical View of Data 6/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Memory 7/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Memory 8/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Memory 9/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Data Representation "}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Data Representation 11/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Character Data 12/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"ASCII Character Encoding 13/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... ASCII Character Encoding 14/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Unicode 15/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"UTF-8 Character Encoding 16/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"#bytes #bits,Byte 1,Byte 2,Byte 3,Byte 4"},{"tags":[],"text":"1 7,0xxxxxxx,-,-,-"},{"tags":[],"text":"2 11,110xxxxx,10xxxxxx,-,-"},{"tags":[],"text":"3 16,1110xxxx,10xxxxxx,10xxxxxx,-"},{"tags":[],"text":"4 21,11110xxx,10xxxxxx,10xxxxxx,10xxxxxx"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... UTF-8 Character Encoding 17/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"ch unicode,bits,simple binary,UTF-8 binary"},{"tags":[],"text":"$ U+0024,7,010 0100,00100100"},{"tags":[],"text":"¬¢ U+00A2,11,000 1010 0010,11000010 10100010"},{"tags":[],"text":"‚Ç¨ U+20AC,16,0010 0000 1010 1100,11100010 10000010 10101100"},{"tags":[],"text":"êçà U+10348,21,0 0001 0000 0011 0100 1000,11110000 10010000 10001101 10001000"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... UTF-8 Character Encoding 18/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Numeric Data 19/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Integer Constants 20/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Unsigned integers 21/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Unsigned integers 22/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Signed integers 23/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Signed integers 24/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Signed integers 25/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Signed integers 26/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Signed integers 27/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Pointers 28/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Pointers 29/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Floating Point Numbers 30/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Floating Point Numbers 31/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Floating Point Numbers 32/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Floating Point Numbers 33/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Floating Point Numbers 34/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Component Min Value,Max Value"},{"tags":[],"text":"exponent 00000000 = -127,11111111 = 128"},{"tags":[],"text":"fraction 00...00 = 0,11...11 = 2-1+2-2+...+2-24"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Component Min Value,Max Value"},{"tags":[],"text":"exponent 00000000000 = -2047,11111111111 = 2048"},{"tags":[],"text":"fraction 00...00 = 0,11...11 = 2-1+2-2+...+2-51"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Floating Point Numbers 35/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Arrays 36/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Arrays 37/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Arrays 38/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Arrays 39/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Structs 40/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs 41/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs 42/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Exercise 1: Struct Alternatives 43/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Variable-length Structs 44/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Variable-length Structs 45/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Bit-wise Structs 46/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Bit-wise Structs 47/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Bit-wise Structs 48/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Bit-wise Structs 49/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Bit-wise Structs 50/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Unions 51/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Unions 52/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Unions 53/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Unions 54/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Unions 55/56"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Enumerated Types 56/56"}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" a location in memory "},{"tags":[],"text":" a value (ultimately just a bit-string) "},{"tags":[],"text":" a name (unless created by malloc()) "},{"tags":[],"text":" a type, which determines ... its size (in units of whole bytes, sizeof) how to interpret its value what operations apply to the value "},{"tags":[],"text":" its size (in units of whole bytes, sizeof) "},{"tags":[],"text":" how to interpret its value "},{"tags":[],"text":" what operations apply to the value "},{"tags":[],"text":" a scope (where it's visible within the program) "},{"tags":[],"text":" a lifetime (during which part of program execution it exists) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" its size (in units of whole bytes, sizeof) "},{"tags":[],"text":" how to interpret its value "},{"tags":[],"text":" what operations apply to the value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" global variables, static variables, string constants "},{"tags":[],"text":" objects persist for entire duration of program execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" objects created by malloc, calloc, ... "},{"tags":[],"text":" objects persist in heap until explicitly free'd "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" a small region (frame) for each active function "},{"tags":[],"text":" frames contain local variables and parameters "},{"tags":[],"text":" a frame is created when a function is called "},{"tags":[],"text":" the frame is removed when the function returns "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" relatively large (e.g. 228 bytes) "},{"tags":[],"text":" any byte can be fetched with same cost "},{"tags":[],"text":" cost of fetching 1,2,4,8 bytes is small (ns) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" volatile (e.g. DRAM) ... data lost when powered off "},{"tags":[],"text":" non-volatile (e.g. EEPROM) ... data stays when powered off "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" any byte address can be used to fetch 1-byte object "},{"tags":[],"text":" byte address for N-byte object must be divisible by N "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" load bit-strings of sizes 1,2,4,8 bytes "},{"tags":[],"text":" from N-byte boundary addresses "},{"tags":[],"text":" into registers in the CPU "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" ASCII (ISO 646) 7-bit values, using lower 7-bits of a byte (top bit always zero) can encode roman alphabet, digits, punctuation, control chars "},{"tags":[],"text":" 7-bit values, using lower 7-bits of a byte (top bit always zero) "},{"tags":[],"text":" can encode roman alphabet, digits, punctuation, control chars "},{"tags":[],"text":" UTF-8 (Unicode) 8-bit values, with ability to extend to multi-byte values can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "},{"tags":[],"text":" 8-bit values, with ability to extend to multi-byte values "},{"tags":[],"text":" can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 7-bit values, using lower 7-bits of a byte (top bit always zero) "},{"tags":[],"text":" can encode roman alphabet, digits, punctuation, control chars "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 8-bit values, with ability to extend to multi-byte values "},{"tags":[],"text":" can encode all human languages plus other symbols (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" control characters (0..31) ... e.g. '\\0', '\\n' "},{"tags":[],"text":" punctuation chars (32..47,91..96,123..126) "},{"tags":[],"text":" digits (48..57) ... '0'..'9' "},{"tags":[],"text":" upper case alphabetic (65..90) ... 'A'..'Z' "},{"tags":[],"text":" lower case alphabetic (97..122) ... 'a'..'z' "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" not all writing systems use a small set of discrete symbols "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" around 140K symbols, covering 140 different languages "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" e.g. standard roman alphabet + punctuation needs only 7-bits "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" \\uHexDigits ... insert Unicode code value "},{"tags":[],"text":" \\x2HexDigits ... insert individual bytes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" integer ... subset (range) of the mathematical integers "},{"tags":[],"text":" floating point ... subset of the mathematical real numbers "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 42 ... signed decimal (0..9) "},{"tags":[],"text":" 0x2A ... unsigned hexadecimal (0..F) "},{"tags":[],"text":" 052 ... signed octal (0 ..7) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 123U ... unsigned int value (typically 32 bits) "},{"tags":[],"text":" 123L ... long int value (typically 64 bits) "},{"tags":[],"text":" 123S ... short int value (typically 16 bits) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 4294967296, -1U, 666666S, 078 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" commonly 32 bits, storing values in the range 0 .. 232-1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" commonly 32 bits, storing values in the range -231 .. 231-1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" signed magnitude ... first bit is sign, rest are magnitude "},{"tags":[],"text":" ones complement ... form -N by inverting all bits in N "},{"tags":[],"text":" twos complement ... form -N by inverting N and adding 1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 10000101 ... signed magnitude "},{"tags":[],"text":" 11111010 ... ones complement "},{"tags":[],"text":" 11111011 ... twos complement "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" what do these numbers represent? 00000000, 10000000 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" what do these numbers represent? 00000000, 11111111 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" -0 = ~00000000+1 = 11111111+1 = 00000000 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" number of bits depends on memory size, but typically 32-bits "},{"tags":[],"text":" data pointers reference addresses in data/heap/stack regions "},{"tags":[],"text":" function pointers reference addresses in code region "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" sizeof(int *) = sizeof(char *) = sizeof(double *) = sizeof(struct X *) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" (char *) ... can reference any byte address "},{"tags":[],"text":" (int *) ... must have addr %4 == 0 "},{"tags":[],"text":" (double *) ... must have addr %8 == 0 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" many real values don't have exact representation (e.g. 1/3) "},{"tags":[],"text":" results of calculations may contain small inaccuracies "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" numbers close to zero have higher precision (more accurate) "},{"tags":[],"text":" numbers further from zero have lower precision (less accurate) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" float ... typically 32-bit quantity (lower precision, narrower range) "},{"tags":[],"text":" double ... typically 64-bit quantity (higher precision, wider range) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" scientific notation with fraction F and exponent E "},{"tags":[],"text":" numbers have form F √ó 2E, where both F and E can be -ve "},{"tags":[],"text":" INFINITY = representation for ‚àû and -‚àû (e.g. 1.0/0) "},{"tags":[],"text":" NAN = representation for invalid value NaN (e.g. sqrt(-1.0)) "},{"tags":[],"text":" 32-bit single-precision, 64-bit double precision "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 1010.1011 is normalized as 1.0101011√ó2011 "},{"tags":[],"text":" 1010.1011 = 10 + 11/16 = 10.6875 "},{"tags":[],"text":" 1.0101011√ó2011 = (1 + 43/128) * 23 = 1.3359375 * 8 = 10.6875 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" fraction part is always 1.bbbbbbbb; don't store 1 "},{"tags":[],"text":" exponent is offset relative to a baseline -2b-1-1, b = #exponent bits "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" the baseline (aka bias) is 127, the exponent is 27 "},{"tags":[],"text":" so, in the exponent, we store 127+7 = 134 = 10000110 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" individual array elements are accessed via indices 0..N-1 "},{"tags":[],"text":" total amount of space allocated to array N √ó sizeof(Type ) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" constant strings have '\\0' added automatically "},{"tags":[],"text":" string buffers must allow for element to hold '\\0' "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" each component has a Name and a Type "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" define the dynamic object as the last component "},{"tags":[],"text":" malloc() more space than the struct requires "},{"tags":[],"text":" to make the final component as large as required "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" C allows programmers to specify structs bit-wise "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" specify unnamed components using standard types "},{"tags":[],"text":" specify named individual bit fields in each component "}]}],"block":[{"tags":[{"name":"paragraph"}],"text":"Course Notes B: Memory and Data Representation"},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" The C View of Data1/56 "},{"tags":[{"name":"paragraph"}],"text":" A C program sees data as a collection of variables "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Each variable has a number of properties (e.g. name, type, size) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... The C View of Data2/56 "},{"tags":[{"name":"paragraph"}],"text":" Variables are examples of computational objects "},{"tags":[{"name":"paragraph"}],"text":" Each computational object has "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... The C View of Data3/56 "},{"tags":[{"name":"paragraph"}],"text":" C allocates data objects to various well-defined regions of memoryduring program execution "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... The C View of Data4/56 "},{"tags":[{"name":"paragraph"}],"text":" The global data area contains "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... The C View of Data5/56 "},{"tags":[{"name":"paragraph"}],"text":" Example of runtime stack during call to h() "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" The Physical View of Data6/56 "},{"tags":[{"name":"paragraph"}],"text":" Memory = indexed array of bytes "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Indexes are \"memory addresses\" (a.k.a. pointers) "},{"tags":[{"name":"paragraph"}],"text":" Data can be fetched in chunks of 1,2,4,8 bytes "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Memory7/56 "},{"tags":[{"name":"paragraph"}],"text":" Also called: RAM, main memory, primary storage, ... "},{"tags":[{"name":"paragraph"}],"text":" Technology: semiconductor-based "},{"tags":[{"name":"paragraph"}],"text":" Distinguishing features "},{"tags":[{"name":"paragraph"}],"text":" Two properties related to data persistence "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Memory8/56 "},{"tags":[{"name":"paragraph"}],"text":" When addressing objects in memory "},{"tags":[{"name":"paragraph"}],"text":" Data bytes in registers may be in different order to memory, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Memory9/56 "},{"tags":[{"name":"paragraph"}],"text":" Memories can be categorised as big-endian or little-endian "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Data Representation "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Data Representation11/56 "},{"tags":[{"name":"paragraph"}],"text":" Ultimately, memory allows you to "},{"tags":[{"name":"paragraph"}],"text":" Need to interpret this bit-string as a meaningful value "},{"tags":[{"name":"paragraph"}],"text":" Data representations provide a way of assigning meaning to bit-strings "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Character Data12/56 "},{"tags":[{"name":"paragraph"}],"text":" Character data has several possible representations (encodings) "},{"tags":[{"name":"paragraph"}],"text":" The two most common: "},{"tags":[{"name":"paragraph"}],"text":" (e.g. ‚àö ‚àë ‚àÄ ‚àÉ or ) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ASCII Character Encoding13/56 "},{"tags":[{"name":"paragraph"}],"text":" Uses values in the range 0x00 to 0x7F (0..127) "},{"tags":[{"name":"paragraph"}],"text":" Characters partitioned into sequential groups "},{"tags":[{"name":"paragraph"}],"text":" Sequential nature of groups allow for e.g. (ch - '0') "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... ASCII Character Encoding14/56 "},{"tags":[{"name":"paragraph"}],"text":" Hexademical ASCII char table (from man 7 ascii) "},{"tags":[{"name":"paragraph"}],"text":" 0x0a = '\\n', 0x20 = ' ', 0x09 = '\\t', but note no EOF "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Unicode15/56 "},{"tags":[{"name":"paragraph"}],"text":" Widely-used standard for expressing \"writing systems\" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" UTF-8 Character Encoding16/56 "},{"tags":[{"name":"paragraph"}],"text":" UTF-8 uses a variable-length encoding as follows "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" The 127 1-byte codes are compatible with ASCII "},{"tags":[{"name":"paragraph"}],"text":" The 2048 2-byte codes include most Latin-script alphabets "},{"tags":[{"name":"paragraph"}],"text":" The 65536 3-byte codes include most Asian languages "},{"tags":[{"name":"paragraph"}],"text":" The 2097152 4-byte codes include symbols and emojis and ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... UTF-8 Character Encoding17/56 "},{"tags":[{"name":"paragraph"}],"text":" UTF-8 examples "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Unicode strings can be manipulated in C (e.g. \"\") "},{"tags":[{"name":"paragraph"}],"text":" Like other C strings, they are terminated by a 0 byte (i.e. '\\0') "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... UTF-8 Character Encoding18/56 "},{"tags":[{"name":"paragraph"}],"text":" Unicode constants in C strings ... "},{"tags":[{"name":"paragraph"}],"text":" The following two notations work in some contexts "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" The red sequences produce 3 bytes and 1 Unicode symbol. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Numeric Data19/56 "},{"tags":[{"name":"paragraph"}],"text":" Numeric data comes in two major forms "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Integer Constants20/56 "},{"tags":[{"name":"paragraph"}],"text":" Three ways to write integer constants in C "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Unsigned integers21/56 "},{"tags":[{"name":"paragraph"}],"text":" The unsigned int data type "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Unsigned integers22/56 "},{"tags":[{"name":"paragraph"}],"text":" Value interpreted as binary number "},{"tags":[{"name":"paragraph"}],"text":" E.g. consider an 8-bit unsigned int "},{"tags":[{"name":"paragraph"}],"text":" 01001101 = 26 + 23 + 22 + 20 = 64 + 8 + 4 + 1 = 77 "},{"tags":[{"name":"paragraph"}],"text":" Addition is bitwise with carry "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Most machines will also flag the overflow in the fourth example "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Signed integers23/56 "},{"tags":[{"name":"paragraph"}],"text":" The int data type "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Signed integers24/56 "},{"tags":[{"name":"paragraph"}],"text":" Several possible representations for negative values "},{"tags":[{"name":"paragraph"}],"text":" Examples: representations of (8-bit) -5 (where 5 is 00000101) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Signed integers25/56 "},{"tags":[{"name":"paragraph"}],"text":" Signed magnitude: Easy to form -X from X ... OR in high-order bit "},{"tags":[{"name":"paragraph"}],"text":" A problem (using 8-bit ints) ... "},{"tags":[{"name":"paragraph"}],"text":" Another problem: x + -x ‚â† 0 (mostly) with simple addition "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" To fix requires extra hardware in ALU "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Signed integers26/56 "},{"tags":[{"name":"paragraph"}],"text":" Ones complement: Easy to form -X from X ... NEG all bits "},{"tags":[{"name":"paragraph"}],"text":" A problem (using 8-bit ints) ... "},{"tags":[{"name":"paragraph"}],"text":" At least x + -x is equal to one of the zeroes with simple addition "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Signed integers27/56 "},{"tags":[{"name":"paragraph"}],"text":" Twos complement: to form -X from X ... NEG all bits, then add 1 "},{"tags":[{"name":"paragraph"}],"text":" Now have only one representation for zero (00000000) "},{"tags":[{"name":"paragraph"}],"text":" Even better, x + -x = 0 in all cases with simple addition "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Always produces an \"overflow\" bit, but can ignore this "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Pointers28/56 "},{"tags":[{"name":"paragraph"}],"text":" Pointers represent memory addresses/locations "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Pointers29/56 "},{"tags":[{"name":"paragraph"}],"text":" Can \"move\" from object to object by pointer arithmetic "},{"tags":[{"name":"paragraph"}],"text":" For any pointer T *p;, p++ increases p by sizeof(T ) "},{"tags":[{"name":"paragraph"}],"text":" Examples (assuming 16-bit pointers): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" A common (efficient) paradigm for scanning a string "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Floating Point Numbers30/56 "},{"tags":[{"name":"paragraph"}],"text":" Floating point numbers model a (tiny) subset of ‚Ñù "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Floating Point Numbers31/56 "},{"tags":[{"name":"paragraph"}],"text":" C has two floating point types "},{"tags":[{"name":"paragraph"}],"text":" Display via printf "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" W gives total width (blank padded), P gives #digits after dec point "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Floating Point Numbers32/56 "},{"tags":[{"name":"paragraph"}],"text":" IEEE 754 standard ... "},{"tags":[{"name":"paragraph"}],"text":" Example of normalising in binary: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Floating Point Numbers33/56 "},{"tags":[{"name":"paragraph"}],"text":" Internal structure of floating point values "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" More complex than int because 1.dddd e dd "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Floating Point Numbers34/56 "},{"tags":[{"name":"paragraph"}],"text":" Details of internal structure "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" 00...00 = 24 zero bits, 11...11 = 24 one bits "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" 00...00 = 24 zero bits, 11...11 = 24 one bits "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Floating Point Numbers35/56 "},{"tags":[{"name":"paragraph"}],"text":" Example (single-precision): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" where red is sign bit, green is exponent, blue is fraction "},{"tags":[{"name":"paragraph"}],"text":" Note: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Arrays36/56 "},{"tags":[{"name":"paragraph"}],"text":" Arrays are defined to have N elements, each of type T "},{"tags":[{"name":"paragraph"}],"text":" Examples: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Elements are laid out adjacent in memory "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Arrays37/56 "},{"tags":[{"name":"paragraph"}],"text":" Assuming an array declaration like Type v[N ] ... "},{"tags":[{"name":"paragraph"}],"text":" Name of array can be treated as a pointer to element type Type "},{"tags":[{"name":"paragraph"}],"text":" Array indexing can be treated as v[i] ‚âÖ *(v+i) "},{"tags":[{"name":"paragraph"}],"text":" If have pointer to first element, can use it just like an array "},{"tags":[{"name":"paragraph"}],"text":" Strings are just arrays of char with a '\\0' terminator "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Arrays38/56 "},{"tags":[{"name":"paragraph"}],"text":" When arrays are \"passed\" to a function, actually pass &a[0] "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Arrays39/56 "},{"tags":[{"name":"paragraph"}],"text":" Arrays can be created automatically or via malloc() "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Two separate arrays (different &'s), but have same contents "},{"tags":[{"name":"paragraph"}],"text":" (except for the unitialised parts of the arrays) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Structs40/56 "},{"tags":[{"name":"paragraph"}],"text":" Structs are defined to have a number of components "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs41/56 "},{"tags":[{"name":"paragraph"}],"text":" Internal layout of struct components determined by compiler "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Each name maps to a byte offset within the struct "},{"tags":[{"name":"paragraph"}],"text":" E.g. in first example id = offset 0, given = offset 4, family = offset 54, etc. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs42/56 "},{"tags":[{"name":"paragraph"}],"text":" To ensure alignment, internal \"padding\" may be needed "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Padding wastes space; re-order fields to minimise waste. "},{"tags":[{"name":"paragraph"}],"text":" clang has -Wpadded to warn about padding in structs "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Exercise 1: Struct Alternatives43/56 "},{"tags":[{"name":"paragraph"}],"text":" Consider these two possible representations of Nodes in a linked list of strings: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Show how they would be (a) defined, (b) initialised. How large is each? "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Variable-length Structs44/56 "},{"tags":[{"name":"paragraph"}],"text":" Structs can contain pointers to dynamic objects "},{"tags":[{"name":"paragraph"}],"text":" But we can also \"embed\" one dynamic object in a malloc'd struct "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Variable-length Structs45/56 "},{"tags":[{"name":"paragraph"}],"text":" Amount of memory allocated to struct is determined dynamically: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Bit-wise Structs46/56 "},{"tags":[{"name":"paragraph"}],"text":" For fine-grained control over layout of fields in structs "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Has one component and three bit fields within that component. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Bit-wise Structs47/56 "},{"tags":[{"name":"paragraph"}],"text":" Two ways of declaring bit fields: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" In both cases, sizeof(struct _bit_fields) is 4 bytes. "},{"tags":[{"name":"paragraph"}],"text":" First way makes it clearer that a single unsigned int is used. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Bit-wise Structs48/56 "},{"tags":[{"name":"paragraph"}],"text":" Another example (graphics objects): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Bit-wise Structs49/56 "},{"tags":[{"name":"paragraph"}],"text":" The graphics object would be stored in memory as: "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Bit-wise Structs50/56 "},{"tags":[{"name":"paragraph"}],"text":" Bit-fields provide an alternative to bit operators and masks: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Unions51/56 "},{"tags":[{"name":"paragraph"}],"text":" Unions allow programmers to specify multiple interpretations for a single piece of memory. "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Unions52/56 "},{"tags":[{"name":"paragraph"}],"text":" Example of defining a union type (cf. struct): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" myUnion is a single 4-byte memory object "},{"tags":[{"name":"paragraph"}],"text":" Programmers can specify how to interpret bits using field names. "},{"tags":[{"name":"paragraph"}],"text":" In the example above, all components are coincidentally the same size (4 bytes) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Unions53/56 "},{"tags":[{"name":"paragraph"}],"text":" Difference between a struct and a union "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Unions54/56 "},{"tags":[{"name":"paragraph"}],"text":" General syntax for defining union types and variables: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Type can be any C type; Member names must be distinct "},{"tags":[{"name":"paragraph"}],"text":" sizeof(Union) is the size of the largest member "},{"tags":[{"name":"paragraph"}],"text":" &uvar.Member1 == &uvar.Member2 == &uvar.Member3 ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Unions55/56 "},{"tags":[{"name":"paragraph"}],"text":" Common use of union types: \"generic\" variables "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Enumerated Types56/56 "},{"tags":[{"name":"paragraph"}],"text":" Enumerated types allow programmers to define a set of distinct named values "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" The names are assigned consecutive int values, starting from 0 "},{"tags":[{"name":"paragraph"}],"text":" Above PrimaryColors type is equivalent to "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Variables of type enum... are effectively unsigned ints. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Produced: 1 Mar 2018 "}]}