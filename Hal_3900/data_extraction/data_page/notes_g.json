{"grouped":[{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Parallelism/Concurrency "}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Concurrency/Parallelism 2/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency/Parallelism 3/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency/Parallelism 4/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency/Parallelism 5/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Creating Concurrency 6/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Creating Concurrency 7/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Linux/Unix Threads 8/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Linux/Unix Threads 9/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Linux/Unix Threads 10/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Linux/Unix Threads 11/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Concurrency 12/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency 13/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency 14/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency 15/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Concurrency Control 16/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Concurrency Control 17/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Producer-Consumer Problem 18/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Producer-Consumer Problem 19/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Producer-Consumer Problem 20/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Producer-Consumer Problem 21/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Producer-Consumer Problem 22/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Semaphores 23/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Semaphores 24/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Semaphores 25/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Semaphores 26/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Semaphores 27/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Message Passing 28/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Passing 29/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Passing 30/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Passing 31/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Passing 32/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Passing 33/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Process Interaction "}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Interacting Processes 35/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Interacting Processes 36/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"File Locking 37/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... File Locking 38/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Pipes 39/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Pipes 40/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Pipes 41/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Pipes 42/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Pipes 43/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Pipes 44/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Message Queues 45/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Queues 46/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Queues 47/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Queues 48/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Queues 49/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Queues 50/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Message Queues 51/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Sockets 52/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 53/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 54/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 55/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 56/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 57/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 58/59"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Sockets 59/59"}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" e.g. multiple CPUs, one process on each CPU (MIMD) "},{"tags":[],"text":" e.g. data vector, one processor computes on each element (SIMD) "},{"tags":[],"text":" e.g. map-reduce: computation spread across multiple hosts "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" e.g. single CPU, alternating between processes (time-slicing) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" mutliple identical processors "},{"tags":[],"text":" each given one element of a data structure from main memory "},{"tags":[],"text":" each performing same computation on that element "},{"tags":[],"text":" results copied back to main memory data structure "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" manipulating very large data sets "},{"tags":[],"text":" on a large network of nodes (local or distributed) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" data distributed (shuffled) as (key,value) pairs "},{"tags":[],"text":" each node receives a set of pairs with common key(s) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" nodes perform calculation on received data items "},{"tags":[],"text":" and combine outputs from these calculations "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" child executes concurrently with parent "},{"tags":[],"text":" inherits some state from parent (e.g. open fd's) "},{"tags":[],"text":" runs in its own address space "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" process switching requires kernel intervention "},{"tags":[],"text":" each has a significant amount of state "},{"tags":[],"text":" process interaction requires system-level mechanisms "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" processes are independent of each other; threads exist within a (parent) process "},{"tags":[],"text":" processes have own state; threads share parent process state "},{"tags":[],"text":" each process has own address space; all threads within a process share one address space "},{"tags":[],"text":" processes communicate via IPC mechanisms (see later); threads can communicate via shared memory "},{"tags":[],"text":" context-switching between processes is expensive; context-switching between threads is (relatively) cheap "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" requires #include <pthread.h> "},{"tags":[],"text":" provides (opaque) pthread_t data type "},{"tags":[],"text":" functions on threads: create, identify, send signals, exit, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" creates a new thread with specified Attributes "},{"tags":[],"text":" thread info stored in *Thread "},{"tags":[],"text":" thread starts by executing Func() with Arg "},{"tags":[],"text":" returns 0 if OK, -1 otherwise and sets errno "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" returns pthread_t for current thread "},{"tags":[],"text":" in some ways, analogous to getpid() "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" compares two thread IDs "},{"tags":[],"text":" returns non-zero if same thread, 0 otherwise "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" suspend execution until thread T terminates "},{"tags":[],"text":" pthread_exit() value is placed in *value_ptr "},{"tags":[],"text":" if T has already exited, does not wait "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" terminate execution of thread, and do some cleaning up "},{"tags":[],"text":" stores a return value in *value_ptr "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" each process runs to completion before next one starts "},{"tags":[],"text":" low throughput; not acceptable on multi-user systems "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" if one process is delayed, others can run "},{"tags":[],"text":" if we have multiple CPUs, use all of them at once "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" each process runs and completes its task "},{"tags":[],"text":" without any effect on the computation of other processes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" multiple processes accessing a shared resource "},{"tags":[],"text":" one process synchronizing with another for some computation "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" nondeterminism ... same code, different runs, different results e.g. output on shared resource is jumbled e.g. input from shared resource is unpredictable "},{"tags":[],"text":" e.g. output on shared resource is jumbled "},{"tags":[],"text":" e.g. input from shared resource is unpredictable "},{"tags":[],"text":" deadlock ... a group of processes end up waiting for each other "},{"tags":[],"text":" starvation ... one process keeps missing access to resource "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" e.g. output on shared resource is jumbled "},{"tags":[],"text":" e.g. input from shared resource is unpredictable "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" each process attempts to withdraw($300, A) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" process 1 executes up to line 3, then swapped out "},{"tags":[],"text":" process 2 executes up to line 3, then swapped out "},{"tags":[],"text":" process 1 continues and reduces balance by $300 "},{"tags":[],"text":" process 2 continues and reduces balance by $300 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" provide correct sequencing of interactions between processes "},{"tags":[],"text":" coordinate semantically-valid access to shared resources "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" shared memory based (e.g. semaphores) "},{"tags":[],"text":" message passing based (e.g. send/receive) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" available via special library functions, or "},{"tags":[],"text":" available via new language constructs "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" uses shared variable, manipulated atomically "},{"tags":[],"text":" blocks if access unavailable, decrements once available "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" processes communicate by sending/receiving messages "},{"tags":[],"text":" receiver can block waiting for message to arrive "},{"tags":[],"text":" sender may block waiting for message to be received synchronous message passing: sender waits for ACK of receipt asynchronous message passing: sender transmits and continues "},{"tags":[],"text":" synchronous message passing: sender waits for ACK of receipt "},{"tags":[],"text":" asynchronous message passing: sender transmits and continues "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" synchronous message passing: sender waits for ACK of receipt "},{"tags":[],"text":" asynchronous message passing: sender transmits and continues "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" have a buffer with slots for N items "},{"tags":[],"text":" a process that produces new items and puts them in the buffer "},{"tags":[],"text":" a process that consumes items from the buffer "},{"tags":[],"text":" a mechanism for a process to pause itself "},{"tags":[],"text":" a mechanism for signalling a process to wake up "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" C checks nItems, finds zero, decides to pause "},{"tags":[],"text":" just before pausing, C is timed-out (different to paused) "},{"tags":[],"text":" P creates item, puts it in currently empty buffer "},{"tags":[],"text":" because buffer now has one item, P signals C "},{"tags":[],"text":" because C is not paused, signal is lost "},{"tags":[],"text":" C is resumed after time-out and pauses "},{"tags":[],"text":" P resumes and adds more items "},{"tags":[],"text":" eventually buffer fills and P pauses "},{"tags":[],"text":" each process is paused, waiting for signal from the other "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" init(Sem, InitValue) set the initial value of semaphore Sem "},{"tags":[],"text":" set the initial value of semaphore Sem "},{"tags":[],"text":" wait(Sem) (also called P()) if current value of Sem > 0, decrement Sem and continue otherwise, block and wait until Sem value > 0 "},{"tags":[],"text":" if current value of Sem > 0, decrement Sem and continue "},{"tags":[],"text":" otherwise, block and wait until Sem value > 0 "},{"tags":[],"text":" signal(Sem) (also called V()) increment value of Sem, and continue "},{"tags":[],"text":" increment value of Sem, and continue "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" set the initial value of semaphore Sem "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" if current value of Sem > 0, decrement Sem and continue "},{"tags":[],"text":" otherwise, block and wait until Sem value > 0 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" increment value of Sem, and continue "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" can be achieved via a FIFO queue (fair, but maybe not optimal) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" semaphores are updated atomically "},{"tags":[],"text":" so can't timeout in if (nItems == 0) pause() "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" only one process at a time manipulates the buffer "},{"tags":[],"text":" allows multiple producers/consumers to interact correctly "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" #include <semaphore.h>, giving sem_t "},{"tags":[],"text":" int sem_init(sem_t *Sem, int Shared, uint Value) create a semaphore object, and set initial value "},{"tags":[],"text":" create a semaphore object, and set initial value "},{"tags":[],"text":" int sem_wait(sem_t *Sem) (i.e. wait()) try to decrement; block if Sem == 0 "},{"tags":[],"text":" try to decrement; block if Sem == 0 "},{"tags":[],"text":" int sem_post(sem_t *Sem) (i.e. signal()) increment the value of semaphore Sem "},{"tags":[],"text":" increment the value of semaphore Sem "},{"tags":[],"text":" int sem_destroy(sem_t *Sem) free all memory associated with semaphore Sem "},{"tags":[],"text":" free all memory associated with semaphore Sem "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" create a semaphore object, and set initial value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" try to decrement; block if Sem == 0 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" increment the value of semaphore Sem "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" free all memory associated with semaphore Sem "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" source process sends a message to a target process "},{"tags":[],"text":" target process uses message to invoke appropriate code "},{"tags":[],"text":" may send a reply message containing the computed result "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" data is passed by copying value into a message (cf. parameters) "},{"tags":[],"text":" particularly effective for concurrent, distributed systems "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" synchronous sender transmits message, waits for response familiar programming model; like a (remote) function call "},{"tags":[],"text":" sender transmits message, waits for response "},{"tags":[],"text":" familiar programming model; like a (remote) function call "},{"tags":[],"text":" asynchronous sender transmits message, continues with own task reponse arrival eventually interrupts original sender "},{"tags":[],"text":" sender transmits message, continues with own task "},{"tags":[],"text":" reponse arrival eventually interrupts original sender "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" sender transmits message, waits for response "},{"tags":[],"text":" familiar programming model; like a (remote) function call "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" sender transmits message, continues with own task "},{"tags":[],"text":" reponse arrival eventually interrupts original sender "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" could occur on local processor, or across wide-area network "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" MPI_Init(..) ... initialises message passing environment "},{"tags":[],"text":" MPI_Send(..) ... send a message (synchronous) "},{"tags":[],"text":" MPI_Recv(..) ... send a message (synchronous) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" goroutines ... concurrently executing \"functions\" "},{"tags":[],"text":" channels ... communication pipes between goroutines "},{"tags":[],"text":" select ... manage multiple channels "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" signals: kill(), wait(), signal handlers "},{"tags":[],"text":" accessing the same resource (e.g. writing onto the same file) "},{"tags":[],"text":" pipes: stdout of process A goes into stdin of process B "},{"tags":[],"text":" message queues: passing data between each other "},{"tags":[],"text":" sockets: client-server style interaction "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" two processes writing to same file \"simultaneously\" "},{"tags":[],"text":" order of output depends on actions of (opaque) scheduler "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" controls access to shared files (note: files not fds) "},{"tags":[],"text":" possible operations LOCK_SH ... acquire shared lock LOCK_EX ... acquire exclusive lock LOCK_UN ... unlock LOCK_NB ... operation fails rather than blocking "},{"tags":[],"text":" LOCK_SH ... acquire shared lock "},{"tags":[],"text":" LOCK_EX ... acquire exclusive lock "},{"tags":[],"text":" LOCK_UN ... unlock "},{"tags":[],"text":" LOCK_NB ... operation fails rather than blocking "},{"tags":[],"text":" in blocking mode, flock() does not return until lock available "},{"tags":[],"text":" only works correctly if all processes accessing file use locks "},{"tags":[],"text":" return value: 0 in success, -1 on failure "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" LOCK_SH ... acquire shared lock "},{"tags":[],"text":" LOCK_EX ... acquire exclusive lock "},{"tags":[],"text":" LOCK_UN ... unlock "},{"tags":[],"text":" LOCK_NB ... operation fails rather than blocking "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" if file not locked or other shared locks, OK "},{"tags":[],"text":" if file has exclusive lock, blocked "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" if file is not locked, OK "},{"tags":[],"text":" if any locks (shared or exclusive) on file, blocked "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" flock() returns 0 if lock was acquired "},{"tags":[],"text":" flock() returns -1 if process would have been blocked "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" producer process writes to byte stream (cf. stdout) "},{"tags":[],"text":" consumer process reads from same byte stream "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" producer blocks when buffer full; consumer blocks when buffer empty "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" open two file descriptors (to be shared by processes) "},{"tags":[],"text":" fd[0] is opened for reading; fd[1] is opened for writing "},{"tags":[],"text":" return 0 if OK, otherwise return -1 and sets errno "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" fork() to create a child process "},{"tags":[],"text":" both processes have copies of fd[] "},{"tags":[],"text":" one can write to fd[1], the other can read from fd[0] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" set up a pipe between parent and child "},{"tags":[],"text":" exec() child to become a new process talking to parent "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" analogous to fopen, except first arg is a command "},{"tags":[],"text":" Cmd is passed to shell for interpretation "},{"tags":[],"text":" returns FILE* which be read/written depending on Mode "},{"tags":[],"text":" returns NULL if can't establish pipe or invalid Cmd "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" processes come initially from parent/child pair (fork) "},{"tags":[],"text":" connection established via shared file descriptions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" for unrelated processes to pass information "},{"tags":[],"text":" along a buffered channel shared by many processes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" MQ names look like \"/SomeCharacters \" (no slash chars) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" create a new message queue, or open existing one "},{"tags":[],"text":" Flags are like those for fopen() (e.g. O_RDONLY) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" finish accessing message queue MQ "},{"tags":[],"text":" the message queue continues to exist (cf. fclose()) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" adds message Msg to message queue MQ "},{"tags":[],"text":" Prio gives priority (determines order of messages on MQ) "},{"tags":[],"text":" if MQ is full ... blocks until MQ space available if O_NONBLOCK is set, fails and returns error "},{"tags":[],"text":" blocks until MQ space available "},{"tags":[],"text":" if O_NONBLOCK is set, fails and returns error "},{"tags":[],"text":" also, mq_timedsend() which waits for specified time if MQ full fails if still no space on MQ after timeout "},{"tags":[],"text":" waits for specified time if MQ full "},{"tags":[],"text":" fails if still no space on MQ after timeout "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" blocks until MQ space available "},{"tags":[],"text":" if O_NONBLOCK is set, fails and returns error "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" waits for specified time if MQ full "},{"tags":[],"text":" fails if still no space on MQ after timeout "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" removes highest priority message from queue MQ "},{"tags":[],"text":" if *Prio is not NULL, receives message priority "},{"tags":[],"text":" if MQ is empty ... blocks until a message is added to MQ if O_NONBLOCK is set, fails and returns error "},{"tags":[],"text":" blocks until a message is added to MQ "},{"tags":[],"text":" if O_NONBLOCK is set, fails and returns error "},{"tags":[],"text":" if several processes blocked on mq_receive() oldest and highest priority process receives the message "},{"tags":[],"text":" oldest and highest priority process receives the message "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" blocks until a message is added to MQ "},{"tags":[],"text":" if O_NONBLOCK is set, fails and returns error "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" oldest and highest priority process receives the message "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" assume that both processes are on the same host "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" e.g. web servers, networked databases, networked message queues, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" commonly used to construct client-server systems "},{"tags":[],"text":" either locally (Unix domain) or network-wide (Internet domain) "},{"tags":[],"text":" server creates a socket, then ... binds to an address (local or network) listens for connections from clients "},{"tags":[],"text":" binds to an address (local or network) "},{"tags":[],"text":" listens for connections from clients "},{"tags":[],"text":" client creates a socket, then ... connects to the server using known address writes to server via socket (i.e. sends requests) reads from server via socket (i.e. receives responses) "},{"tags":[],"text":" connects to the server using known address "},{"tags":[],"text":" writes to server via socket (i.e. sends requests) "},{"tags":[],"text":" reads from server via socket (i.e. receives responses) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" binds to an address (local or network) "},{"tags":[],"text":" listens for connections from clients "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" connects to the server using known address "},{"tags":[],"text":" writes to server via socket (i.e. sends requests) "},{"tags":[],"text":" reads from server via socket (i.e. receives responses) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" requires #include <sys/socket.h> "},{"tags":[],"text":" creates a socket, using ... Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"tags":[],"text":" Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) "},{"tags":[],"text":" AF_LOCAL ... on the local host (Unix domain) "},{"tags":[],"text":" AF_INET ... over the network (Internet domain) "},{"tags":[],"text":" Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"tags":[],"text":" SOCK_STREAM ... sequenced, reliable communications stream "},{"tags":[],"text":" SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"tags":[],"text":" Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"tags":[],"text":" many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"tags":[],"text":" returns a socket descriptor (small int) or -1 on error "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Domain ... communications domain AF_LOCAL ... on the local host (Unix domain) AF_INET ... over the network (Internet domain) "},{"tags":[],"text":" AF_LOCAL ... on the local host (Unix domain) "},{"tags":[],"text":" AF_INET ... over the network (Internet domain) "},{"tags":[],"text":" Type ... semantics of communication SOCK_STREAM ... sequenced, reliable communications stream SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"tags":[],"text":" SOCK_STREAM ... sequenced, reliable communications stream "},{"tags":[],"text":" SOCK_DGRAM ... connectionless, unreliable packet transfer "},{"tags":[],"text":" Protocol ... communication protocol many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "},{"tags":[],"text":" many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" AF_LOCAL ... on the local host (Unix domain) "},{"tags":[],"text":" AF_INET ... over the network (Internet domain) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" SOCK_STREAM ... sequenced, reliable communications stream "},{"tags":[],"text":" SOCK_DGRAM ... connectionless, unreliable packet transfer "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" many exist (see /etc/protocols), e.g. IP, TCP, UDP, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" associates an open socket with an address "},{"tags":[],"text":" for Unix Domain, address is a pathname in the file system "},{"tags":[],"text":" for Internet Domain, address is IP address + port number "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" wait for connections on socket Sockfd "},{"tags":[],"text":" allow at most Backlog connections to be queued up "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" sin_family ... domain: AF_UNIX or AF_INET "},{"tags":[],"text":" sin_port ... port number: 80, 443, etc. "},{"tags":[],"text":" sin_addr ... structure containing host address "},{"tags":[],"text":" sin_zero[8] ... padding "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Sockfd has been created, bound and is listening "},{"tags":[],"text":" blocks until a connection request is received "},{"tags":[],"text":" sets up a connection between client/server after connect() "},{"tags":[],"text":" places information about the requestor in Addr "},{"tags":[],"text":" returns a new socket descriptor, or -1 on error "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" connects the socket Sockfd to address Addr "},{"tags":[],"text":" assumes that Addr contains a process listening appropriately "},{"tags":[],"text":" returns 0 on success, or -1 on error "}]}],"block":[{"tags":[{"name":"paragraph"}],"text":"G: Parallelism/Concurrency"},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Parallelism/Concurrency "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Concurrency/Parallelism2/59 "},{"tags":[{"name":"paragraph"}],"text":" Parallelism = multiple computations executed simultaneously "},{"tags":[{"name":"paragraph"}],"text":" Both parallelism and concurrency need to deal with synchronisation. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency/Parallelism3/59 "},{"tags":[{"name":"paragraph"}],"text":" Example of SIMD parallel processing (e.g. GPU) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" But not totally independent: need to synchronise on completion "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency/Parallelism4/59 "},{"tags":[{"name":"paragraph"}],"text":" Map-reduce is a programming model for "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency/Parallelism5/59 "},{"tags":[{"name":"paragraph"}],"text":" Canonical example: compute word frequencies "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Creating Concurrency6/59 "},{"tags":[{"name":"paragraph"}],"text":" One method for creating concurrent tasks: "},{"tags":[{"name":"paragraph"}],"text":" fork() creates a new (child) process "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Creating Concurrency7/59 "},{"tags":[{"name":"paragraph"}],"text":" Alternative mechanism for concurrent tasks: threads "},{"tags":[{"name":"paragraph"}],"text":" Difference between threads and processes "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Linux/Unix Threads8/59 "},{"tags":[{"name":"paragraph"}],"text":" pThreads = POSIX implementation of threads "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Linux/Unix Threads9/59 "},{"tags":[{"name":"paragraph"}],"text":" int pthread_create(pthread_t *Thread, pthread_attr_t *Attr, void *(*Func)(void *), void *Arg) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Linux/Unix Threads10/59 "},{"tags":[{"name":"paragraph"}],"text":" pthread_t pthread_self(void) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Linux/Unix Threads11/59 "},{"tags":[{"name":"paragraph"}],"text":" int pthread_join(pthread_t T, void **value_ptr) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Concurrency12/59 "},{"tags":[{"name":"paragraph"}],"text":" The alternative to concurrency ... sequential execution "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency13/59 "},{"tags":[{"name":"paragraph"}],"text":" In reality, processes are often not independent "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency14/59 "},{"tags":[{"name":"paragraph"}],"text":" Example of problematic concurrency ... bank withdrawal: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Scenario: two processes, one account A, initial balance $500 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency15/59 "},{"tags":[{"name":"paragraph"}],"text":" Restatement of program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Possible outcome of scenario: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Concurrency Control16/59 "},{"tags":[{"name":"paragraph"}],"text":" Concurrency control aims to "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Concurrency Control17/59 "},{"tags":[{"name":"paragraph"}],"text":" Shared memory approach: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Producer-Consumer Problem18/59 "},{"tags":[{"name":"paragraph"}],"text":" Classic example for concurrency control issues "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Producer-Consumer Problem19/59 "},{"tags":[{"name":"paragraph"}],"text":" Data objects shared by two processes: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Functions on buffer (simplified view): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Producer-Consumer Problem20/59 "},{"tags":[{"name":"paragraph"}],"text":" Producer process (P): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Producer-Consumer Problem21/59 "},{"tags":[{"name":"paragraph"}],"text":" Consumer process (C): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Producer-Consumer Problem22/59 "},{"tags":[{"name":"paragraph"}],"text":" A possible scenario (assumes signals only reach paused processes) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Semaphores23/59 "},{"tags":[{"name":"paragraph"}],"text":" Semaphore operations: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Semaphores24/59 "},{"tags":[{"name":"paragraph"}],"text":" Using semaphores for the producer-consumer problem: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" The mutex semaphore ensures that "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Semaphores25/59 "},{"tags":[{"name":"paragraph"}],"text":" Using semaphores for the producer-consumer problem (cont) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Semaphores26/59 "},{"tags":[{"name":"paragraph"}],"text":" Using semaphores for the producer-consumer problem (cont) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Semaphores27/59 "},{"tags":[{"name":"paragraph"}],"text":" Semaphores on Linux/Unix ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Message Passing28/59 "},{"tags":[{"name":"paragraph"}],"text":" Message passing = a method for invoking computations "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Passing29/59 "},{"tags":[{"name":"paragraph"}],"text":" Message passing systems can be ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Passing30/59 "},{"tags":[{"name":"paragraph"}],"text":" Message passing architecture "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Passing31/59 "},{"tags":[{"name":"paragraph"}],"text":" A standard message passing framework (MPI) has been defined "},{"tags":[{"name":"paragraph"}],"text":" Bindings exist for many languages (e.g. C, C++, Java, Python, ...) "},{"tags":[{"name":"paragraph"}],"text":" Other languages have message passing built in "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Passing32/59 "},{"tags":[{"name":"paragraph"}],"text":" Example of message passing with language support: Google's Go "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Passing33/59 "},{"tags":[{"name":"paragraph"}],"text":" Bank withdrawal example using Go: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" For more info on Go, see https://tour.golang.org/ "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Process Interaction "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Interacting Processes35/59 "},{"tags":[{"name":"paragraph"}],"text":" Processes can interact via "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Interacting Processes36/59 "},{"tags":[{"name":"paragraph"}],"text":" Example of problematic process interaction: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Could control access to file via semaphores "},{"tags":[{"name":"paragraph"}],"text":" An alternative (less general) mechanism: file locking "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" File Locking37/59 "},{"tags":[{"name":"paragraph"}],"text":" int flock(int FileDesc, int Operation) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... File Locking38/59 "},{"tags":[{"name":"paragraph"}],"text":" If a process tries to acquire a shared lock ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Pipes39/59 "},{"tags":[{"name":"paragraph"}],"text":" A common style of process interaction (communication) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" A pipe provides buffered i/o between producer and consumer "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Pipes40/59 "},{"tags":[{"name":"paragraph"}],"text":" int pipe(int fd[2]) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Pipes41/59 "},{"tags":[{"name":"paragraph"}],"text":" Creating a pipe ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Pipes42/59 "},{"tags":[{"name":"paragraph"}],"text":" Example: setting up a pipe "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Pipes43/59 "},{"tags":[{"name":"paragraph"}],"text":" A common pattern in pipe usage "},{"tags":[{"name":"paragraph"}],"text":" FILE *popen(char *Cmd, char *Mode) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Pipes44/59 "},{"tags":[{"name":"paragraph"}],"text":" Example of popen() "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Message Queues45/59 "},{"tags":[{"name":"paragraph"}],"text":" Pipes operate between two processes on same host "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Queues46/59 "},{"tags":[{"name":"paragraph"}],"text":" Message queue architecture "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Queues47/59 "},{"tags":[{"name":"paragraph"}],"text":" Requires #include <mqueue.h>, giving mqd_t "},{"tags":[{"name":"paragraph"}],"text":" mqd_t mq_open(char *Name, int Flags) "},{"tags":[{"name":"paragraph"}],"text":" int mq_close(mqd_t *MQ) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Queues48/59 "},{"tags":[{"name":"paragraph"}],"text":" int mq_send(mqd_t MQ, char *Msg, int Size, uint Prio) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Queues49/59 "},{"tags":[{"name":"paragraph"}],"text":" int mq_receive(mqd_t MQ, char *Msg, int Size, uint *Prio) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Queues50/59 "},{"tags":[{"name":"paragraph"}],"text":" Pseudo-code showing structure of a MQ server program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Message Queues51/59 "},{"tags":[{"name":"paragraph"}],"text":" Pseudo-code showing structure of a MQ client program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Sockets52/59 "},{"tags":[{"name":"paragraph"}],"text":" Inter-process communication (IPC) mechanisms considered so far "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets53/59 "},{"tags":[{"name":"paragraph"}],"text":" Socket = an end-point of an IPC channel "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets54/59 "},{"tags":[{"name":"paragraph"}],"text":" int socket(int Domain, int Type, int Protocol) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets55/59 "},{"tags":[{"name":"paragraph"}],"text":" int bind(int Sockfd, SockAddr *Addr, socklen_t AddrLen) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets56/59 "},{"tags":[{"name":"paragraph"}],"text":" SockAddr = struct sockaddr_in "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets57/59 "},{"tags":[{"name":"paragraph"}],"text":" int accept(int Sockfd, SockAddr *Addr, socklen_t *AddrLen) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets58/59 "},{"tags":[{"name":"paragraph"}],"text":" Pseudo-code showing structure of a simple client program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" (See http://www.linuxhowtos.org/C_C++/socket.htm) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Sockets59/59 "},{"tags":[{"name":"paragraph"}],"text":" Pseudo-code showing structure of a server program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Produced: 2 May 2018 "}]}