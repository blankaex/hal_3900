{"grouped":[{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Instruction Set Architectures "}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"CPU Architecture 2/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Why Study Assembler? 3/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Instruction Sets 4/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Instruction Sets 5/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Instruction Sets 6/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Instruction Sets 7/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Instruction Sets 8/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Fetch-Execute Cycle 9/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Fetch-Execute Cycle 10/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Assembly Language 11/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Assembly Language 12/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS Architecture 13/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS vs SPIM 14/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Using SPIM 15/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Using SPIM 16/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Using SPIM 17/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS Machine Archtecture 18/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Machine Archtecture 19/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Reg ,Name, ,Notes"},{"tags":[],"text":"$0 ,zero, ,the value 0, not changeable"},{"tags":[],"text":"$1 ,$at, ,assembler temporary; used to implement pseudo-ops"},{"tags":[],"text":"$2 ,$v0, ,value from expression evaluation or function return"},{"tags":[],"text":"$3 ,$v1, ,value from expression evaluation or function return"},{"tags":[],"text":"$4 ,$a0, ,first argument to a function/subroutine, if needed"},{"tags":[],"text":"$5 ,$a1, ,second argument to a function/subroutine, if needed"},{"tags":[],"text":"$6 ,$a2, ,third argument to a function/subroutine, if needed"},{"tags":[],"text":"$7 ,$a3, ,fourth argument to a function/subroutine, if needed"},{"tags":[],"text":"$8..$15 ,$t0..$t7, ,temporary; must be saved by caller to subroutine;subroutine can overwrite"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Machine Archtecture 20/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Reg ,Name, ,Notes"},{"tags":[],"text":"$16..$23 ,$s0..$s7, ,safe function variable;must not be overwritten by called subroutine"},{"tags":[],"text":"$24..$25 ,$t8..$t9, ,temporary; must be saved by caller to subroutine;subroutine can overwrite"},{"tags":[],"text":"$26..$27 ,$k0..$k1, ,for kernel use; may change unexpectedly"},{"tags":[],"text":"$28 ,$gp, ,global pointer"},{"tags":[],"text":"$29 ,$sp, ,stack pointer"},{"tags":[],"text":"$30 ,$fp, ,frame pointer"},{"tags":[],"text":"$31 ,$ra, ,return address of most recent caller"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Machine Archtecture 21/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Reg ,Notes"},{"tags":[],"text":""},{"tags":[],"text":"$f0..$f2 ,hold floating-point function results"},{"tags":[],"text":"$f4..$f10 ,temporary registers; not preserved across function calls"},{"tags":[],"text":"$f12..$f14 ,used for first two double-precision function arguments"},{"tags":[],"text":"$f16..$f18 ,temporary registers; used for expression evaluation"},{"tags":[],"text":"$f20..$f30 ,saved registers; value is preserved across function calls"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS Assembly Language 22/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Assembly Language 23/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Assembly Language 24/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Assembly Language 25/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Assembly Language 26/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Region ,Address, ,Notes"},{"tags":[],"text":"text ,0x00400000, ,contains only instructions; read-only; cannot expand"},{"tags":[],"text":"data ,0x10000000, ,data objects; readable/writeable; can be expanded"},{"tags":[],"text":"stack ,0x7fffefff, ,grows down from that address; readable/writeable"},{"tags":[],"text":"k_text ,0x80000000, ,kernel code; read-only; only accessible kernel mode"},{"tags":[],"text":"k_data ,0x90000000, ,kernel data; read/write; only accessible kernel mode"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS Instructions 27/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instructions 28/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Addressing Modes 29/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Addressing Modes 30/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Format ,Address computation"},{"tags":[],"text":"(register) ,address = *register = contents of register"},{"tags":[],"text":"k ,address = k"},{"tags":[],"text":"k(register) ,address = k + *register"},{"tags":[],"text":"symbol ,address = &symbol = address of symbol"},{"tags":[],"text":"symbol ± k ,address = &symbol ± k"},{"tags":[],"text":"symbol ± k(register) ,address = &symbol ± (k + *register)"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Addressing Modes 31/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Operand Sizes 32/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS Instruction Set 33/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 34/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Syntax Semantics"},{"tags":[],"text":"$Reg as source, the content of the register, reg[Reg]"},{"tags":[],"text":"$Reg as destination, value is stored in register, reg[Reg] = value"},{"tags":[],"text":"Label references the associated address (in C terms, &Label)"},{"tags":[],"text":"Addr any expression that yields an address (e.g. Label($Reg))"},{"tags":[],"text":"Addr as source, the content of memory cell memory[Addr]"},{"tags":[],"text":"Addr as destination, value is stored in memory[Addr] = value"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 35/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 36/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 37/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 38/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 39/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Service Code,Arguments,Result"},{"tags":[],"text":"print_int 1,$a0 = integer, "},{"tags":[],"text":"print_float 2,$f12 = float, "},{"tags":[],"text":"print_double 3,$f12 = double, "},{"tags":[],"text":"print_string 4,$a0 = char *, "},{"tags":[],"text":"read_int 5, ,integer in $v0"},{"tags":[],"text":"read_float 6, ,float in $f0"},{"tags":[],"text":"read_double 7, ,double in $f0"},{"tags":[],"text":"read_string 8,$a0 = buffer, $a1 = length,string in buffer (including \"\\n\\0\")"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Instruction Set 40/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"MIPS Programming 41/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Programming 42/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Programming 43/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Programming 44/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... MIPS Programming 45/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Rendering C in MIPS 46/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Rendering C in MIPS 47/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Arithmetic Expressions 48/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Conditional Statements 49/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Conditional Statements 50/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Conditional Statements 51/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Conditional Statements 52/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Conditional Statements 53/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Boolean Expressions 54/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Boolean Expressions 55/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Iteration Statements 56/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Iteration Statements 57/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Functions 58/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 59/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 60/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 61/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 62/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 63/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Aside: MIPS Branch Delay Slots 64/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Aside: Why do we need both $fp and $sp? 65/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Function Calling Protocol 66/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Calling Protocol 67/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Calling Protocol 68/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Calling Protocol 69/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Calling Protocol 70/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Calling Protocol 71/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Calling Protocol 72/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Structure of Functions 73/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Function Prologue 74/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Prologue 75/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Prologue 76/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Prologue 77/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Function Epilogue 78/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Function Epilogue 79/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Data Structures and MIPS 80/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Static vs Dynamic Allocation 81/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Static vs Dynamic Allocation 82/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Static vs Dynamic Allocation 83/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Static vs Dynamic Allocation 84/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Static vs Dynamic Allocation 85/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Static vs Dynamic Allocation 86/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"1-d Arrays in MIPS 87/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 1-d Arrays in MIPS 88/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 1-d Arrays in MIPS 89/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 1-d Arrays in MIPS 90/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"2-d Arrays in MIPS 91/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 2-d Arrays in MIPS 92/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 2-d Arrays in MIPS 93/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 2-d Arrays in MIPS 94/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... 2-d Arrays in MIPS 95/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Structs in MIPS 96/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs in MIPS 97/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs in MIPS 98/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs in MIPS 99/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs in MIPS 100/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs in MIPS 101/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Structs in MIPS 102/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Compiling C to MIPS 103/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"C Pre-processor 104/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... C Pre-processor 105/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"C Parser 106/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Symbol Table Management 107/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Local Variables 108/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Expression Evaluation 109/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Mapping Control Structures 110/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Mapping Control Structures 111/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":" Argc and Argv 112/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Argc and Argv 113/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Argc and Argv 114/114"}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" a set of data registers "},{"tags":[],"text":" a set of control registers (incl PC) "},{"tags":[],"text":" an arithmetic-logic unit (ALU) "},{"tags":[],"text":" access to random access memory (RAM) "},{"tags":[],"text":" a set of simple instructions transfer data between memory and registers push values through the ALU to compute results make tests and transfer control of execution "},{"tags":[],"text":" transfer data between memory and registers "},{"tags":[],"text":" push values through the ALU to compute results "},{"tags":[],"text":" make tests and transfer control of execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" transfer data between memory and registers "},{"tags":[],"text":" push values through the ALU to compute results "},{"tags":[],"text":" make tests and transfer control of execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" e.g. different # registers, different sized registers, different instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" sometimes you are required to use it (e.g. device handlers) "},{"tags":[],"text":" improves your understanding of how C programs execute very helpful when debugging able to avoid using known inefficient constructs "},{"tags":[],"text":" very helpful when debugging "},{"tags":[],"text":" able to avoid using known inefficient constructs "},{"tags":[],"text":" uber-nerdy performance tweaking (squeezing out last nano-s) re-write that critical (frequently-used) function in assembler "},{"tags":[],"text":" re-write that critical (frequently-used) function in assembler "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" very helpful when debugging "},{"tags":[],"text":" able to avoid using known inefficient constructs "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" re-write that critical (frequently-used) function in assembler "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" small(ish) set of simple, general instructions "},{"tags":[],"text":" separate computation & data transfer instructions "},{"tags":[],"text":" leading to simpler processor hardware "},{"tags":[],"text":" e.g. MIPS, RISC, Alpha, SPARC, PowerPC, ARM, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" large(r) set of powerful instructions "},{"tags":[],"text":" each instruction has multiple actions (comp+store) "},{"tags":[],"text":" more circuitry to decode/process instructions "},{"tags":[],"text":" e.g. PDP, VAX, Z80, Motorola 68xxx, Intel x86, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" typically have 1-2 32-bit words per instruction "},{"tags":[],"text":" partition bits in each word into operator & operands "},{"tags":[],"text":" #bits for each depends on #instructions, #registers, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" load Register, MemoryAddress copy value stored in memory at address into named register "},{"tags":[],"text":" copy value stored in memory at address into named register "},{"tags":[],"text":" loadc Register, ConstantValue copy value into named register "},{"tags":[],"text":" copy value into named register "},{"tags":[],"text":" store Register, MemoryAddress copy value stored in named register into memory at address "},{"tags":[],"text":" copy value stored in named register into memory at address "},{"tags":[],"text":" jump MemoryAddress transfer execution of program to instruction at address "},{"tags":[],"text":" transfer execution of program to instruction at address "},{"tags":[],"text":" jumpif Register, MemoryAddress transfer execution of program if e.g. register holds zero value "},{"tags":[],"text":" transfer execution of program if e.g. register holds zero value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" copy value stored in memory at address into named register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" copy value into named register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" copy value stored in named register into memory at address "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" transfer execution of program to instruction at address "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" transfer execution of program if e.g. register holds zero value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" add Register1, Register2, Register3 (similarly for sub, mul, div) Register3 = Register1 + Register2 "},{"tags":[],"text":" Register3 = Register1 + Register2 "},{"tags":[],"text":" and Register1, Register2, Register3 (similarly for or, xor) Register3 = Register1 & Register2 "},{"tags":[],"text":" Register3 = Register1 & Register2 "},{"tags":[],"text":" neg Register1, Register2 Register2 = ~ Register1 "},{"tags":[],"text":" Register2 = ~ Register1 "},{"tags":[],"text":" shiftl Register1, Value, Register2 (similarly for shiftr) Register2 = Register1 << Value "},{"tags":[],"text":" Register2 = Register1 << Value "},{"tags":[],"text":" syscall Value invoke a system service; which service determined by Value "},{"tags":[],"text":" invoke a system service; which service determined by Value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Register3 = Register1 + Register2 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Register3 = Register1 & Register2 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Register2 = ~ Register1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Register2 = Register1 << Value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" invoke a system service; which service determined by Value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" determine what the operator is "},{"tags":[],"text":" determine which registers, if any, are involved "},{"tags":[],"text":" determine which memory location, if any, is involved "},{"tags":[],"text":" carry out the operation with the relevant operands "},{"tags":[],"text":" store result, if any, in appropriate register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" write instructions using mnemonics rather than hex codes "},{"tags":[],"text":" reference registers using either numbers or names "},{"tags":[],"text":" can associate names to memory addresses "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" need to use fine-grained control of memory usage "},{"tags":[],"text":" required to manipulate data in registers "},{"tags":[],"text":" control structures programmed via explicit jumps "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" very popular in a range of computing devices in the 1990's "},{"tags":[],"text":" e.g. Silicon Graphics, NEC, Nintendo64, Playstation, supercomputers "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" using two variants of the open-source SPIM emulator "},{"tags":[],"text":" qtspim ... provides a GUI front-end, useful for debugging "},{"tags":[],"text":" spim ... command-line based version, useful for testing "},{"tags":[],"text":" xspim ... GUI front-end, useful for debugging, only in CSE labs "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" reads text files containing instruction + directives "},{"tags":[],"text":" converts to machine code and loads into \"memory\" "},{"tags":[],"text":" provides debugging capabilities single-step, breakpoints, view registers/memory, ... "},{"tags":[],"text":" single-step, breakpoints, view registers/memory, ... "},{"tags":[],"text":" provides mechanism to interact with operating system (syscall) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" single-step, breakpoints, view registers/memory, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" provide convenient/mnemonic ways to do common operations "},{"tags":[],"text":" e.g. move $s0,$v0 rather than addu $s0,$0,$v0 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" spim ... command line tool load programs using -file option interact using stdin/stdout via login terminal "},{"tags":[],"text":" load programs using -file option "},{"tags":[],"text":" interact using stdin/stdout via login terminal "},{"tags":[],"text":" qtspim ... GUI environment load programs via a load button interact via a pop-up stdin/stdout terminal "},{"tags":[],"text":" load programs via a load button "},{"tags":[],"text":" interact via a pop-up stdin/stdout terminal "},{"tags":[],"text":" xspim ... GUI environment similar to qtspim, but not as pretty requires X-windows server "},{"tags":[],"text":" similar to qtspim, but not as pretty "},{"tags":[],"text":" requires X-windows server "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" load programs using -file option "},{"tags":[],"text":" interact using stdin/stdout via login terminal "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" load programs via a load button "},{"tags":[],"text":" interact via a pop-up stdin/stdout terminal "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" similar to qtspim, but not as pretty "},{"tags":[],"text":" requires X-windows server "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 32 × 32-bit general purpose registers "},{"tags":[],"text":" 16 × 64-bit double-precision registers "},{"tags":[],"text":" PC ... 32-bit register (always aligned on 4-byte boundary) "},{"tags":[],"text":" HI,LO ... for storing results of multiplication and division "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" register $0 always has value 0, cannot be written "},{"tags":[],"text":" registers $1, $26, $27 reserved for use by system "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" registers come in pairs of 2 × 32-bits "},{"tags":[],"text":" only even registers are addressed for double-precision "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" comments ... introduced by # "},{"tags":[],"text":" labels ... appended with : "},{"tags":[],"text":" directives ... symbol beginning with . "},{"tags":[],"text":" assembly language instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" data objects that live in the data region "},{"tags":[],"text":" functions (instruction sequences) that live in the code/text region "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" load and store .. transfer data between registers and memory "},{"tags":[],"text":" computational ... perform arithmetic/logical operations "},{"tags":[],"text":" jump and branch ... transfer control of program execution "},{"tags":[],"text":" coprocessor ... standard interface to various co-processors "},{"tags":[],"text":" special ... miscellaneous tasks (e.g. syscall) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" between memory and register (direct, indirect) "},{"tags":[],"text":" constant to register (immediate) "},{"tags":[],"text":" register + register + destination register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" an operation (e.g. load, store, add, branch, ...) "},{"tags":[],"text":" one or more operands (e.g. registers, memory addresses, constants) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" symbolic name (label) (effectively, a constant) "},{"tags":[],"text":" indirectly via a register (effectively, pointer dereferencing) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" computed address for a: is 0x100000008 "},{"tags":[],"text":" computed address for b: is 0x100000000 "},{"tags":[],"text":" computed address for c: is 0x100000004 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" single bytes, two bytes (\"halfword\"), four bytes (\"word\") "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" LB ... load one byte from specified address "},{"tags":[],"text":" LBU ... load unsigned byte from specified address "},{"tags":[],"text":" LH ... load two bytes from specified address "},{"tags":[],"text":" LHU ... load unsigned 2-bytes from specified address "},{"tags":[],"text":" LW ... load four bytes (one word) from specified address "},{"tags":[],"text":" LA ... load the specified address "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" lw, sw, add, sub, and, or, sll, slt, beq, j, jal, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" move, rem, la, li, blt, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" treat registers as unsigned int reg[32] "},{"tags":[],"text":" treat memory as unsigned char mem[232] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" develop the solution in C "},{"tags":[],"text":" map to \"simplified\" C "},{"tags":[],"text":" translate each simplified C statement to MIPS instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" does not have while, switch, complex expressions "},{"tags":[],"text":" does have simple if, goto, one-operator expressions "},{"tags":[],"text":" does not have function calls and auto local variables "},{"tags":[],"text":" does have jump-and-remember-where-you-came-from "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" labels ... symbolic name for C statement "},{"tags":[],"text":" goto ... transfer control to labelled statement "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" follow the conventions implied by register names "},{"tags":[],"text":" preserve values that need to be saved across function calls "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" you manage register usage as you like "},{"tags":[],"text":" typically making use of $t? registers "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" you transfer control to a separate piece of code "},{"tags":[],"text":" which may change the value of any non-preserved register "},{"tags":[],"text":" $s? registers must be preserved by function "},{"tags":[],"text":" $a?, $v?, $t? registers may be modified by function "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" x = (1 + y*y) / 2; z = 1.0 / 2; ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" move Rd,Rs, li Rd,Const, add, div, and, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" sequence (;), if, while, for, break, continue, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" seq, slti, sltu, ..., beq, bgtz, bgezal, ..., j, jr, jal, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" describing the process as a sequence of binary operations "},{"tags":[],"text":" managing data flow between the operations "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" works best for small, dense range of case values (e.g. 1..10) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" evaluate Cond1; if 0 then return 0 for whole expression "},{"tags":[],"text":" evaluate Cond2; if 0 then return 0 for whole expression "},{"tags":[],"text":" ... "},{"tags":[],"text":" evaluate Condn; if 0 then return 0 for whole expression "},{"tags":[],"text":" otherwise, return 1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" evaluate Cond1; if !0 then return 1 for whole expression "},{"tags":[],"text":" evaluate Cond2; if !0 then return 1 for whole expression "},{"tags":[],"text":" ... "},{"tags":[],"text":" evaluate Condn; if !0 then return 1 for whole expression "},{"tags":[],"text":" otherwise, return 1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" the arguments are evaluated and set up for function "},{"tags":[],"text":" control is transferred to the code for the function "},{"tags":[],"text":" local variables are created "},{"tags":[],"text":" the function code is executed in this environment "},{"tags":[],"text":" the return value is set up "},{"tags":[],"text":" control transfers back to where the function was called from "},{"tags":[],"text":" the caller receives the return value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" used for: saved registers, local variables, parameters to callees "},{"tags":[],"text":" created in the function prologue (pushed) "},{"tags":[],"text":" removed in the function epilogue (popped) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" function f() calls g() which calls h() "},{"tags":[],"text":" h() runs, then finishes and returns to g() "},{"tags":[],"text":" g() continues, then finishes and returns to f() "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" caller saved registers (saved by f()) f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" e.g. $t0 .. $t9, $a0 .. $a3, $ra "},{"tags":[],"text":" f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" "},{"tags":[],"text":" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" "},{"tags":[],"text":" e.g. $t0 .. $t9, $a0 .. $a3, $ra "},{"tags":[],"text":" callee saved registers (saved by g()) f() tells g() \"I assume the values of these registers will be unchanged when you return\" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" e.g. $s0 .. $s7, $sp, $fp "},{"tags":[],"text":" f() tells g() \"I assume the values of these registers will be unchanged when you return\" "},{"tags":[],"text":" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" "},{"tags":[],"text":" e.g. $s0 .. $s7, $sp, $fp "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" "},{"tags":[],"text":" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" "},{"tags":[],"text":" e.g. $t0 .. $t9, $a0 .. $a3, $ra "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" f() tells g() \"I assume the values of these registers will be unchanged when you return\" "},{"tags":[],"text":" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" "},{"tags":[],"text":" e.g. $s0 .. $s7, $sp, $fp "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" one instruction can start before the previous one finishes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" instruction following branch is executed before branch completes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" $sp can change (e.g. pushing params, adding local vars) "},{"tags":[],"text":" may need to reference local vars on the stack "},{"tags":[],"text":" useful if they can be defined by an offset relative to fixed point "},{"tags":[],"text":" $fp provides a fixed point during function code execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" place 64-bit double args in $f12 and $f14 "},{"tags":[],"text":" place 32-bit arguments in the $a0..$a3 "},{"tags":[],"text":" if more than 4 args, or args larger than 32-bits ... push value of all such args onto stack "},{"tags":[],"text":" push value of all such args onto stack "},{"tags":[],"text":" save any non-$s? registers that need to be preserved push value of all such registers onto stack "},{"tags":[],"text":" push value of all such registers onto stack "},{"tags":[],"text":" jal address of function (usually given by a label) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" push value of all such args onto stack "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" push value of all such registers onto stack "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" create a stack frame for itself (change $fp and $sp) "},{"tags":[],"text":" save the return address ($ra) in the stack frame "},{"tags":[],"text":" save any $s? registers that it plans to change "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 4 bytes for saved $fp + 4 bytes for saved $ra "},{"tags":[],"text":" + 4 bytes for each saved $s? "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" new $fp = old $sp - 4 "},{"tags":[],"text":" new $sp = old $sp - size of frame (in bytes) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" place the return value in $v0 (and maybe $v1) "},{"tags":[],"text":" pop any pushed arguments off the stack "},{"tags":[],"text":" restore the values of any saved $s? registers "},{"tags":[],"text":" restore the saved value of $ra (return address) "},{"tags":[],"text":" remove its stack frame (change $fp and $sp) "},{"tags":[],"text":" return to the calling function (jr $ra) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" new $sp = old $fp + 4 "},{"tags":[],"text":" new $fp = memory[old $fp] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" char ... as byte in memory, or low-order byte in register "},{"tags":[],"text":" int ... as word in memory, or whole register "},{"tags":[],"text":" double ... as two-words in memory, or $f? register "},{"tags":[],"text":" arrays ... sequence of memory bytes/words, accessed by index "},{"tags":[],"text":" structs ... chunk of memory, accessed by fields/offsets "},{"tags":[],"text":" linked structures ... struct containing address of another struct "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" could be implemented in register if used in small scope "},{"tags":[],"text":" could be implemented on stack if local to function "},{"tags":[],"text":" could be implemented in .data if need longer persistence "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" uninitialised memory allocated at compile/assemble-time, e.g. int val; val: .space 4 char str[20]; str: .space 20 int vec[20]; vec: .space 80 "},{"tags":[],"text":" initialised memory allocated at compile/assemble-time, e.g. int val = 5; val: .word 5 int arr[4] = {9,8,7,6}; arr: .word 9, 8, 7, 6 char *msg = \"Hello\\n\"; msg: .asciiz \"Hello\\n\" "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" variables local to a function "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" use space allocated on stack during function prologue "},{"tags":[],"text":" referenced during function relative to $fp "},{"tags":[],"text":" space reclaimed from stack in function epilogue "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" uninitialised block of memory allocated at run-time int *ptr = malloc(sizeof(int)); char *str = malloc(20*sizeof(char)); int *vec = malloc(20*sizeof(int)); *ptr = 5; strcpy(str, \"a string\"); vec[0] = 1; // or *vec = 1; vec[1] = 6; "},{"tags":[],"text":" initialised block of memory allocated at run-time int *vec = calloc(20, sizeof(int)); // vec[i] == 0, for i in 0..19 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" but provides syscall 9 to extend .data "},{"tags":[],"text":" before syscall, set $a0 to the number of bytes requested "},{"tags":[],"text":" after syscall, $v0 holds start address of allocated chunk "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" a complete implementation of C's heap management, i.e. "},{"tags":[],"text":" a large region of memory to manage (syscall 9) "},{"tags":[],"text":" ability to mark chunks of this region as \"in use\" (with size) "},{"tags":[],"text":" ability to maintain list of free chunks "},{"tags":[],"text":" ability to merge free chunks to prevent fragmentation "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" either approach needs to account for size of elements "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" must also pass array size, since not available elsewhere "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" makes things easier for a human to prodcue MIPS code "},{"tags":[],"text":" does not provide an automatic way of translating "},{"tags":[],"text":" this is provided by a compiler (e.g. dcc) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" convert #include and #define "},{"tags":[],"text":" parse code to check syntactically valid "},{"tags":[],"text":" manage a list of symbols used in program "},{"tags":[],"text":" decide how to represent data structures "},{"tags":[],"text":" allocate local variables to registers or stack "},{"tags":[],"text":" map control structures to MIPS instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" #include File replace #include by contents of file \"name.h\" ... uses named File.h <name.h> ... uses File.h in /usr/include "},{"tags":[],"text":" replace #include by contents of file "},{"tags":[],"text":" \"name.h\" ... uses named File.h "},{"tags":[],"text":" <name.h> ... uses File.h in /usr/include "},{"tags":[],"text":" #define Name Constant replace all occurences of symbol Name by Constant e.g #define MAX 5 char array[MAX] → char array[5] "},{"tags":[],"text":" replace all occurences of symbol Name by Constant "},{"tags":[],"text":" e.g #define MAX 5 char array[MAX] → char array[5] "},{"tags":[],"text":" #define Name(Params) Expression replace Name(Params) by SubstitutedExpression e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "},{"tags":[],"text":" replace Name(Params) by SubstitutedExpression "},{"tags":[],"text":" e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" replace #include by contents of file "},{"tags":[],"text":" \"name.h\" ... uses named File.h "},{"tags":[],"text":" <name.h> ... uses File.h in /usr/include "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" replace all occurences of symbol Name by Constant "},{"tags":[],"text":" e.g #define MAX 5 char array[MAX] → char array[5] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" replace Name(Params) by SubstitutedExpression "},{"tags":[],"text":" e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" scope, lifetime, locally/externally defined "},{"tags":[],"text":" disambiguates e.g. x in main() vs x in fun() "},{"tags":[],"text":" resolves symbols to specific locations (data/stack/registers) "},{"tags":[],"text":" external symbols may remain unresolved until linking "},{"tags":[],"text":" however, need to have a type for each external symbol "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" on the stack ... +persist for whole function, -lw/sw needed in MIPS "},{"tags":[],"text":" in a register ... +efficient, -not many, useful if var used in small scope if need to persist across function calls, use $s? register if used in very localised scope, can use $t? register "},{"tags":[],"text":" if need to persist across function calls, use $s? register "},{"tags":[],"text":" if used in very localised scope, can use $t? register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" if need to persist across function calls, use $s? register "},{"tags":[],"text":" if used in very localised scope, can use $t? register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" even complex expressions don't generally need > 3-4 registers "}]}],"block":[{"tags":[{"name":"paragraph"}],"text":"C: Assembly Language (MIPS)"},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Instruction Set Architectures "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" CPU Architecture2/114 "},{"tags":[{"name":"paragraph"}],"text":" A typical modern CPU has "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Why Study Assembler?3/114 "},{"tags":[{"name":"paragraph"}],"text":" Useful to know assembly language because ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Instruction Sets4/114 "},{"tags":[{"name":"paragraph"}],"text":" Two broad families of instruction set architectures ... "},{"tags":[{"name":"paragraph"}],"text":" RISC (reduced instruction set computer) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Instruction Sets5/114 "},{"tags":[{"name":"paragraph"}],"text":" Machine-level instructions ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Operands and destination are typically registers "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Instruction Sets6/114 "},{"tags":[{"name":"paragraph"}],"text":" Common kinds of instructions (not from any real machine) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Instruction Sets7/114 "},{"tags":[{"name":"paragraph"}],"text":" Other common kinds of instructions (not from any real machine) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Instruction Sets8/114 "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Fetch-Execute Cycle9/114 "},{"tags":[{"name":"paragraph"}],"text":" All CPUs have program execution logic like: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" PC = Program Counter, a CPU register which keeps track of execution "},{"tags":[{"name":"paragraph"}],"text":" Note that some instructions may modify PC further (e.g. JUMP) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Fetch-Execute Cycle10/114 "},{"tags":[{"name":"paragraph"}],"text":" Executing an instruction involves "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Assembly Language11/114 "},{"tags":[{"name":"paragraph"}],"text":" Instructions are simply bit patterns within a 32-bit bit-string "},{"tags":[{"name":"paragraph"}],"text":" Could describe machine programs as a sequence of hex digits, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Often call \"assembly language\" as \"assembler\" "},{"tags":[{"name":"paragraph"}],"text":" Slight notational abuse, because \"assembler\" also refers to a program that translates assembly language to machine code "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Assembly Language12/114 "},{"tags":[{"name":"paragraph"}],"text":" Assembler = symbolic language for writing machine code "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS Architecture13/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS is a well-known and relatively simple architecture "},{"tags":[{"name":"paragraph"}],"text":" Source code for browsing under /home/cs1521/spim/spim "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS vs SPIM14/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS is a machine architecture, including instruction set "},{"tags":[{"name":"paragraph"}],"text":" SPIM is an emulator for the MIPS instruction set "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Using SPIM15/114 "},{"tags":[{"name":"paragraph"}],"text":" Three ways to execute MIPS code with SPIM "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Using SPIM16/114 "},{"tags":[{"name":"paragraph"}],"text":" Command-line tool: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Using SPIM17/114 "},{"tags":[{"name":"paragraph"}],"text":" GUI tool: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS Machine Archtecture18/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS CPU has "},{"tags":[{"name":"paragraph"}],"text":" Some registers have special uses e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Machine Archtecture19/114 "},{"tags":[{"name":"paragraph"}],"text":" Registers and their usage "},{"tags":[{"name":"paragraph"}],"text":" Reg Name Notes $0 zero the value 0, not changeable $1 $at assembler temporary; used to implement pseudo-ops $2 $v0 value from expression evaluation or function return $3 $v1 value from expression evaluation or function return $4 $a0 first argument to a function/subroutine, if needed $5 $a1 second argument to a function/subroutine, if needed $6 $a2 third argument to a function/subroutine, if needed $7 $a3 fourth argument to a function/subroutine, if needed $8..$15 $t0..$t7 temporary; must be saved by caller to subroutine;subroutine can overwrite "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Machine Archtecture20/114 "},{"tags":[{"name":"paragraph"}],"text":" More register usage ... "},{"tags":[{"name":"paragraph"}],"text":" Reg Name Notes $16..$23 $s0..$s7 safe function variable;must not be overwritten by called subroutine $24..$25 $t8..$t9 temporary; must be saved by caller to subroutine;subroutine can overwrite $26..$27 $k0..$k1 for kernel use; may change unexpectedly $28 $gp global pointer $29 $sp stack pointer $30 $fp frame pointer $31 $ra return address of most recent caller "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Machine Archtecture21/114 "},{"tags":[{"name":"paragraph"}],"text":" Floating point register usage ... "},{"tags":[{"name":"paragraph"}],"text":" Reg Notes $f0..$f2 hold floating-point function results $f4..$f10 temporary registers; not preserved across function calls $f12..$f14 used for first two double-precision function arguments $f16..$f18 temporary registers; used for expression evaluation $f20..$f30 saved registers; value is preserved across function calls "},{"tags":[{"name":"paragraph"}],"text":" Notes: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS Assembly Language22/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS assembly language programs contain "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Assembly Language23/114 "},{"tags":[{"name":"paragraph"}],"text":" Example MIPS assembler program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Color coding: label, directive, comment "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Assembly Language24/114 "},{"tags":[{"name":"paragraph"}],"text":" Generic structure of MIPS programs "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Assembly Language25/114 "},{"tags":[{"name":"paragraph"}],"text":" Another example MIPS assembler program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Assembly Language26/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS programs assume the following memory layout "},{"tags":[{"name":"paragraph"}],"text":" Region Address Notes text 0x00400000 contains only instructions; read-only; cannot expand data 0x10000000 data objects; readable/writeable; can be expanded stack 0x7fffefff grows down from that address; readable/writeable k_text 0x80000000 kernel code; read-only; only accessible kernel mode k_data 0x90000000 kernel data; read/write; only accessible kernel mode "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS Instructions27/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS has several classes of instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instructions28/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS instructions are 32-bits long, and specify ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Addressing Modes29/114 "},{"tags":[{"name":"paragraph"}],"text":" Memory addresses can be given by "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" If $s0 contains 0x10000000 and &var = 0x100000008 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Addressing Modes30/114 "},{"tags":[{"name":"paragraph"}],"text":" Addressing modes in MIPS "},{"tags":[{"name":"paragraph"}],"text":" Format Address computation (register) address = *register = contents of register k address = k k(register) address = k + *register symbol address = &symbol = address of symbol symbol ± k address = &symbol ± k symbol ± k(register) address = &symbol ± (k + *register) "},{"tags":[{"name":"paragraph"}],"text":" where k is a literal constant value (e.g. 4 or 0x10000000) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Addressing Modes31/114 "},{"tags":[{"name":"paragraph"}],"text":" Examples of load/store and addressing: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Operand Sizes32/114 "},{"tags":[{"name":"paragraph"}],"text":" MIPS instructions can manipulate different-sized operands "},{"tags":[{"name":"paragraph"}],"text":" Leads to many opcodes for a (conceptually) single operation, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS Instruction Set33/114 "},{"tags":[{"name":"paragraph"}],"text":" The MIPS processor implements a base set of instructions, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Note: use of $at register for intermediate results "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set34/114 "},{"tags":[{"name":"paragraph"}],"text":" In describing instructions: "},{"tags":[{"name":"paragraph"}],"text":" SyntaxSemantics $Reg as source, the content of the register, reg[Reg] $Reg as destination, value is stored in register, reg[Reg] = value Label references the associated address (in C terms, &Label) Addr any expression that yields an address (e.g. Label($Reg)) Addr as source, the content of memory cell memory[Addr] Addr as destination, value is stored in memory[Addr] = value "},{"tags":[{"name":"paragraph"}],"text":" Effectively ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set35/114 "},{"tags":[{"name":"paragraph"}],"text":" Examples of data movement instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Examples of bit manipulation instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set36/114 "},{"tags":[{"name":"paragraph"}],"text":" Examples of arithmetic instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set37/114 "},{"tags":[{"name":"paragraph"}],"text":" Examples of testing and branching instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" After each branch instruction, execution continues at new PC location "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set38/114 "},{"tags":[{"name":"paragraph"}],"text":" Special jump instruction for invoking functions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set39/114 "},{"tags":[{"name":"paragraph"}],"text":" SPIM interacts with stdin/stdout via syscalls "},{"tags":[{"name":"paragraph"}],"text":" ServiceCodeArgumentsResult print_int1$a0 = integer print_float2$f12 = float print_double3$f12 = double print_string4$a0 = char * read_int5 integer in $v0 read_float6 float in $f0 read_double7 double in $f0 read_string8$a0 = buffer, $a1 = lengthstring in buffer (including \"\\n\\0\") "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Instruction Set40/114 "},{"tags":[{"name":"paragraph"}],"text":" Directives (instructions to assembler, not MIPS instructions) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" MIPS Programming41/114 "},{"tags":[{"name":"paragraph"}],"text":" Writing directly in MIPS assembler is difficult (impossible?) "},{"tags":[{"name":"paragraph"}],"text":" Strategy for producing likely correct MIPS code "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Programming42/114 "},{"tags":[{"name":"paragraph"}],"text":" Example translating C to MIPS: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Programming43/114 "},{"tags":[{"name":"paragraph"}],"text":" Simplified C makes extensive use of "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Programming44/114 "},{"tags":[{"name":"paragraph"}],"text":" Beware: registers are shared by all parts of the code. "},{"tags":[{"name":"paragraph"}],"text":" One function can overwrite value set by another function "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" After the function, x == 6 and y == 120 "},{"tags":[{"name":"paragraph"}],"text":" It is sheer coincidence that y has the correct value. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... MIPS Programming45/114 "},{"tags":[{"name":"paragraph"}],"text":" Need to be careful managing registers "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Rendering C in MIPS46/114 "},{"tags":[{"name":"paragraph"}],"text":" C provides expression evaluation and assignment, e.g. "},{"tags":[{"name":"paragraph"}],"text":" Sequence is easy S1 ; S2 → mips(S1) mips(S2) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Rendering C in MIPS47/114 "},{"tags":[{"name":"paragraph"}],"text":" Simple example of assignment and sequence: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Arithmetic Expressions48/114 "},{"tags":[{"name":"paragraph"}],"text":" Expression evaluation involves "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" It is useful to minimise the number of registers involved in the evaluation "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Conditional Statements49/114 "},{"tags":[{"name":"paragraph"}],"text":" Conditional statements (e.g. if) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Conditional Statements50/114 "},{"tags":[{"name":"paragraph"}],"text":" Conditional statements (e.g. if) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Conditional Statements51/114 "},{"tags":[{"name":"paragraph"}],"text":" Example of if-then-else: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Conditional Statements52/114 "},{"tags":[{"name":"paragraph"}],"text":" Could make switch by first converting to if "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Conditional Statements53/114 "},{"tags":[{"name":"paragraph"}],"text":" Jump table: an alternative implementation of switch "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Boolean Expressions54/114 "},{"tags":[{"name":"paragraph"}],"text":" Boolean expressions in C are short circuit "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Evaluates by "},{"tags":[{"name":"paragraph"}],"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Boolean Expressions55/114 "},{"tags":[{"name":"paragraph"}],"text":" Similarly for disjunctions "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Evaluates by "},{"tags":[{"name":"paragraph"}],"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Iteration Statements56/114 "},{"tags":[{"name":"paragraph"}],"text":" Iteration (e.g. while) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Treat for as a special case of while "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Iteration Statements57/114 "},{"tags":[{"name":"paragraph"}],"text":" Example of iteration over an array: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Functions58/114 "},{"tags":[{"name":"paragraph"}],"text":" When we call a function: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Functions59/114 "},{"tags":[{"name":"paragraph"}],"text":" Data associated with function calls is placed on the MIPS stack. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Functions60/114 "},{"tags":[{"name":"paragraph"}],"text":" Each function allocates a small section of the stack (a frame) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Functions61/114 "},{"tags":[{"name":"paragraph"}],"text":" How stack changes as functions are called and return: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Functions62/114 "},{"tags":[{"name":"paragraph"}],"text":" Register usage conventions when f() calls g(): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Functions63/114 "},{"tags":[{"name":"paragraph"}],"text":" Contents of a typical stack frame: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Aside: MIPS Branch Delay Slots64/114 "},{"tags":[{"name":"paragraph"}],"text":" The real MIPS architecture is \"pipelined\" to improve efficiency "},{"tags":[{"name":"paragraph"}],"text":" A problem scenario, and its solution (branch delay slot): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Since SPIM is not pipelined, the nop is not required "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Aside: Why do we need both $fp and $sp?65/114 "},{"tags":[{"name":"paragraph"}],"text":" During execution of a function "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Function Calling Protocol66/114 "},{"tags":[{"name":"paragraph"}],"text":" Before one function calls another, it needs to "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Calling Protocol67/114 "},{"tags":[{"name":"paragraph"}],"text":" Example: simple function call "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Calling Protocol68/114 "},{"tags":[{"name":"paragraph"}],"text":" Simple function call: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Calling Protocol69/114 "},{"tags":[{"name":"paragraph"}],"text":" Execution of sum() function: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Calling Protocol70/114 "},{"tags":[{"name":"paragraph"}],"text":" Example: function f() calls function g(a,b,c,d,e,f) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Calling Protocol71/114 "},{"tags":[{"name":"paragraph"}],"text":" Function call in MIPS: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Calling Protocol72/114 "},{"tags":[{"name":"paragraph"}],"text":" Execution of g() function: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Structure of Functions73/114 "},{"tags":[{"name":"paragraph"}],"text":" Functions in MIPS have the following general structure: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Aim of prologue: create environment for function to execute in. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Function Prologue74/114 "},{"tags":[{"name":"paragraph"}],"text":" Before a function starts working, it needs to ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Prologue75/114 "},{"tags":[{"name":"paragraph"}],"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Prologue76/114 "},{"tags":[{"name":"paragraph"}],"text":" Alternatively ... (more explicit push) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Prologue77/114 "},{"tags":[{"name":"paragraph"}],"text":" Alternatively ... (relative to new $fp) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Function Epilogue78/114 "},{"tags":[{"name":"paragraph"}],"text":" Before a function returns, it needs to ... "},{"tags":[{"name":"paragraph"}],"text":" Changing $fp and $sp ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Function Epilogue79/114 "},{"tags":[{"name":"paragraph"}],"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Data Structures and MIPS80/114 "},{"tags":[{"name":"paragraph"}],"text":" C data structures and their MIPS representations: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Static vs Dynamic Allocation81/114 "},{"tags":[{"name":"paragraph"}],"text":" Static allocation: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Static vs Dynamic Allocation82/114 "},{"tags":[{"name":"paragraph"}],"text":" Dynamic allocation (i): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Static vs Dynamic Allocation83/114 "},{"tags":[{"name":"paragraph"}],"text":" Example of local variables on the stack: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Static vs Dynamic Allocation84/114 "},{"tags":[{"name":"paragraph"}],"text":" Dynamic allocation (ii): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Static vs Dynamic Allocation85/114 "},{"tags":[{"name":"paragraph"}],"text":" SPIM doesn't provide malloc()/free() functions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Cannot access allocated data by name; need to retain address. "},{"tags":[{"name":"paragraph"}],"text":" No way to free allocated data, and no way to align data appropriately "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Static vs Dynamic Allocation86/114 "},{"tags":[{"name":"paragraph"}],"text":" Implementing C-like malloc() and free() in MIPS requires "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" 1-d Arrays in MIPS87/114 "},{"tags":[{"name":"paragraph"}],"text":" Can be named/initialised as noted above: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Can access elements via index or cursor (pointer) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 1-d Arrays in MIPS88/114 "},{"tags":[{"name":"paragraph"}],"text":" Scanning across an array of N elements using index "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 1-d Arrays in MIPS89/114 "},{"tags":[{"name":"paragraph"}],"text":" Scanning across an array of N elements using cursor "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 1-d Arrays in MIPS90/114 "},{"tags":[{"name":"paragraph"}],"text":" Arrays that are local to functions are allocated space on the stack "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" 2-d Arrays in MIPS91/114 "},{"tags":[{"name":"paragraph"}],"text":" 2-d arrays could be represented two ways: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 2-d Arrays in MIPS92/114 "},{"tags":[{"name":"paragraph"}],"text":" Representations of int matrix[4][4] ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Now consider summing all elements "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 2-d Arrays in MIPS93/114 "},{"tags":[{"name":"paragraph"}],"text":" Accessing elements: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 2-d Arrays in MIPS94/114 "},{"tags":[{"name":"paragraph"}],"text":" Computing sum of all elements for strategy (a) int matrix[4][4] "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... 2-d Arrays in MIPS95/114 "},{"tags":[{"name":"paragraph"}],"text":" Computing sum of all elements for strategy (b) int matrix[4][4] "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Structs in MIPS96/114 "},{"tags":[{"name":"paragraph"}],"text":" C structs hold a collection of values accessed by name "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs in MIPS97/114 "},{"tags":[{"name":"paragraph"}],"text":" C struct definitions effectively define a new type. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Instances of structures can be created by allocating space: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs in MIPS98/114 "},{"tags":[{"name":"paragraph"}],"text":" Accessing structure components is by offset, not name "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs in MIPS99/114 "},{"tags":[{"name":"paragraph"}],"text":" Structs that are local to functions are allocated space on the stack "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs in MIPS100/114 "},{"tags":[{"name":"paragraph"}],"text":" C can pass whole structures to functions, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs in MIPS101/114 "},{"tags":[{"name":"paragraph"}],"text":" Accessing struct within function ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Structs in MIPS102/114 "},{"tags":[{"name":"paragraph"}],"text":" Can also pass a pointer to a struct "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Clearly a more efficient way to pass a large struct "},{"tags":[{"name":"paragraph"}],"text":" Also, required if the function needs to update the original struct "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Compiling C to MIPS103/114 "},{"tags":[{"name":"paragraph"}],"text":" Using simplified C as an intermediate language "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" C Pre-processor104/114 "},{"tags":[{"name":"paragraph"}],"text":" Maps C→C, performing various substitutions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... C Pre-processor105/114 "},{"tags":[{"name":"paragraph"}],"text":" More C pre-processor substitions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" C Parser106/114 "},{"tags":[{"name":"paragraph"}],"text":" Understands syntax of C language "},{"tags":[{"name":"paragraph"}],"text":" Attempts to convert C program into parse tree "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Symbol Table Management107/114 "},{"tags":[{"name":"paragraph"}],"text":" Compiler keeps track of names "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Local Variables108/114 "},{"tags":[{"name":"paragraph"}],"text":" Two choices for local variables "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Expression Evaluation109/114 "},{"tags":[{"name":"paragraph"}],"text":" Uses temporary ($t?) registers "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Complex boolean expressions handled by short-circuit evaluation. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Mapping Control Structures110/114 "},{"tags":[{"name":"paragraph"}],"text":" Use templates, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Mapping Control Structures111/114 "},{"tags":[{"name":"paragraph"}],"text":" Template for if...else if... else "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Argc and Argv112/114 "},{"tags":[{"name":"paragraph"}],"text":" The real MIPS machine has no idea about argc and argv "},{"tags":[{"name":"paragraph"}],"text":" SPIM runs under Linux, and needs to interact with environment "},{"tags":[{"name":"paragraph"}],"text":" So, the initialisation code (that invokes main) sets them up: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":" Note: we are ignoring envp (environment pointer) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Argc and Argv113/114 "},{"tags":[{"name":"paragraph"}],"text":" What the main program receives: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Argc and Argv114/114 "},{"tags":[{"name":"paragraph"}],"text":" Code to print the program's name (argv[0]): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Code to print the first cmd-line arg (argv[1]) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Produced: 2 Apr 2018 "}]}