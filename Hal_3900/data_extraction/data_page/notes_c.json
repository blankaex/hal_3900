{"grouped":[{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"instruction set architectures","salience":1}],"text":"Instruction Set Architectures "}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"cpu architecture 2","salience":1}],"text":"CPU Architecture 2/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"study assembler","salience":1}],"text":"Why Study Assembler? 3/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"instruction","salience":1}],"text":"Instruction Sets 4/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"instruction","salience":1}],"text":"... Instruction Sets 5/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"instruction","salience":1}],"text":"... Instruction Sets 6/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"instruction","salience":1}],"text":"... Instruction Sets 7/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"instruction","salience":1}],"text":"... Instruction Sets 8/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"fetch-execute cycle 9","salience":1}],"text":"Fetch-Execute Cycle 9/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"fetch-execute cycle 10","salience":1}],"text":"... Fetch-Execute Cycle 10/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"assembly language","salience":1}],"text":"Assembly Language 11/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"assembly language","salience":1}],"text":"... Assembly Language 12/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips architecture","salience":1}],"text":"MIPS Architecture 13/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips","salience":0.7497316002845764},{"name":"spim 14","salience":0.2502683997154236}],"text":"MIPS vs SPIM 14/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Using SPIM 15/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Using SPIM 16/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Using SPIM 17/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips machine archtecture","salience":1}],"text":"MIPS Machine Archtecture 18/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips machine archtecture","salience":1}],"text":"... MIPS Machine Archtecture 19/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"reg","salience":0.8399657011032104},{"name":"notes","salience":0.16003429889678955}],"text":"Reg ,Name, ,Notes"},{"tags":[{"name":"value","salience":1}],"text":"$0 ,zero, ,the value 0, not changeable"},{"tags":[{"name":"pseudo-ops","salience":1}],"text":"$1 ,$at, ,assembler temporary; used to implement pseudo-ops"},{"tags":[{"name":"value","salience":0.5403892397880554},{"name":"function return","salience":0.2798740267753601},{"name":"expression evaluation","salience":0.17973674833774567}],"text":"$2 ,$v0, ,value from expression evaluation or function return"},{"tags":[{"name":"value","salience":0.5403892397880554},{"name":"function return","salience":0.2798740267753601},{"name":"expression evaluation","salience":0.17973674833774567}],"text":"$3 ,$v1, ,value from expression evaluation or function return"},{"tags":[{"name":"argument","salience":0.44250625371932983},{"name":"function","salience":0.4103134572505951},{"name":"subroutine","salience":0.14718028903007507}],"text":"$4 ,$a0, ,first argument to a function/subroutine, if needed"},{"tags":[{"name":"argument","salience":0.44250625371932983},{"name":"function","salience":0.4103134572505951},{"name":"subroutine","salience":0.14718028903007507}],"text":"$5 ,$a1, ,second argument to a function/subroutine, if needed"},{"tags":[{"name":"argument","salience":0.44250625371932983},{"name":"function","salience":0.4103134572505951},{"name":"subroutine","salience":0.14718028903007507}],"text":"$6 ,$a2, ,third argument to a function/subroutine, if needed"},{"tags":[{"name":"argument","salience":0.44250625371932983},{"name":"function","salience":0.4103134572505951},{"name":"subroutine","salience":0.14718028903007507}],"text":"$7 ,$a3, ,fourth argument to a function/subroutine, if needed"},{"tags":[{"name":"subroutine","salience":0.4147495925426483},{"name":"subroutine","salience":0.4147495925426483},{"name":"caller","salience":0.17050080001354218}],"text":"$8..$15 ,$t0..$t7, ,temporary; must be saved by caller to subroutine;subroutine can overwrite"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips machine archtecture","salience":1}],"text":"... MIPS Machine Archtecture 20/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"reg","salience":0.8399657011032104},{"name":"notes","salience":0.16003429889678955}],"text":"Reg ,Name, ,Notes"},{"tags":[{"name":"function variable","salience":0.6031419038772583},{"name":"subroutine","salience":0.3968581259250641}],"text":"$16..$23 ,$s0..$s7, ,safe function variable;must not be overwritten by called subroutine"},{"tags":[{"name":"subroutine","salience":0.4147495925426483},{"name":"subroutine","salience":0.4147495925426483},{"name":"caller","salience":0.17050080001354218}],"text":"$24..$25 ,$t8..$t9, ,temporary; must be saved by caller to subroutine;subroutine can overwrite"},{"tags":[{"name":"kernel use","salience":1}],"text":"$26..$27 ,$k0..$k1, ,for kernel use; may change unexpectedly"},{"tags":[{"name":"pointer","salience":1}],"text":"$28 ,$gp, ,global pointer"},{"tags":[{"name":"stack pointer","salience":0.5373925566673279},{"name":"sp","salience":0.4626074433326721}],"text":"$29 ,$sp, ,stack pointer"},{"tags":[{"name":"frame pointer","salience":1}],"text":"$30 ,$fp, ,frame pointer"},{"tags":[{"name":"address","salience":0.6372127532958984},{"name":"caller","salience":0.36278724670410156}],"text":"$31 ,$ra, ,return address of most recent caller"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips machine archtecture","salience":1}],"text":"... MIPS Machine Archtecture 21/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"reg","salience":0.8456545472145081},{"name":"notes","salience":0.15434543788433075}],"text":"Reg ,Notes"},{"tags":[],"text":""},{"tags":[{"name":"function results","salience":1}],"text":"$f0..$f2 ,hold floating-point function results"},{"tags":[{"name":"registers","salience":0.6537261009216309},{"name":"function calls","salience":0.34627392888069153}],"text":"$f4..$f10 ,temporary registers; not preserved across function calls"},{"tags":[{"name":"double-precision function arguments","salience":1}],"text":"$f12..$f14 ,used for first two double-precision function arguments"},{"tags":[{"name":"registers","salience":0.6372127532958984},{"name":"expression evaluation","salience":0.36278724670410156}],"text":"$f16..$f18 ,temporary registers; used for expression evaluation"},{"tags":[{"name":"registers","salience":0.42235732078552246},{"name":"value","salience":0.35889875888824463},{"name":"function calls","salience":0.21874389052391052}],"text":"$f20..$f30 ,saved registers; value is preserved across function calls"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips assembly language","salience":1}],"text":"MIPS Assembly Language 22/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips assembly language","salience":1}],"text":"... MIPS Assembly Language 23/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips assembly language","salience":1}],"text":"... MIPS Assembly Language 24/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips assembly language","salience":1}],"text":"... MIPS Assembly Language 25/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips assembly language","salience":1}],"text":"... MIPS Assembly Language 26/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"region","salience":0.6233991980552673},{"name":"address","salience":0.21800990402698517},{"name":"notes","salience":0.1585909128189087}],"text":"Region ,Address, ,Notes"},{"tags":[{"name":"text","salience":0.7602997422218323},{"name":"instructions","salience":0.2397002875804901}],"text":"text ,0x00400000, ,contains only instructions; read-only; cannot expand"},{"tags":[{"name":"data","salience":0.6970641016960144},{"name":"data objects","salience":0.2273259311914444},{"name":"writeable","salience":0.07560998946428299}],"text":"data ,0x10000000, ,data objects; readable/writeable; can be expanded"},{"tags":[{"name":"stack","salience":0.6132466793060303},{"name":"0x7fffefff","salience":0.3117404878139496},{"name":"address","salience":0.07501284778118134}],"text":"stack ,0x7fffefff, ,grows down from that address; readable/writeable"},{"tags":[{"name":"kernel code","salience":0.6514027118682861},{"name":"kernel mode","salience":0.34859731793403625}],"text":"k_text ,0x80000000, ,kernel code; read-only; only accessible kernel mode"},{"tags":[{"name":"k_data","salience":0.4638114869594574},{"name":"kernel data","salience":0.35194411873817444},{"name":"kernel mode","salience":0.18424436450004578}],"text":"k_data ,0x90000000, ,kernel data; read/write; only accessible kernel mode"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instructions","salience":1}],"text":"MIPS Instructions 27/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instructions","salience":1}],"text":"... MIPS Instructions 28/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"addressing modes 29","salience":1}],"text":"Addressing Modes 29/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"addressing modes 30","salience":1}],"text":"... Addressing Modes 30/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"format","salience":0.8837491273880005},{"name":"address computation","salience":0.11625086516141891}],"text":"Format ,Address computation"},{"tags":[{"name":"address","salience":0.5052622556686401},{"name":"register","salience":0.32486966252326965},{"name":"contents","salience":0.16986805200576782}],"text":"(register) ,address = *register = contents of register"},{"tags":[{"name":"address","salience":1}],"text":"k ,address = k"},{"tags":[{"name":"register","salience":0.492259681224823},{"name":"address","salience":0.32047709822654724},{"name":"register","salience":0.18726322054862976}],"text":"k(register) ,address = k + *register"},{"tags":[{"name":"symbol","salience":0.5653970837593079},{"name":"address","salience":0.2704382836818695},{"name":"symbol","salience":0.10006995499134064},{"name":"address","salience":0.06409469991922379}],"text":"symbol ,address = &symbol = address of symbol"},{"tags":[{"name":"symbol","salience":0.7229015231132507},{"name":"address","salience":0.27709847688674927}],"text":"symbol ± k ,address = &symbol ± k"},{"tags":[{"name":"symbol","salience":0.4877510368824005},{"name":"register","salience":0.25473251938819885},{"name":"address","salience":0.16325809061527252},{"name":"register","salience":0.0942583680152893}],"text":"symbol ± k(register) ,address = &symbol ± (k + *register)"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"addressing modes 31","salience":1}],"text":"... Addressing Modes 31/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"operand sizes","salience":1}],"text":"Operand Sizes 32/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"MIPS Instruction Set 33/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 34/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"syntax semantics","salience":1}],"text":"Syntax Semantics"},{"tags":[{"name":"reg","salience":0.3900255560874939},{"name":"source","salience":0.23129552602767944},{"name":"content","salience":0.16328434646129608},{"name":"register","salience":0.15071137249469757},{"name":"reg","salience":0.06468319892883301}],"text":"$Reg as source, the content of the register, reg[Reg]"},{"tags":[{"name":"reg","salience":0.34052202105522156},{"name":"destination","salience":0.18962594866752625},{"name":"value","salience":0.14873290061950684},{"name":"register","salience":0.12293611466884613},{"name":"value","salience":0.07555955648422241},{"name":"reg","salience":0.07014372944831848},{"name":"reg","salience":0.05247974023222923}],"text":"$Reg as destination, value is stored in register, reg[Reg] = value"},{"tags":[{"name":"label","salience":0.6305989623069763},{"name":"address","salience":0.20875190198421478},{"name":"&label","salience":0.09178002923727036},{"name":"c terms","salience":0.06886912882328033}],"text":"Label references the associated address (in C terms, &Label)"},{"tags":[{"name":"expression","salience":0.6023736000061035},{"name":"address","salience":0.20652760565280914},{"name":"label","salience":0.19109882414340973}],"text":"Addr any expression that yields an address (e.g. Label($Reg))"},{"tags":[{"name":"addr","salience":0.7573260068893433},{"name":"source","salience":0.1926935911178589},{"name":"memory cell memory","salience":0.04998038336634636}],"text":"Addr as source, the content of memory cell memory[Addr]"},{"tags":[{"name":"addr","salience":0.6916861534118652},{"name":"destination","salience":0.15013831853866577},{"name":"memory","salience":0.09782961010932922},{"name":"value","salience":0.06034590303897858}],"text":"Addr as destination, value is stored in memory[Addr] = value"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 35/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 36/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 37/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 38/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 39/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"service code","salience":0.44561079144477844},{"name":"arguments","salience":0.3223798871040344},{"name":"result","salience":0.23200932145118713}],"text":"Service Code,Arguments,Result"},{"tags":[{"name":"integer","salience":1}],"text":"print_int 1,$a0 = integer, "},{"tags":[{"name":"float","salience":1}],"text":"print_float 2,$f12 = float, "},{"tags":[],"text":"print_double 3,$f12 = double, "},{"tags":[{"name":"char","salience":1}],"text":"print_string 4,$a0 = char *, "},{"tags":[{"name":"integer","salience":1}],"text":"read_int 5, ,integer in $v0"},{"tags":[],"text":"read_float 6, ,float in $f0"},{"tags":[],"text":"read_double 7, ,double in $f0"},{"tags":[{"name":"buffer","salience":0.3238232433795929},{"name":"buffer","salience":0.21362915635108948},{"name":"length","salience":0.20529428124427795},{"name":"string","salience":0.1896841824054718},{"name":"\\n\\0","salience":0.06756916642189026}],"text":"read_string 8,$a0 = buffer, $a1 = length,string in buffer (including \"\\n\\0\")"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips instruction set","salience":1}],"text":"... MIPS Instruction Set 40/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips programming","salience":1}],"text":"MIPS Programming 41/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips programming","salience":1}],"text":"... MIPS Programming 42/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips programming","salience":1}],"text":"... MIPS Programming 43/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips programming","salience":1}],"text":"... MIPS Programming 44/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips programming","salience":1}],"text":"... MIPS Programming 45/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"rendering c","salience":1}],"text":"Rendering C in MIPS 46/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"rendering c","salience":1}],"text":"... Rendering C in MIPS 47/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arithmetic expressions 48","salience":1}],"text":"Arithmetic Expressions 48/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"statements","salience":1}],"text":"Conditional Statements 49/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"statements","salience":1}],"text":"... Conditional Statements 50/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"statements","salience":1}],"text":"... Conditional Statements 51/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"statements","salience":1}],"text":"... Conditional Statements 52/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"statements","salience":1}],"text":"... Conditional Statements 53/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"boolean expressions","salience":1}],"text":"Boolean Expressions 54/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"boolean expressions","salience":1}],"text":"... Boolean Expressions 55/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"iteration","salience":1}],"text":"Iteration Statements 56/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"statements 57","salience":1}],"text":"... Iteration Statements 57/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"Functions 58/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 59/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 60/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 61/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 62/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[],"text":"... Functions 63/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mips branch delay slots","salience":1}],"text":"Aside: MIPS Branch Delay Slots 64/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"aside","salience":0.8947967290878296},{"name":"sp","salience":0.10520326346158981}],"text":"Aside: Why do we need both $fp and $sp? 65/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"Function Calling Protocol 66/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"... Function Calling Protocol 67/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"... Function Calling Protocol 68/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"... Function Calling Protocol 69/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"... Function Calling Protocol 70/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"... Function Calling Protocol 71/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function calling protocol","salience":1}],"text":"... Function Calling Protocol 72/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structure","salience":1}],"text":"Structure of Functions 73/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function prologue","salience":1}],"text":"Function Prologue 74/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function prologue","salience":1}],"text":"... Function Prologue 75/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function prologue","salience":1}],"text":"... Function Prologue 76/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function prologue","salience":1}],"text":"... Function Prologue 77/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function","salience":1}],"text":"Function Epilogue 78/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"function","salience":1}],"text":"... Function Epilogue 79/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"data structures","salience":1}],"text":"Data Structures and MIPS 80/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"dynamic allocation 81","salience":1}],"text":"Static vs Dynamic Allocation 81/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"dynamic allocation","salience":1}],"text":"... Static vs Dynamic Allocation 82/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"dynamic allocation 83","salience":1}],"text":"... Static vs Dynamic Allocation 83/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"dynamic allocation","salience":1}],"text":"... Static vs Dynamic Allocation 84/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"dynamic allocation","salience":1}],"text":"... Static vs Dynamic Allocation 85/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"dynamic allocation","salience":1}],"text":"... Static vs Dynamic Allocation 86/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"1-d Arrays in MIPS 87/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 1-d Arrays in MIPS 88/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 1-d Arrays in MIPS 89/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 1-d Arrays in MIPS 90/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"2-d Arrays in MIPS 91/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 2-d Arrays in MIPS 92/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 2-d Arrays in MIPS 93/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 2-d Arrays in MIPS 94/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"arrays","salience":1}],"text":"... 2-d Arrays in MIPS 95/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":1}],"text":"Structs in MIPS 96/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":1}],"text":"... Structs in MIPS 97/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":1}],"text":"... Structs in MIPS 98/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":1}],"text":"... Structs in MIPS 99/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":0.5882814526557922},{"name":"mips 100","salience":0.41171854734420776}],"text":"... Structs in MIPS 100/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":0.5882814526557922},{"name":"mips 101","salience":0.41171854734420776}],"text":"... Structs in MIPS 101/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"structs","salience":0.5882814526557922},{"name":"mips 102","salience":0.41171854734420776}],"text":"... Structs in MIPS 102/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"c","salience":1}],"text":"Compiling C to MIPS 103/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"c pre-processor 104","salience":1}],"text":"C Pre-processor 104/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"c pre-processor 105","salience":1}],"text":"... C Pre-processor 105/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"c parser 106","salience":1}],"text":"C Parser 106/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"symbol table management","salience":1}],"text":"Symbol Table Management 107/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"variables","salience":1}],"text":"Local Variables 108/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"expression evaluation 109","salience":1}],"text":"Expression Evaluation 109/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mapping control structures 110","salience":1}],"text":"Mapping Control Structures 110/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"mapping control structures 111","salience":1}],"text":"... Mapping Control Structures 111/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"argc","salience":0.7497316002845764},{"name":"argv 112","salience":0.2502683997154236}],"text":" Argc and Argv 112/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"argc","salience":0.5882814526557922},{"name":"argv 113","salience":0.41171854734420776}],"text":"... Argc and Argv 113/114"}]},{"tags":[{"name":"table"}],"items":[{"tags":[{"name":"argc","salience":0.5882814526557922},{"name":"argv 114","salience":0.41171854734420776}],"text":"... Argc and Argv 114/114"}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"set","salience":0.6507119536399841},{"name":"data registers","salience":0.34928804636001587}],"text":" a set of data registers "},{"tags":[{"name":"set","salience":0.6219350099563599},{"name":"control registers","salience":0.21984653174877167},{"name":"pc","salience":0.15821844339370728}],"text":" a set of control registers (incl PC) "},{"tags":[{"name":"arithmetic-logic unit","salience":0.7445061206817627},{"name":"alu","salience":0.2554938793182373}],"text":" an arithmetic-logic unit (ALU) "},{"tags":[{"name":"access","salience":0.572419285774231},{"name":"access","salience":0.19484907388687134},{"name":"memory","salience":0.1754765808582306},{"name":"ram","salience":0.05725507810711861}],"text":" access to random access memory (RAM) "},{"tags":[{"name":"set","salience":0.2883356511592865},{"name":"data","salience":0.11975832283496857},{"name":"instructions","salience":0.11975832283496857},{"name":"registers","salience":0.08333802223205566},{"name":"memory","salience":0.08235999196767807},{"name":"alu","salience":0.07671863585710526},{"name":"values","salience":0.07492197304964066},{"name":"tests","salience":0.046454887837171555},{"name":"control","salience":0.04118237644433975},{"name":"execution","salience":0.04118237644433975},{"name":"results","salience":0.025989435613155365}],"text":" a set of simple instructions transfer data between memory and registers push values through the ALU to compute results make tests and transfer control of execution "},{"tags":[{"name":"data","salience":0.44561079144477844},{"name":"memory","salience":0.3223798871040344},{"name":"registers","salience":0.23200932145118713}],"text":" transfer data between memory and registers "},{"tags":[{"name":"values","salience":0.5957205891609192},{"name":"alu","salience":0.22627656161785126},{"name":"results","salience":0.17800281941890717}],"text":" push values through the ALU to compute results "},{"tags":[{"name":"tests","salience":0.4082038402557373},{"name":"control","salience":0.3331919312477112},{"name":"execution","salience":0.2586042284965515}],"text":" make tests and transfer control of execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"data","salience":0.44561079144477844},{"name":"memory","salience":0.3223798871040344},{"name":"registers","salience":0.23200932145118713}],"text":" transfer data between memory and registers "},{"tags":[{"name":"values","salience":0.5957205891609192},{"name":"alu","salience":0.22627656161785126},{"name":"results","salience":0.17800281941890717}],"text":" push values through the ALU to compute results "},{"tags":[{"name":"tests","salience":0.4082038402557373},{"name":"control","salience":0.3331919312477112},{"name":"execution","salience":0.2586042284965515}],"text":" make tests and transfer control of execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"# registers","salience":0.5531008243560791},{"name":"instructions","salience":0.2587806284427643},{"name":"registers","salience":0.18811854720115662}],"text":" e.g. different # registers, different sized registers, different instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"device handlers","salience":1}],"text":" sometimes you are required to use it (e.g. device handlers) "},{"tags":[{"name":"understanding","salience":0.6648920774459839},{"name":"c programs","salience":0.22010421752929688},{"name":"constructs","salience":0.11500371992588043}],"text":" improves your understanding of how C programs execute very helpful when debugging able to avoid using known inefficient constructs "},{"tags":[],"text":" very helpful when debugging "},{"tags":[{"name":"constructs","salience":1}],"text":" able to avoid using known inefficient constructs "},{"tags":[{"name":"performance tweaking","salience":0.3732396364212036},{"name":"nano-s)","salience":0.29975318908691406},{"name":"function","salience":0.190620556473732},{"name":"assembler","salience":0.13638660311698914}],"text":" uber-nerdy performance tweaking (squeezing out last nano-s) re-write that critical (frequently-used) function in assembler "},{"tags":[{"name":"assembler","salience":0.6068437695503235},{"name":"function","salience":0.3931562006473541}],"text":" re-write that critical (frequently-used) function in assembler "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" very helpful when debugging "},{"tags":[{"name":"constructs","salience":1}],"text":" able to avoid using known inefficient constructs "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"assembler","salience":0.6068437695503235},{"name":"function","salience":0.3931562006473541}],"text":" re-write that critical (frequently-used) function in assembler "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"set","salience":0.6537261009216309},{"name":"instructions","salience":0.34627392888069153}],"text":" small(ish) set of simple, general instructions "},{"tags":[{"name":"computation","salience":0.4531022608280182},{"name":"data","salience":0.31802356243133545},{"name":"instructions","salience":0.22887417674064636}],"text":" separate computation & data transfer instructions "},{"tags":[{"name":"processor hardware","salience":1}],"text":" leading to simpler processor hardware "},{"tags":[{"name":"mips","salience":0.5421134233474731},{"name":"risc","salience":0.1481085866689682},{"name":"sparc","salience":0.10320516675710678},{"name":"alpha","salience":0.10199765861034393},{"name":"arm","salience":0.07232172787189484},{"name":"powerpc","salience":0.03225342184305191}],"text":" e.g. MIPS, RISC, Alpha, SPARC, PowerPC, ARM, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"set","salience":0.5783335566520691},{"name":"instructions","salience":0.4216664433479309}],"text":" large(r) set of powerful instructions "},{"tags":[{"name":"instruction","salience":0.6448712348937988},{"name":"actions","salience":0.20650902390480042},{"name":"store","salience":0.14861975610256195}],"text":" each instruction has multiple actions (comp+store) "},{"tags":[{"name":"circuitry","salience":0.6507119536399841},{"name":"process instructions","salience":0.34928804636001587}],"text":" more circuitry to decode/process instructions "},{"tags":[{"name":"e.g. pdp","salience":0.404992014169693},{"name":"vax","salience":0.16925650835037231},{"name":"motorola","salience":0.1179414838552475},{"name":"z80","salience":0.11656155437231064},{"name":"68xxx","salience":0.10860014706850052},{"name":"intel x86","salience":0.08264829963445663}],"text":" e.g. PDP, VAX, Z80, Motorola 68xxx, Intel x86, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"instruction","salience":0.609609842300415},{"name":"words","salience":0.39039015769958496}],"text":" typically have 1-2 32-bit words per instruction "},{"tags":[{"name":"partition bits","salience":0.6054206490516663},{"name":"word","salience":0.2026439905166626},{"name":"operands","salience":0.11699814349412918},{"name":"operator","salience":0.07493718713521957}],"text":" partition bits in each word into operator & operands "},{"tags":[{"name":"#bits","salience":0.49590665102005005},{"name":"each","salience":0.23201249539852142},{"name":"#instructions","salience":0.15358766913414001},{"name":"#registers","salience":0.11849317699670792}],"text":" #bits for each depends on #instructions, #registers, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register","salience":0.6309286952018738},{"name":"memory","salience":0.13177473843097687},{"name":"memoryaddress","salience":0.12484826892614365},{"name":"register","salience":0.0720585361123085},{"name":"address","salience":0.040389738976955414}],"text":" load Register, MemoryAddress copy value stored in memory at address into named register "},{"tags":[{"name":"copy value","salience":0.5508466958999634},{"name":"memory","salience":0.18437720835208893},{"name":"address","salience":0.1706031858921051},{"name":"register","salience":0.09417293965816498}],"text":" copy value stored in memory at address into named register "},{"tags":[{"name":"loadc register","salience":0.7452298402786255},{"name":"constantvalue","salience":0.13086086511611938},{"name":"register","salience":0.12390928715467453}],"text":" loadc Register, ConstantValue copy value into named register "},{"tags":[{"name":"copy value","salience":0.6507119536399841},{"name":"register","salience":0.34928804636001587}],"text":" copy value into named register "},{"tags":[{"name":"register","salience":0.39049771428108215},{"name":"copy value","salience":0.16557684540748596},{"name":"memoryaddress","salience":0.16520899534225464},{"name":"memory","salience":0.13388492166996002},{"name":"address","salience":0.08417093008756638},{"name":"register","salience":0.06066058576107025}],"text":" store Register, MemoryAddress copy value stored in named register into memory at address "},{"tags":[{"name":"copy value","salience":0.6192377805709839},{"name":"register","salience":0.20726878941059113},{"name":"address","salience":0.10586510598659515},{"name":"memory","salience":0.06762834638357162}],"text":" copy value stored in named register into memory at address "},{"tags":[{"name":"memoryaddress","salience":0.4225150942802429},{"name":"program","salience":0.2050086110830307},{"name":"transfer execution","salience":0.20271259546279907},{"name":"address","salience":0.10373133420944214},{"name":"instruction","salience":0.06603237986564636}],"text":" jump MemoryAddress transfer execution of program to instruction at address "},{"tags":[{"name":"execution","salience":0.5320023894309998},{"name":"program","salience":0.17611274123191833},{"name":"instruction","salience":0.16476689279079437},{"name":"address","salience":0.12711797654628754}],"text":" transfer execution of program to instruction at address "},{"tags":[{"name":"jumpif register","salience":0.635901153087616},{"name":"program","salience":0.12756037712097168},{"name":"memoryaddress","salience":0.1114942878484726},{"name":"value","salience":0.08915458619594574},{"name":"e.g. register","salience":0.03588961437344551}],"text":" jumpif Register, MemoryAddress transfer execution of program if e.g. register holds zero value "},{"tags":[{"name":"execution","salience":0.5519616007804871},{"name":"program","salience":0.18271999061107635},{"name":"e.g. register","salience":0.13492809236049652},{"name":"value","salience":0.13039034605026245}],"text":" transfer execution of program if e.g. register holds zero value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"copy value","salience":0.5508466958999634},{"name":"memory","salience":0.18437720835208893},{"name":"address","salience":0.1706031858921051},{"name":"register","salience":0.09417293965816498}],"text":" copy value stored in memory at address into named register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"copy value","salience":0.6507119536399841},{"name":"register","salience":0.34928804636001587}],"text":" copy value into named register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"copy value","salience":0.6192377805709839},{"name":"register","salience":0.20726878941059113},{"name":"address","salience":0.10586510598659515},{"name":"memory","salience":0.06762834638357162}],"text":" copy value stored in named register into memory at address "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"execution","salience":0.5320023894309998},{"name":"program","salience":0.17611274123191833},{"name":"instruction","salience":0.16476689279079437},{"name":"address","salience":0.12711797654628754}],"text":" transfer execution of program to instruction at address "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"execution","salience":0.5519616007804871},{"name":"program","salience":0.18271999061107635},{"name":"e.g. register","salience":0.13492809236049652},{"name":"value","salience":0.13039034605026245}],"text":" transfer execution of program if e.g. register holds zero value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register1","salience":0.37821656465530396},{"name":"register2","salience":0.16484354436397552},{"name":"register3","salience":0.16484354436397552},{"name":"sub","salience":0.13027644157409668},{"name":"mul","salience":0.1202450841665268},{"name":"div","salience":0.04157482087612152}],"text":" add Register1, Register2, Register3 (similarly for sub, mul, div) Register3 = Register1 + Register2 "},{"tags":[{"name":"register3","salience":1}],"text":" Register3 = Register1 + Register2 "},{"tags":[{"name":"register1","salience":0.47174689173698425},{"name":"register2","salience":0.21636302769184113},{"name":"xor","salience":0.15957055985927582},{"name":"register3","salience":0.1523195207118988}],"text":" and Register1, Register2, Register3 (similarly for or, xor) Register3 = Register1 & Register2 "},{"tags":[],"text":" Register3 = Register1 & Register2 "},{"tags":[{"name":"register1","salience":0.7348219156265259},{"name":"register2 register2","salience":0.2651781141757965}],"text":" neg Register1, Register2 Register2 = ~ Register1 "},{"tags":[{"name":"register2","salience":1}],"text":" Register2 = ~ Register1 "},{"tags":[{"name":"shiftl register1","salience":0.7298029065132141},{"name":"shiftr","salience":0.11663266271352768},{"name":"register2","salience":0.08937640488147736},{"name":"value","salience":0.06418801844120026}],"text":" shiftl Register1, Value, Register2 (similarly for shiftr) Register2 = Register1 << Value "},{"tags":[{"name":"register2","salience":0.7801566123962402},{"name":"value","salience":0.21984337270259857}],"text":" Register2 = Register1 << Value "},{"tags":[{"name":"syscall value","salience":0.6430737376213074},{"name":"system service","salience":0.25674521923065186},{"name":"value","salience":0.06116192042827606},{"name":"service","salience":0.03901911899447441}],"text":" syscall Value invoke a system service; which service determined by Value "},{"tags":[{"name":"system service","salience":0.41729241609573364},{"name":"service","salience":0.39076104760169983},{"name":"value","salience":0.19194650650024414}],"text":" invoke a system service; which service determined by Value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register3","salience":1}],"text":" Register3 = Register1 + Register2 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" Register3 = Register1 & Register2 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register2","salience":1}],"text":" Register2 = ~ Register1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register2","salience":0.7801566123962402},{"name":"value","salience":0.21984337270259857}],"text":" Register2 = Register1 << Value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"system service","salience":0.41729241609573364},{"name":"service","salience":0.39076104760169983},{"name":"value","salience":0.19194650650024414}],"text":" invoke a system service; which service determined by Value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"operator","salience":1}],"text":" determine what the operator is "},{"tags":[{"name":"registers","salience":0.5934883952140808},{"name":"any","salience":0.4065115749835968}],"text":" determine which registers, if any, are involved "},{"tags":[{"name":"memory location","salience":0.5154759883880615},{"name":"any","salience":0.48452404141426086}],"text":" determine which memory location, if any, is involved "},{"tags":[{"name":"operation","salience":0.5743696093559265},{"name":"operands","salience":0.4256303906440735}],"text":" carry out the operation with the relevant operands "},{"tags":[{"name":"store result","salience":0.6508029103279114},{"name":"any","salience":0.2300509661436081},{"name":"register","salience":0.11914613842964172}],"text":" store result, if any, in appropriate register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"instructions","salience":0.6531559228897095},{"name":"mnemonics","salience":0.2016914188861847},{"name":"hex codes","salience":0.14515264332294464}],"text":" write instructions using mnemonics rather than hex codes "},{"tags":[{"name":"reference registers","salience":0.4547956883907318},{"name":"numbers","salience":0.3084128499031067},{"name":"names","salience":0.2367914766073227}],"text":" reference registers using either numbers or names "},{"tags":[{"name":"names","salience":0.5758325457572937},{"name":"memory addresses","salience":0.4241674542427063}],"text":" can associate names to memory addresses "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"control","salience":0.6372127532958984},{"name":"memory usage","salience":0.36278724670410156}],"text":" need to use fine-grained control of memory usage "},{"tags":[{"name":"data","salience":0.5783335566520691},{"name":"registers","salience":0.4216664433479309}],"text":" required to manipulate data in registers "},{"tags":[{"name":"control structures","salience":0.6507119536399841},{"name":"jumps","salience":0.34928804636001587}],"text":" control structures programmed via explicit jumps "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"range","salience":0.5154759883880615},{"name":"computing devices","salience":0.48452404141426086}],"text":" very popular in a range of computing devices in the 1990's "},{"tags":[{"name":"silicon graphics","salience":0.31915223598480225},{"name":"nec","salience":0.22060377895832062},{"name":"nintendo64","salience":0.20565110445022583},{"name":"supercomputers","salience":0.18444126844406128},{"name":"playstation","salience":0.07015160471200943}],"text":" e.g. Silicon Graphics, NEC, Nintendo64, Playstation, supercomputers "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"variants","salience":0.7213504314422607},{"name":"spim emulator","salience":0.27864953875541687}],"text":" using two variants of the open-source SPIM emulator "},{"tags":[{"name":"gui","salience":0.5423165559768677},{"name":"debugging","salience":0.4576834440231323}],"text":" qtspim ... provides a GUI front-end, useful for debugging "},{"tags":[{"name":"command-line","salience":0.4063774645328522},{"name":"version","salience":0.3808820843696594},{"name":"testing","salience":0.2127404659986496}],"text":" spim ... command-line based version, useful for testing "},{"tags":[{"name":"front-end","salience":0.26761990785598755},{"name":"debugging","salience":0.24931269884109497},{"name":"gui","salience":0.23571379482746124},{"name":"labs","salience":0.1339109241962433},{"name":"cse","salience":0.11344267427921295}],"text":" xspim ... GUI front-end, useful for debugging, only in CSE labs "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"text files","salience":0.3752753436565399},{"name":"instruction","salience":0.3517312705516815},{"name":"directives","salience":0.27299338579177856}],"text":" reads text files containing instruction + directives "},{"tags":[{"name":"converts","salience":0.5250181555747986},{"name":"loads","salience":0.17573198676109314},{"name":"machine code","salience":0.17380070686340332},{"name":"memory","salience":0.12544915080070496}],"text":" converts to machine code and loads into \"memory\" "},{"tags":[{"name":"breakpoints","salience":0.4872622489929199},{"name":"memory","salience":0.35067135095596313},{"name":"view registers","salience":0.16206640005111694}],"text":" provides debugging capabilities single-step, breakpoints, view registers/memory, ... "},{"tags":[{"name":"breakpoints","salience":0.43985825777053833},{"name":"view registers","salience":0.41226235032081604},{"name":"memory","salience":0.14787936210632324}],"text":" single-step, breakpoints, view registers/memory, ... "},{"tags":[{"name":"mechanism","salience":0.5891435146331787},{"name":"operating system","salience":0.2313196063041687},{"name":"syscall","salience":0.1795368492603302}],"text":" provides mechanism to interact with operating system (syscall) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"breakpoints","salience":0.43985825777053833},{"name":"view registers","salience":0.41226235032081604},{"name":"memory","salience":0.14787936210632324}],"text":" single-step, breakpoints, view registers/memory, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"ways","salience":0.5485146045684814},{"name":"operations","salience":0.45148539543151855}],"text":" provide convenient/mnemonic ways to do common operations "},{"tags":[],"text":" e.g. move $s0,$v0 rather than addu $s0,$0,$v0 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"command line tool load programs","salience":0.2858593761920929},{"name":"option","salience":0.26711487770080566},{"name":"stdout","salience":0.20762988924980164},{"name":"login terminal","salience":0.14627890288829803},{"name":"stdin","salience":0.09311693906784058}],"text":" spim ... command line tool load programs using -file option interact using stdin/stdout via login terminal "},{"tags":[{"name":"load programs","salience":0.6507119536399841},{"name":"option","salience":0.34928804636001587}],"text":" load programs using -file option "},{"tags":[{"name":"stdin","salience":0.4440673589706421},{"name":"stdout","salience":0.3247269093990326},{"name":"login terminal","salience":0.23120573163032532}],"text":" interact using stdin/stdout via login terminal "},{"tags":[{"name":"gui environment load programs","salience":0.3842686116695404},{"name":"load button","salience":0.26757147908210754},{"name":"terminal","salience":0.13231761753559113},{"name":"stdout","salience":0.13231761753559113},{"name":"pop-up","salience":0.0835246816277504}],"text":" qtspim ... GUI environment load programs via a load button interact via a pop-up stdin/stdout terminal "},{"tags":[{"name":"load programs","salience":0.6507119536399841},{"name":"load button","salience":0.34928804636001587}],"text":" load programs via a load button "},{"tags":[{"name":"pop-up","salience":0.44690966606140137},{"name":"stdout","salience":0.3216305077075958},{"name":"terminal","salience":0.231459841132164}],"text":" interact via a pop-up stdin/stdout terminal "},{"tags":[{"name":"gui environment","salience":0.6013358235359192},{"name":"qtspim","salience":0.23903919756412506},{"name":"x-windows","salience":0.10070125013589859},{"name":"server","salience":0.05892372503876686}],"text":" xspim ... GUI environment similar to qtspim, but not as pretty requires X-windows server "},{"tags":[{"name":"qtspim","salience":1}],"text":" similar to qtspim, but not as pretty "},{"tags":[{"name":"x-windows","salience":0.7838321328163147},{"name":"server","salience":0.2161678820848465}],"text":" requires X-windows server "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"load programs","salience":0.6507119536399841},{"name":"option","salience":0.34928804636001587}],"text":" load programs using -file option "},{"tags":[{"name":"stdin","salience":0.4440673589706421},{"name":"stdout","salience":0.3247269093990326},{"name":"login terminal","salience":0.23120573163032532}],"text":" interact using stdin/stdout via login terminal "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"load programs","salience":0.6507119536399841},{"name":"load button","salience":0.34928804636001587}],"text":" load programs via a load button "},{"tags":[{"name":"pop-up","salience":0.44690966606140137},{"name":"stdout","salience":0.3216305077075958},{"name":"terminal","salience":0.231459841132164}],"text":" interact via a pop-up stdin/stdout terminal "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"qtspim","salience":1}],"text":" similar to qtspim, but not as pretty "},{"tags":[{"name":"x-windows","salience":0.7838321328163147},{"name":"server","salience":0.2161678820848465}],"text":" requires X-windows server "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"purpose registers","salience":1}],"text":" 32 × 32-bit general purpose registers "},{"tags":[{"name":"registers","salience":1}],"text":" 16 × 64-bit double-precision registers "},{"tags":[{"name":"pc","salience":0.6233991980552673},{"name":"register","salience":0.21800990402698517},{"name":"boundary","salience":0.1585909128189087}],"text":" PC ... 32-bit register (always aligned on 4-byte boundary) "},{"tags":[{"name":"hi","salience":0.43957361578941345},{"name":"results","salience":0.19706784188747406},{"name":"lo","salience":0.18674080073833466},{"name":"division","salience":0.1079193651676178},{"name":"multiplication","salience":0.06869836151599884}],"text":" HI,LO ... for storing results of multiplication and division "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"value","salience":1}],"text":" register $0 always has value 0, cannot be written "},{"tags":[{"name":"registers","salience":0.768847644329071},{"name":"system","salience":0.1407572478055954},{"name":"use","salience":0.09039513766765594}],"text":" registers $1, $26, $27 reserved for use by system "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"registers","salience":0.7524243593215942},{"name":"pairs","salience":0.24757564067840576}],"text":" registers come in pairs of 2 × 32-bits "},{"tags":[{"name":"registers","salience":0.7194413542747498},{"name":"double-precision","salience":0.28055864572525024}],"text":" only even registers are addressed for double-precision "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"comments","salience":1}],"text":" comments ... introduced by # "},{"tags":[{"name":"labels","salience":1}],"text":" labels ... appended with : "},{"tags":[{"name":"directives","salience":0.7249495983123779},{"name":"symbol","salience":0.27505040168762207}],"text":" directives ... symbol beginning with . "},{"tags":[{"name":"assembly language instructions","salience":1}],"text":" assembly language instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"data objects","salience":0.8736587166786194},{"name":"data region","salience":0.12634126842021942}],"text":" data objects that live in the data region "},{"tags":[{"name":"functions","salience":0.5206588506698608},{"name":"instruction sequences","salience":0.23053091764450073},{"name":"text","salience":0.11508195102214813},{"name":"region","salience":0.08179201930761337},{"name":"code","salience":0.051936302334070206}],"text":" functions (instruction sequences) that live in the code/text region "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"load","salience":0.572986900806427},{"name":"store","salience":0.25978657603263855},{"name":"data","salience":0.09256055951118469},{"name":"memory","salience":0.04577241837978363},{"name":"registers","salience":0.02889355644583702}],"text":" load and store .. transfer data between registers and memory "},{"tags":[{"name":"operations","salience":1}],"text":" computational ... perform arithmetic/logical operations "},{"tags":[{"name":"jump","salience":0.5132083296775818},{"name":"branch","salience":0.24010717868804932},{"name":"transfer control","salience":0.1589461863040924},{"name":"program execution","salience":0.0877382829785347}],"text":" jump and branch ... transfer control of program execution "},{"tags":[{"name":"interface","salience":0.5846098065376282},{"name":"co-processors","salience":0.4153902232646942}],"text":" coprocessor ... standard interface to various co-processors "},{"tags":[{"name":"tasks","salience":1}],"text":" special ... miscellaneous tasks (e.g. syscall) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"memory","salience":0.7249495983123779},{"name":"register","salience":0.27505040168762207}],"text":" between memory and register (direct, indirect) "},{"tags":[],"text":" constant to register (immediate) "},{"tags":[{"name":"register","salience":0.7201937437057495},{"name":"destination","salience":0.2798062860965729}],"text":" register + register + destination register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"operation","salience":0.5633911490440369},{"name":"store","salience":0.18857604265213013},{"name":"load","salience":0.186503604054451},{"name":"branch","salience":0.061529215425252914}],"text":" an operation (e.g. load, store, add, branch, ...) "},{"tags":[{"name":"operands","salience":0.40657392144203186},{"name":"e.g. registers","salience":0.29087379574775696},{"name":"constants","salience":0.2076450139284134},{"name":"memory addresses","salience":0.0949072614312172}],"text":" one or more operands (e.g. registers, memory addresses, constants) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"name","salience":0.6233991980552673},{"name":"label","salience":0.21800990402698517},{"name":"constant","salience":0.1585909128189087}],"text":" symbolic name (label) (effectively, a constant) "},{"tags":[{"name":"register","salience":0.5758325457572937},{"name":"pointer dereferencing","salience":0.4241674542427063}],"text":" indirectly via a register (effectively, pointer dereferencing) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"address","salience":1}],"text":" computed address for a: is 0x100000008 "},{"tags":[{"name":"address","salience":0.5759657621383667},{"name":"b","salience":0.4240342378616333}],"text":" computed address for b: is 0x100000000 "},{"tags":[{"name":"address","salience":0.5759657621383667},{"name":"c","salience":0.4240342378616333}],"text":" computed address for c: is 0x100000004 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"halfword","salience":0.469355046749115},{"name":"word","salience":0.33778393268585205},{"name":"bytes","salience":0.19286100566387177}],"text":" single bytes, two bytes (\"halfword\"), four bytes (\"word\") "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"byte","salience":0.652863085269928},{"name":"address","salience":0.347136914730072}],"text":" LB ... load one byte from specified address "},{"tags":[{"name":"lbu","salience":0.4813540279865265},{"name":"byte","salience":0.3422468602657318},{"name":"address","salience":0.1763991266489029}],"text":" LBU ... load unsigned byte from specified address "},{"tags":[{"name":"address","salience":1}],"text":" LH ... load two bytes from specified address "},{"tags":[{"name":"lhu","salience":0.780203640460968},{"name":"address","salience":0.21979637444019318}],"text":" LHU ... load unsigned 2-bytes from specified address "},{"tags":[{"name":"word","salience":0.6372127532958984},{"name":"address","salience":0.36278724670410156}],"text":" LW ... load four bytes (one word) from specified address "},{"tags":[{"name":"la","salience":0.6481606364250183},{"name":"address","salience":0.3518393635749817}],"text":" LA ... load the specified address "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"sw","salience":0.6132493615150452},{"name":"sub","salience":0.20300854742527008},{"name":"slt","salience":0.11676771938800812},{"name":"beq","salience":0.06697434186935425}],"text":" lw, sw, add, sub, and, or, sll, slt, beq, j, jal, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"rem","salience":0.4288822114467621},{"name":"li","salience":0.28391149640083313},{"name":"la","salience":0.18709157407283783},{"name":"blt","salience":0.10011472553014755}],"text":" move, rem, la, li, blt, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"registers","salience":0.7229015231132507},{"name":"int","salience":0.27709847688674927}],"text":" treat registers as unsigned int reg[32] "},{"tags":[{"name":"memory","salience":0.7371235489845276},{"name":"char mem","salience":0.2628764510154724}],"text":" treat memory as unsigned char mem[232] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"solution","salience":0.5783335566520691},{"name":"c","salience":0.4216664433479309}],"text":" develop the solution in C "},{"tags":[{"name":"map","salience":0.7815695405006409},{"name":"c","salience":0.21843047440052032}],"text":" map to \"simplified\" C "},{"tags":[{"name":"c statement","salience":0.5783335566520691},{"name":"mips instructions","salience":0.4216664433479309}],"text":" translate each simplified C statement to MIPS instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"switch","salience":0.6398029327392578},{"name":"expressions","salience":0.3601970672607422}],"text":" does not have while, switch, complex expressions "},{"tags":[{"name":"expressions","salience":1}],"text":" does have simple if, goto, one-operator expressions "},{"tags":[{"name":"function calls","salience":0.6514027118682861},{"name":"variables","salience":0.34859731793403625}],"text":" does not have function calls and auto local variables "},{"tags":[],"text":" does have jump-and-remember-where-you-came-from "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"labels","salience":0.6219350099563599},{"name":"name","salience":0.21984653174877167},{"name":"c statement","salience":0.15821844339370728}],"text":" labels ... symbolic name for C statement "},{"tags":[{"name":"control","salience":0.5783335566520691},{"name":"statement","salience":0.4216664433479309}],"text":" goto ... transfer control to labelled statement "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"conventions","salience":0.5733224749565125},{"name":"register names","salience":0.42667752504348755}],"text":" follow the conventions implied by register names "},{"tags":[{"name":"values","salience":0.9041938781738281},{"name":"function calls","salience":0.09580609947443008}],"text":" preserve values that need to be saved across function calls "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register usage","salience":1}],"text":" you manage register usage as you like "},{"tags":[{"name":"use","salience":0.675700843334198},{"name":"registers","salience":0.3242991864681244}],"text":" typically making use of $t? registers "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"control","salience":0.6254516243934631},{"name":"code","salience":0.22854813933372498},{"name":"piece","salience":0.14600026607513428}],"text":" you transfer control to a separate piece of code "},{"tags":[{"name":"value","salience":0.6587997674942017},{"name":"register","salience":0.34120023250579834}],"text":" which may change the value of any non-preserved register "},{"tags":[{"name":"registers","salience":0.6323899030685425},{"name":"function","salience":0.3676101267337799}],"text":" $s? registers must be preserved by function "},{"tags":[{"name":"function","salience":0.6068437695503235},{"name":"registers","salience":0.3931562006473541}],"text":" $a?, $v?, $t? registers may be modified by function "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" x = (1 + y*y) / 2; z = 1.0 / 2; ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"rd","salience":0.5781397819519043},{"name":"li rd","salience":0.17798233032226562},{"name":"const","salience":0.15950438380241394},{"name":"div","salience":0.08437350392341614}],"text":" move Rd,Rs, li Rd,Const, add, div, and, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"sequence","salience":1}],"text":" sequence (;), if, while, for, break, continue, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"slti","salience":0.323254257440567},{"name":"seq","salience":0.323254257440567},{"name":"sltu","salience":0.14656028151512146},{"name":"bgtz","salience":0.10404825955629349},{"name":"beq","salience":0.10288295149803162}],"text":" seq, slti, sltu, ..., beq, bgtz, bgezal, ..., j, jr, jal, ... "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"process","salience":0.5237324237823486},{"name":"sequence","salience":0.3055844008922577},{"name":"operations","salience":0.17068319022655487}],"text":" describing the process as a sequence of binary operations "},{"tags":[{"name":"data flow","salience":0.5758325457572937},{"name":"operations","salience":0.4241674542427063}],"text":" managing data flow between the operations "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"range","salience":0.5154759883880615},{"name":"case values","salience":0.48452404141426086}],"text":" works best for small, dense range of case values (e.g. 1..10) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"cond1","salience":0.780203640460968},{"name":"expression","salience":0.21979637444019318}],"text":" evaluate Cond1; if 0 then return 0 for whole expression "},{"tags":[{"name":"cond2","salience":0.780203640460968},{"name":"expression","salience":0.21979637444019318}],"text":" evaluate Cond2; if 0 then return 0 for whole expression "},{"tags":[],"text":" ... "},{"tags":[{"name":"condn","salience":0.780203640460968},{"name":"expression","salience":0.21979637444019318}],"text":" evaluate Condn; if 0 then return 0 for whole expression "},{"tags":[],"text":" otherwise, return 1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"cond1","salience":0.780203640460968},{"name":"expression","salience":0.21979637444019318}],"text":" evaluate Cond1; if !0 then return 1 for whole expression "},{"tags":[{"name":"cond2","salience":0.780203640460968},{"name":"expression","salience":0.21979637444019318}],"text":" evaluate Cond2; if !0 then return 1 for whole expression "},{"tags":[],"text":" ... "},{"tags":[{"name":"condn","salience":0.780203640460968},{"name":"expression","salience":0.21979637444019318}],"text":" evaluate Condn; if !0 then return 1 for whole expression "},{"tags":[],"text":" otherwise, return 1 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"arguments","salience":0.8312284350395203},{"name":"function","salience":0.16877159476280212}],"text":" the arguments are evaluated and set up for function "},{"tags":[{"name":"control","salience":0.6618804335594177},{"name":"code","salience":0.21694540977478027},{"name":"function","salience":0.1211741641163826}],"text":" control is transferred to the code for the function "},{"tags":[{"name":"variables","salience":1}],"text":" local variables are created "},{"tags":[{"name":"function code","salience":0.6816625595092773},{"name":"environment","salience":0.31833744049072266}],"text":" the function code is executed in this environment "},{"tags":[{"name":"return value","salience":1}],"text":" the return value is set up "},{"tags":[{"name":"control transfers","salience":0.8043056726455688},{"name":"function","salience":0.19569435715675354}],"text":" control transfers back to where the function was called from "},{"tags":[{"name":"caller","salience":0.6309516429901123},{"name":"return value","salience":0.3690483570098877}],"text":" the caller receives the return value "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"registers","salience":0.35946354269981384},{"name":"variables","salience":0.33630555868148804},{"name":"callees","salience":0.1856406331062317},{"name":"parameters","salience":0.11859025806188583}],"text":" used for: saved registers, local variables, parameters to callees "},{"tags":[{"name":"function prologue","salience":1}],"text":" created in the function prologue (pushed) "},{"tags":[{"name":"function epilogue","salience":1}],"text":" removed in the function epilogue (popped) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"function f","salience":1}],"text":" function f() calls g() which calls h() "},{"tags":[],"text":" h() runs, then finishes and returns to g() "},{"tags":[],"text":" g() continues, then finishes and returns to f() "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"caller","salience":0.5269695520401001},{"name":"registers","salience":0.1436973661184311},{"name":"f","salience":0.1436973661184311},{"name":"f","salience":0.05921395123004913},{"name":"anything","salience":0.041615549474954605},{"name":"registers","salience":0.040651530027389526},{"name":"f","salience":0.028423434123396873},{"name":"registers","salience":0.015731247141957283}],"text":" caller saved registers (saved by f()) f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" e.g. $t0 .. $t9, $a0 .. $a3, $ra "},{"tags":[{"name":"anything","salience":0.5767676830291748},{"name":"registers","salience":0.4232323467731476}],"text":" f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" "},{"tags":[{"name":"registers","salience":0.5081885457038879},{"name":"f","salience":0.49181145429611206}],"text":" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" "},{"tags":[],"text":" e.g. $t0 .. $t9, $a0 .. $a3, $ra "},{"tags":[{"name":"registers","salience":0.28266534209251404},{"name":"callee","salience":0.23296886682510376},{"name":"registers","salience":0.14610666036605835},{"name":"f","salience":0.10739728063344955},{"name":"registers","salience":0.0805305615067482},{"name":"values","salience":0.07956348359584808},{"name":"f","salience":0.05152200907468796},{"name":"sp","salience":0.019245799630880356}],"text":" callee saved registers (saved by g()) f() tells g() \"I assume the values of these registers will be unchanged when you return\" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" e.g. $s0 .. $s7, $sp, $fp "},{"tags":[{"name":"values","salience":0.7867732048034668},{"name":"registers","salience":0.21322676539421082}],"text":" f() tells g() \"I assume the values of these registers will be unchanged when you return\" "},{"tags":[{"name":"registers","salience":0.6902694702148438},{"name":"f","salience":0.30973049998283386}],"text":" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" "},{"tags":[{"name":"sp","salience":1}],"text":" e.g. $s0 .. $s7, $sp, $fp "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"anything","salience":0.5767676830291748},{"name":"registers","salience":0.4232323467731476}],"text":" f() tells g() \"If there is anything I want to preserve in these registers, I have already saved it before calling you\" "},{"tags":[{"name":"registers","salience":0.5081885457038879},{"name":"f","salience":0.49181145429611206}],"text":" g() tells f() \"Don't assume that these registers will be unchanged when I return to you\" "},{"tags":[],"text":" e.g. $t0 .. $t9, $a0 .. $a3, $ra "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"values","salience":0.7867732048034668},{"name":"registers","salience":0.21322676539421082}],"text":" f() tells g() \"I assume the values of these registers will be unchanged when you return\" "},{"tags":[{"name":"registers","salience":0.6902694702148438},{"name":"f","salience":0.30973049998283386}],"text":" g() tells f() \"If I need to use these registers, I will save them first and restore them before returning\" "},{"tags":[{"name":"sp","salience":1}],"text":" e.g. $s0 .. $s7, $sp, $fp "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"instruction","salience":0.8495042324066162},{"name":"finishes","salience":0.1504957526922226}],"text":" one instruction can start before the previous one finishes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"instruction","salience":0.5678465366363525},{"name":"branch","salience":0.35658136010169983},{"name":"branch","salience":0.07557207345962524}],"text":" instruction following branch is executed before branch completes "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"sp","salience":0.5653871893882751},{"name":"vars","salience":0.26923656463623047},{"name":"params","salience":0.1653762310743332}],"text":" $sp can change (e.g. pushing params, adding local vars) "},{"tags":[{"name":"vars","salience":0.6372127532958984},{"name":"stack","salience":0.36278724670410156}],"text":" may need to reference local vars on the stack "},{"tags":[{"name":"point","salience":1}],"text":" useful if they can be defined by an offset relative to fixed point "},{"tags":[{"name":"point","salience":0.5999821424484253},{"name":"function code execution","salience":0.4000178575515747}],"text":" $fp provides a fixed point during function code execution "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"args","salience":1}],"text":" place 64-bit double args in $f12 and $f14 "},{"tags":[{"name":"arguments","salience":1}],"text":" place 32-bit arguments in the $a0..$a3 "},{"tags":[{"name":"args","salience":0.37239086627960205},{"name":"args","salience":0.2637135088443756},{"name":"args","salience":0.19045668840408325},{"name":"stack","salience":0.11036983877420425},{"name":"value","salience":0.06306912004947662}],"text":" if more than 4 args, or args larger than 32-bits ... push value of all such args onto stack "},{"tags":[{"name":"value","salience":0.6151715517044067},{"name":"args","salience":0.2166653722524643},{"name":"stack","salience":0.16816309094429016}],"text":" push value of all such args onto stack "},{"tags":[{"name":"non","salience":0.39932650327682495},{"name":"registers","salience":0.39832600951194763},{"name":"registers","salience":0.09978272020816803},{"name":"stack","salience":0.06273151934146881},{"name":"push value","salience":0.03983326628804207}],"text":" save any non-$s? registers that need to be preserved push value of all such registers onto stack "},{"tags":[{"name":"value","salience":0.6151715517044067},{"name":"registers","salience":0.2166653722524643},{"name":"stack","salience":0.16816309094429016}],"text":" push value of all such registers onto stack "},{"tags":[{"name":"address","salience":0.6233991980552673},{"name":"function","salience":0.21800990402698517},{"name":"label","salience":0.1585909128189087}],"text":" jal address of function (usually given by a label) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"value","salience":0.6151715517044067},{"name":"args","salience":0.2166653722524643},{"name":"stack","salience":0.16816309094429016}],"text":" push value of all such args onto stack "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"value","salience":0.6151715517044067},{"name":"registers","salience":0.2166653722524643},{"name":"stack","salience":0.16816309094429016}],"text":" push value of all such registers onto stack "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"stack frame","salience":0.8265856504440308},{"name":"sp","salience":0.17341433465480804}],"text":" create a stack frame for itself (change $fp and $sp) "},{"tags":[{"name":"return address","salience":0.7194413542747498},{"name":"stack frame","salience":0.28055864572525024}],"text":" save the return address ($ra) in the stack frame "},{"tags":[{"name":"registers","salience":1}],"text":" save any $s? registers that it plans to change "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" 4 bytes for saved $fp + 4 bytes for saved $ra "},{"tags":[],"text":" + 4 bytes for each saved $s? "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" new $fp = old $sp - 4 "},{"tags":[{"name":"size","salience":0.7305375337600708},{"name":"frame","salience":0.2694624960422516}],"text":" new $sp = old $sp - size of frame (in bytes) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"return value","salience":0.6592422127723694},{"name":"v1","salience":0.3407577574253082}],"text":" place the return value in $v0 (and maybe $v1) "},{"tags":[{"name":"arguments","salience":0.5783335566520691},{"name":"stack","salience":0.4216664433479309}],"text":" pop any pushed arguments off the stack "},{"tags":[{"name":"values","salience":0.7263602614402771},{"name":"registers","salience":0.2736397087574005}],"text":" restore the values of any saved $s? registers "},{"tags":[{"name":"value","salience":0.5187899470329285},{"name":"return address","salience":0.48121005296707153}],"text":" restore the saved value of $ra (return address) "},{"tags":[{"name":"stack frame","salience":0.6576114892959595},{"name":"sp","salience":0.34238848090171814}],"text":" remove its stack frame (change $fp and $sp) "},{"tags":[{"name":"calling function","salience":1}],"text":" return to the calling function (jr $ra) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" new $sp = old $fp + 4 "},{"tags":[{"name":"memory","salience":1}],"text":" new $fp = memory[old $fp] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"char","salience":0.44506359100341797},{"name":"byte","salience":0.22596636414527893},{"name":"memory","salience":0.14165152609348297},{"name":"byte","salience":0.11483310908079147},{"name":"register","salience":0.07248539477586746}],"text":" char ... as byte in memory, or low-order byte in register "},{"tags":[{"name":"int","salience":0.5444506406784058},{"name":"memory","salience":0.18223634362220764},{"name":"word","salience":0.18023356795310974},{"name":"register","salience":0.09307947009801865}],"text":" int ... as word in memory, or whole register "},{"tags":[{"name":"memory","salience":0.39884674549102783},{"name":"words","salience":0.3945857882499695},{"name":"register","salience":0.20656748116016388}],"text":" double ... as two-words in memory, or $f? register "},{"tags":[{"name":"arrays","salience":0.4473201334476471},{"name":"sequence","salience":0.20281051099300385},{"name":"memory bytes","salience":0.14398226141929626},{"name":"words","salience":0.13303418457508087},{"name":"index","salience":0.07285290211439133}],"text":" arrays ... sequence of memory bytes/words, accessed by index "},{"tags":[{"name":"structs","salience":0.4906282126903534},{"name":"chunk","salience":0.22244597971439362},{"name":"memory","salience":0.15615348517894745},{"name":"offsets","salience":0.07990628480911255},{"name":"fields","salience":0.05086604133248329}],"text":" structs ... chunk of memory, accessed by fields/offsets "},{"tags":[{"name":"structures","salience":0.800235390663147},{"name":"address","salience":0.12368591874837875},{"name":"struct","salience":0.07607871294021606}],"text":" linked structures ... struct containing address of another struct "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"register","salience":0.6537261009216309},{"name":"scope","salience":0.34627392888069153}],"text":" could be implemented in register if used in small scope "},{"tags":[{"name":"stack","salience":1}],"text":" could be implemented on stack if local to function "},{"tags":[{"name":"data","salience":0.6861677169799805},{"name":"persistence","salience":0.31383228302001953}],"text":" could be implemented in .data if need longer persistence "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"memory","salience":0.43218550086021423},{"name":"char str","salience":0.13204994797706604},{"name":"str","salience":0.12178608030080795},{"name":"vec","salience":0.10534689575433731},{"name":"space","salience":0.08179006725549698},{"name":"vec","salience":0.07485271245241165},{"name":"space","salience":0.05198880657553673}],"text":" uninitialised memory allocated at compile/assemble-time, e.g. int val; val: .space 4 char str[20]; str: .space 20 int vec[20]; vec: .space 80 "},{"tags":[{"name":"memory","salience":0.34761980175971985},{"name":"int","salience":0.16580989956855774},{"name":"int arr","salience":0.1148608848452568},{"name":"arr","salience":0.10711099952459335},{"name":"word","salience":0.10711099952459335},{"name":"msg","salience":0.0817524790763855},{"name":"hello\\n","salience":0.04347911849617958},{"name":"char","salience":0.03225582838058472}],"text":" initialised memory allocated at compile/assemble-time, e.g. int val = 5; val: .word 5 int arr[4] = {9,8,7,6}; arr: .word 9, 8, 7, 6 char *msg = \"Hello\\n\"; msg: .asciiz \"Hello\\n\" "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"variables","salience":0.7815695405006409},{"name":"function","salience":0.21843047440052032}],"text":" variables local to a function "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"space","salience":0.6219350099563599},{"name":"stack","salience":0.21984653174877167},{"name":"function prologue","salience":0.15821844339370728}],"text":" use space allocated on stack during function prologue "},{"tags":[{"name":"function","salience":1}],"text":" referenced during function relative to $fp "},{"tags":[{"name":"space","salience":0.6219350099563599},{"name":"stack","salience":0.21984653174877167},{"name":"function epilogue","salience":0.15821844339370728}],"text":" space reclaimed from stack in function epilogue "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"int","salience":0.18290188908576965},{"name":"block","salience":0.14148809015750885},{"name":"memory","salience":0.14148809015750885},{"name":"int","salience":0.07580497115850449},{"name":"malloc","salience":0.0708637535572052},{"name":"char","salience":0.06494040787220001},{"name":"int","salience":0.05272723361849785},{"name":"malloc","salience":0.04922930523753166},{"name":"malloc","salience":0.048649344593286514},{"name":"int","salience":0.04853513836860657},{"name":"sizeof","salience":0.04451505467295647},{"name":"char","salience":0.04451505467295647},{"name":"strcpy","salience":0.01229233667254448},{"name":"string","salience":0.01229233667254448},{"name":"vec","salience":0.009756985120475292}],"text":" uninitialised block of memory allocated at run-time int *ptr = malloc(sizeof(int)); char *str = malloc(20*sizeof(char)); int *vec = malloc(20*sizeof(int)); *ptr = 5; strcpy(str, \"a string\"); vec[0] = 1; // or *vec = 1; vec[1] = 6; "},{"tags":[{"name":"block","salience":0.43338871002197266},{"name":"memory","salience":0.2648797035217285},{"name":"int","salience":0.1294587105512619},{"name":"int","salience":0.0913415476679802},{"name":"sizeof","salience":0.08093134313821793}],"text":" initialised block of memory allocated at run-time int *vec = calloc(20, sizeof(int)); // vec[i] == 0, for i in 0..19 "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"data","salience":1}],"text":" but provides syscall 9 to extend .data "},{"tags":[{"name":"syscall","salience":0.7288792729377747},{"name":"bytes","salience":0.18542474508285522},{"name":"number","salience":0.08569597452878952}],"text":" before syscall, set $a0 to the number of bytes requested "},{"tags":[{"name":"syscall","salience":0.7428349852561951},{"name":"chunk","salience":0.13599497079849243},{"name":"address","salience":0.1211700588464737}],"text":" after syscall, $v0 holds start address of allocated chunk "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"implementation","salience":0.5091436505317688},{"name":"c","salience":0.36834314465522766},{"name":"heap management","salience":0.12251318246126175}],"text":" a complete implementation of C's heap management, i.e. "},{"tags":[{"name":"region","salience":0.578466534614563},{"name":"memory","salience":0.4215334355831146}],"text":" a large region of memory to manage (syscall 9) "},{"tags":[{"name":"ability","salience":0.432430624961853},{"name":"chunks","salience":0.2025153934955597},{"name":"region","salience":0.13763079047203064},{"name":"use","salience":0.12860600650310516},{"name":"size","salience":0.09881717711687088}],"text":" ability to mark chunks of this region as \"in use\" (with size) "},{"tags":[{"name":"ability","salience":0.6219350099563599},{"name":"list","salience":0.21984653174877167},{"name":"chunks","salience":0.15821844339370728}],"text":" ability to maintain list of free chunks "},{"tags":[{"name":"ability","salience":0.615208089351654},{"name":"chunks","salience":0.21746863424777985},{"name":"fragmentation","salience":0.1673232614994049}],"text":" ability to merge free chunks to prevent fragmentation "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"approach","salience":0.768847644329071},{"name":"elements","salience":0.1407572478055954},{"name":"size","salience":0.09039513766765594}],"text":" either approach needs to account for size of elements "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"array size","salience":0.6674092411994934},{"name":"elsewhere","salience":0.3325907289981842}],"text":" must also pass array size, since not available elsewhere "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"things","salience":0.618603527545929},{"name":"human","salience":0.2186688780784607},{"name":"mips code","salience":0.16272760927677155}],"text":" makes things easier for a human to prodcue MIPS code "},{"tags":[{"name":"way","salience":1}],"text":" does not provide an automatic way of translating "},{"tags":[{"name":"compiler","salience":1}],"text":" this is provided by a compiler (e.g. dcc) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[],"text":" convert #include and #define "},{"tags":[{"name":"code","salience":1}],"text":" parse code to check syntactically valid "},{"tags":[{"name":"list","salience":0.44561079144477844},{"name":"symbols","salience":0.3223798871040344},{"name":"program","salience":0.23200932145118713}],"text":" manage a list of symbols used in program "},{"tags":[{"name":"data structures","salience":1}],"text":" decide how to represent data structures "},{"tags":[{"name":"variables","salience":0.3752753436565399},{"name":"registers","salience":0.3517312705516815},{"name":"stack","salience":0.27299338579177856}],"text":" allocate local variables to registers or stack "},{"tags":[{"name":"map control structures","salience":0.5758325457572937},{"name":"mips instructions","salience":0.4241674542427063}],"text":" map control structures to MIPS instructions "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"file","salience":0.43511494994163513},{"name":"file.h","salience":0.18081879615783691},{"name":"contents","salience":0.15519744157791138},{"name":"file","salience":0.1417437642812729},{"name":"name.h","salience":0.0871250331401825}],"text":" #include File replace #include by contents of file \"name.h\" ... uses named File.h <name.h> ... uses File.h in /usr/include "},{"tags":[{"name":"contents","salience":0.5606412291526794},{"name":"file","salience":0.43935874104499817}],"text":" replace #include by contents of file "},{"tags":[{"name":"name.h","salience":0.6641045212745667},{"name":"file.h","salience":0.33589550852775574}],"text":" \"name.h\" ... uses named File.h "},{"tags":[{"name":"file.h","salience":1}],"text":" <name.h> ... uses File.h in /usr/include "},{"tags":[{"name":"name","salience":0.7220973968505859},{"name":"occurences","salience":0.12405356019735336},{"name":"char array","salience":0.06956888735294342},{"name":"constant","salience":0.05289999768137932},{"name":"char array","salience":0.03138016536831856}],"text":" #define Name Constant replace all occurences of symbol Name by Constant e.g #define MAX 5 char array[MAX] → char array[5] "},{"tags":[{"name":"occurences","salience":0.5023859143257141},{"name":"symbol name","salience":0.33701252937316895},{"name":"constant","salience":0.16060155630111694}],"text":" replace all occurences of symbol Name by Constant "},{"tags":[{"name":"char array","salience":0.7396902441978455},{"name":"char array","salience":0.26030978560447693}],"text":" e.g #define MAX 5 char array[MAX] → char array[5] "},{"tags":[{"name":"name","salience":0.43495669960975647},{"name":"params) expression replace name","salience":0.274407297372818},{"name":"params","salience":0.12162825465202332},{"name":"substitutedexpression","salience":0.10776935517787933},{"name":"b","salience":0.037463944405317307},{"name":"b","salience":0.02377444878220558}],"text":" #define Name(Params) Expression replace Name(Params) by SubstitutedExpression e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "},{"tags":[{"name":"params","salience":0.8519662022590637},{"name":"substitutedexpression","salience":0.14803379774093628}],"text":" replace Name(Params) by SubstitutedExpression "},{"tags":[{"name":"b","salience":0.644878089427948},{"name":"b","salience":0.355121910572052}],"text":" e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"contents","salience":0.5606412291526794},{"name":"file","salience":0.43935874104499817}],"text":" replace #include by contents of file "},{"tags":[{"name":"name.h","salience":0.6641045212745667},{"name":"file.h","salience":0.33589550852775574}],"text":" \"name.h\" ... uses named File.h "},{"tags":[{"name":"file.h","salience":1}],"text":" <name.h> ... uses File.h in /usr/include "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"occurences","salience":0.5023859143257141},{"name":"symbol name","salience":0.33701252937316895},{"name":"constant","salience":0.16060155630111694}],"text":" replace all occurences of symbol Name by Constant "},{"tags":[{"name":"char array","salience":0.7396902441978455},{"name":"char array","salience":0.26030978560447693}],"text":" e.g #define MAX 5 char array[MAX] → char array[5] "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"params","salience":0.8519662022590637},{"name":"substitutedexpression","salience":0.14803379774093628}],"text":" replace Name(Params) by SubstitutedExpression "},{"tags":[{"name":"b","salience":0.644878089427948},{"name":"b","salience":0.355121910572052}],"text":" e.g. #define max(x,y) ((x > y) ? x : y) a = max(b,c) → a = ((b > c) ? b : c) "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"scope","salience":0.6576110124588013},{"name":"lifetime","salience":0.34238898754119873}],"text":" scope, lifetime, locally/externally defined "},{"tags":[{"name":"x","salience":0.5871174931526184},{"name":"fun","salience":0.412882536649704}],"text":" disambiguates e.g. x in main() vs x in fun() "},{"tags":[{"name":"symbols","salience":0.48409998416900635},{"name":"data","salience":0.17078019678592682},{"name":"locations","salience":0.16886751353740692},{"name":"registers","salience":0.12124475091695786},{"name":"stack","salience":0.055007558315992355}],"text":" resolves symbols to specific locations (data/stack/registers) "},{"tags":[{"name":"symbols","salience":1}],"text":" external symbols may remain unresolved until linking "},{"tags":[{"name":"type","salience":0.6348069906234741},{"name":"symbol","salience":0.3651930093765259}],"text":" however, need to have a type for each external symbol "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"stack","salience":0.5963461995124817},{"name":"function","salience":0.19960662722587585},{"name":"sw","salience":0.14249245822429657},{"name":"mips","salience":0.0615546889603138}],"text":" on the stack ... +persist for whole function, -lw/sw needed in MIPS "},{"tags":[{"name":"register","salience":0.3512992560863495},{"name":"many","salience":0.13559329509735107},{"name":"scope","salience":0.10732472687959671},{"name":"need","salience":0.0949961319565773},{"name":"var","salience":0.09389834851026535},{"name":"function calls","salience":0.08755849301815033},{"name":"scope","salience":0.07566499710083008},{"name":"register","salience":0.05366476625204086}],"text":" in a register ... +efficient, -not many, useful if var used in small scope if need to persist across function calls, use $s? register if used in very localised scope, can use $t? register "},{"tags":[{"name":"need","salience":0.6508029103279114},{"name":"function calls","salience":0.2300509661436081},{"name":"register","salience":0.11914613842964172}],"text":" if need to persist across function calls, use $s? register "},{"tags":[{"name":"scope","salience":0.6537261009216309},{"name":"register","salience":0.34627392888069153}],"text":" if used in very localised scope, can use $t? register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"need","salience":0.6508029103279114},{"name":"function calls","salience":0.2300509661436081},{"name":"register","salience":0.11914613842964172}],"text":" if need to persist across function calls, use $s? register "},{"tags":[{"name":"scope","salience":0.6537261009216309},{"name":"register","salience":0.34627392888069153}],"text":" if used in very localised scope, can use $t? register "}]},{"tags":[{"name":"list"}],"items":[{"tags":[{"name":"expressions","salience":0.7480986714363098},{"name":"registers","salience":0.2519013583660126}],"text":" even complex expressions don't generally need > 3-4 registers "}]}],"block":[{"tags":[{"name":"paragraph"},{"name":"c: assembly language","salience":0.9005488753318787},{"name":"mips","salience":0.09945113211870193}],"text":"C: Assembly Language (MIPS)"},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"instruction set architectures","salience":1}],"text":" Instruction Set Architectures "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"cpu architecture2","salience":1}],"text":" CPU Architecture2/114 "},{"tags":[{"name":"paragraph"},{"name":"cpu","salience":1}],"text":" A typical modern CPU has "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"study assembler","salience":1}],"text":" Why Study Assembler?3/114 "},{"tags":[{"name":"paragraph"},{"name":"assembly language","salience":1}],"text":" Useful to know assembly language because ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"sets4","salience":1}],"text":" Instruction Sets4/114 "},{"tags":[{"name":"paragraph"},{"name":"families","salience":0.7983086109161377},{"name":"instruction set architectures","salience":0.20169135928153992}],"text":" Two broad families of instruction set architectures ... "},{"tags":[{"name":"paragraph"},{"name":"risc","salience":1}],"text":" RISC (reduced instruction set computer) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"sets5","salience":1}],"text":" ... Instruction Sets5/114 "},{"tags":[{"name":"paragraph"},{"name":"instructions","salience":1}],"text":" Machine-level instructions ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"},{"name":"registers","salience":0.8395260572433472},{"name":"destination","salience":0.16047394275665283}],"text":" Operands and destination are typically registers "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"sets6","salience":1}],"text":" ... Instruction Sets6/114 "},{"tags":[{"name":"paragraph"},{"name":"kinds","salience":0.6233991980552673},{"name":"instructions","salience":0.21800990402698517},{"name":"real machine","salience":0.1585909128189087}],"text":" Common kinds of instructions (not from any real machine) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"sets7","salience":1}],"text":" ... Instruction Sets7/114 "},{"tags":[{"name":"paragraph"},{"name":"kinds","salience":0.4471507966518402},{"name":"instructions","salience":0.3200380802154541},{"name":"real machine","salience":0.23281113803386688}],"text":" Other common kinds of instructions (not from any real machine) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"sets8","salience":1}],"text":" ... Instruction Sets8/114 "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"cycle9","salience":1}],"text":" Fetch-Execute Cycle9/114 "},{"tags":[{"name":"paragraph"},{"name":"cpus","salience":0.7350949645042419},{"name":"program execution logic","salience":0.26490503549575806}],"text":" All CPUs have program execution logic like: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"program counter","salience":0.7164233922958374},{"name":"cpu register","salience":0.17333799600601196},{"name":"track","salience":0.06191433221101761},{"name":"execution","salience":0.04832430183887482}],"text":" PC = Program Counter, a CPU register which keeps track of execution "},{"tags":[{"name":"paragraph"},{"name":"instructions","salience":0.5759657621383667},{"name":"pc","salience":0.4240342378616333}],"text":" Note that some instructions may modify PC further (e.g. JUMP) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" ... Fetch-Execute Cycle10/114 "},{"tags":[{"name":"paragraph"},{"name":"instruction","salience":1}],"text":" Executing an instruction involves "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"assembly language11","salience":1}],"text":" Assembly Language11/114 "},{"tags":[{"name":"paragraph"},{"name":"instructions","salience":0.9054332971572876},{"name":"bit-string","salience":0.0945667028427124}],"text":" Instructions are simply bit patterns within a 32-bit bit-string "},{"tags":[{"name":"paragraph"},{"name":"machine programs","salience":0.49726009368896484},{"name":"sequence","salience":0.30754953622817993},{"name":"hex digits","salience":0.10034827888011932},{"name":"e.g.","salience":0.09484211355447769}],"text":" Could describe machine programs as a sequence of hex digits, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"},{"name":"assembly language","salience":0.5505799651145935},{"name":"assembler","salience":0.4494200348854065}],"text":" Often call \"assembly language\" as \"assembler\" "},{"tags":[{"name":"paragraph"},{"name":"abuse","salience":0.43783149123191833},{"name":"program","salience":0.24408961832523346},{"name":"assembler","salience":0.1525239795446396},{"name":"assembly language","salience":0.09677451103925705},{"name":"machine code","salience":0.06878039985895157}],"text":" Slight notational abuse, because \"assembler\" also refers to a program that translates assembly language to machine code "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"assembly language12","salience":1}],"text":" ... Assembly Language12/114 "},{"tags":[{"name":"paragraph"},{"name":"assembler","salience":0.649027943611145},{"name":"language","salience":0.18116913735866547},{"name":"writing machine code","salience":0.16980291903018951}],"text":" Assembler = symbolic language for writing machine code "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips architecture13","salience":1}],"text":" MIPS Architecture13/114 "},{"tags":[{"name":"paragraph"},{"name":"mips","salience":0.7626896500587463},{"name":"architecture","salience":0.23731034994125366}],"text":" MIPS is a well-known and relatively simple architecture "},{"tags":[{"name":"paragraph"},{"name":"source code","salience":0.48505303263664246},{"name":"home","salience":0.15612763166427612},{"name":"cs1521","salience":0.14425605535507202},{"name":"spim","salience":0.12515097856521606},{"name":"spim","salience":0.08941229432821274}],"text":" Source code for browsing under /home/cs1521/spim/spim "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips","salience":0.7476610541343689},{"name":"spim14","salience":0.2523389458656311}],"text":" MIPS vs SPIM14/114 "},{"tags":[{"name":"paragraph"},{"name":"mips","salience":0.5859708189964294},{"name":"machine architecture","salience":0.3220359683036804},{"name":"instruction set","salience":0.09199320524930954}],"text":" MIPS is a machine architecture, including instruction set "},{"tags":[{"name":"paragraph"},{"name":"spim","salience":0.5462955236434937},{"name":"emulator","salience":0.2882345914840698},{"name":"instruction set","salience":0.11967680603265762},{"name":"mips","salience":0.04579305648803711}],"text":" SPIM is an emulator for the MIPS instruction set "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"spim15","salience":1}],"text":" Using SPIM15/114 "},{"tags":[{"name":"paragraph"},{"name":"ways","salience":0.6320440173149109},{"name":"mips code","salience":0.2071658819913864},{"name":"spim","salience":0.16079013049602509}],"text":" Three ways to execute MIPS code with SPIM "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"spim16","salience":1}],"text":" ... Using SPIM16/114 "},{"tags":[{"name":"paragraph"},{"name":"command-line tool","salience":1}],"text":" Command-line tool: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"spim17","salience":1}],"text":" ... Using SPIM17/114 "},{"tags":[{"name":"paragraph"},{"name":"gui tool","salience":1}],"text":" GUI tool: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips machine archtecture18","salience":1}],"text":" MIPS Machine Archtecture18/114 "},{"tags":[{"name":"paragraph"},{"name":"mips cpu","salience":1}],"text":" MIPS CPU has "},{"tags":[{"name":"paragraph"},{"name":"registers","salience":0.795559823513031},{"name":"uses","salience":0.204440176486969}],"text":" Some registers have special uses e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips machine archtecture19","salience":1}],"text":" ... MIPS Machine Archtecture19/114 "},{"tags":[{"name":"paragraph"},{"name":"registers","salience":0.9197303056716919},{"name":"usage","salience":0.08026968687772751}],"text":" Registers and their usage "},{"tags":[{"name":"paragraph"},{"name":"value","salience":0.1266365498304367},{"name":"notes","salience":0.10305237025022507},{"name":"reg name","salience":0.06252490729093552},{"name":"v0 value","salience":0.05033876746892929},{"name":"expression evaluation","salience":0.04603571444749832},{"name":"function","salience":0.04134456068277359},{"name":"subroutine","salience":0.04134456068277359},{"name":"function","salience":0.04085134342312813},{"name":"function","salience":0.04085134342312813},{"name":"function","salience":0.03801022097468376},{"name":"subroutine","salience":0.03801022097468376},{"name":"argument","salience":0.037219274789094925},{"name":"v1 value","salience":0.03429217264056206},{"name":"expression evaluation","salience":0.03133302554488182},{"name":"return","salience":0.03133302554488182},{"name":"return","salience":0.03133302554488182},{"name":"argument","salience":0.029240844771265984},{"name":"argument","salience":0.029240844771265984},{"name":"subroutine","salience":0.028801510110497475},{"name":"function","salience":0.028801510110497475},{"name":"subroutine","salience":0.02025972120463848},{"name":"subroutine","salience":0.02025972120463848},{"name":"caller","salience":0.013621005229651928},{"name":"subroutine","salience":0.012747054919600487},{"name":"function","salience":0.012747054919600487},{"name":"argument","salience":0.009769648313522339}],"text":" Reg Name Notes $0 zero the value 0, not changeable $1 $at assembler temporary; used to implement pseudo-ops $2 $v0 value from expression evaluation or function return $3 $v1 value from expression evaluation or function return $4 $a0 first argument to a function/subroutine, if needed $5 $a1 second argument to a function/subroutine, if needed $6 $a2 third argument to a function/subroutine, if needed $7 $a3 fourth argument to a function/subroutine, if needed $8..$15 $t0..$t7 temporary; must be saved by caller to subroutine;subroutine can overwrite "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips machine archtecture20","salience":1}],"text":" ... MIPS Machine Archtecture20/114 "},{"tags":[{"name":"paragraph"},{"name":"register usage","salience":1}],"text":" More register usage ... "},{"tags":[{"name":"paragraph"},{"name":"notes","salience":0.22419004142284393},{"name":"reg name","salience":0.1395711451768875},{"name":"function variable","salience":0.09186466783285141},{"name":"subroutine","salience":0.07888935506343842},{"name":"subroutine","salience":0.07888935506343842},{"name":"subroutine","salience":0.07796552777290344},{"name":"caller","salience":0.07222522050142288},{"name":"stack pointer","salience":0.05526755005121231},{"name":"pointer","salience":0.05526755005121231},{"name":"frame pointer","salience":0.039027273654937744},{"name":"caller","salience":0.035660434514284134},{"name":"return address","salience":0.031393710523843765},{"name":"kernel use","salience":0.01978817768394947}],"text":" Reg Name Notes $16..$23 $s0..$s7 safe function variable;must not be overwritten by called subroutine $24..$25 $t8..$t9 temporary; must be saved by caller to subroutine;subroutine can overwrite $26..$27 $k0..$k1 for kernel use; may change unexpectedly $28 $gp global pointer $29 $sp stack pointer $30 $fp frame pointer $31 $ra return address of most recent caller "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips machine archtecture21","salience":1}],"text":" ... MIPS Machine Archtecture21/114 "},{"tags":[{"name":"paragraph"},{"name":"register usage","salience":1}],"text":" Floating point register usage ... "},{"tags":[{"name":"paragraph"},{"name":"reg","salience":0.18742898106575012},{"name":"floating-point function","salience":0.16290713846683502},{"name":"results","salience":0.12397009879350662},{"name":"function","salience":0.11274244636297226},{"name":"registers","salience":0.10536413639783859},{"name":"double-precision function arguments","salience":0.07941675186157227},{"name":"expression evaluation","salience":0.06039775535464287},{"name":"registers","salience":0.05295475572347641},{"name":"function calls","salience":0.042630717158317566},{"name":"value","salience":0.03870522975921631},{"name":"registers","salience":0.03348199278116226}],"text":" Reg Notes $f0..$f2 hold floating-point function results $f4..$f10 temporary registers; not preserved across function calls $f12..$f14 used for first two double-precision function arguments $f16..$f18 temporary registers; used for expression evaluation $f20..$f30 saved registers; value is preserved across function calls "},{"tags":[{"name":"paragraph"},{"name":"notes","salience":1}],"text":" Notes: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips assembly language22","salience":1}],"text":" MIPS Assembly Language22/114 "},{"tags":[{"name":"paragraph"},{"name":"mips","salience":0.5968237519264221},{"name":"assembly language programs","salience":0.40317627787590027}],"text":" MIPS assembly language programs contain "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips assembly language23","salience":1}],"text":" ... MIPS Assembly Language23/114 "},{"tags":[{"name":"paragraph"},{"name":"mips assembler program","salience":1}],"text":" Example MIPS assembler program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"color coding","salience":0.5320023894309998},{"name":"label","salience":0.17611274123191833},{"name":"directive","salience":0.16476689279079437},{"name":"comment","salience":0.12711797654628754}],"text":" Color coding: label, directive, comment "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips assembly language24","salience":1}],"text":" ... MIPS Assembly Language24/114 "},{"tags":[{"name":"paragraph"},{"name":"structure","salience":0.6507119536399841},{"name":"mips programs","salience":0.34928804636001587}],"text":" Generic structure of MIPS programs "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips assembly language25","salience":1}],"text":" ... MIPS Assembly Language25/114 "},{"tags":[{"name":"paragraph"},{"name":"mips assembler program","salience":1}],"text":" Another example MIPS assembler program: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips assembly language26","salience":1}],"text":" ... MIPS Assembly Language26/114 "},{"tags":[{"name":"paragraph"},{"name":"mips programs","salience":0.6507119536399841},{"name":"memory layout","salience":0.34928804636001587}],"text":" MIPS programs assume the following memory layout "},{"tags":[{"name":"paragraph"},{"name":"text 0x00400000","salience":0.20198483765125275},{"name":"region address","salience":0.16328617930412292},{"name":"notes","salience":0.14588673412799835},{"name":"instructions","salience":0.14588673412799835},{"name":"data","salience":0.07369953393936157},{"name":"address","salience":0.043260131031274796},{"name":"data objects","salience":0.04098886623978615},{"name":"writeable","salience":0.04098886623978615},{"name":"stack 0x7fffefff","salience":0.039084192365407944},{"name":"k_data 0x90000000 kernel data","salience":0.03596414253115654},{"name":"mode","salience":0.03288782015442848},{"name":"kernel mode","salience":0.023205244913697243},{"name":"kernel code","salience":0.01287672109901905}],"text":" Region Address Notes text 0x00400000 contains only instructions; read-only; cannot expand data 0x10000000 data objects; readable/writeable; can be expanded stack 0x7fffefff grows down from that address; readable/writeable k_text 0x80000000 kernel code; read-only; only accessible kernel mode k_data 0x90000000 kernel data; read/write; only accessible kernel mode "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instructions27","salience":1}],"text":" MIPS Instructions27/114 "},{"tags":[{"name":"paragraph"},{"name":"mips","salience":0.623616099357605},{"name":"classes","salience":0.28244197368621826},{"name":"instructions","salience":0.09394192695617676}],"text":" MIPS has several classes of instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instructions28","salience":1}],"text":" ... MIPS Instructions28/114 "},{"tags":[{"name":"paragraph"},{"name":"mips instructions","salience":1}],"text":" MIPS instructions are 32-bits long, and specify ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"modes29","salience":1}],"text":" Addressing Modes29/114 "},{"tags":[{"name":"paragraph"},{"name":"memory addresses","salience":1}],"text":" Memory addresses can be given by "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"0x10000000","salience":1}],"text":" If $s0 contains 0x10000000 and &var = 0x100000008 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"modes30","salience":1}],"text":" ... Addressing Modes30/114 "},{"tags":[{"name":"paragraph"},{"name":"modes","salience":0.8674015998840332},{"name":"mips","salience":0.132598415017128}],"text":" Addressing modes in MIPS "},{"tags":[{"name":"paragraph"},{"name":"register","salience":0.2411109209060669},{"name":"format address computation","salience":0.16547149419784546},{"name":"symbol address","salience":0.07452301681041718},{"name":"address","salience":0.0736614316701889},{"name":"register k address","salience":0.0736614316701889},{"name":"address","salience":0.06868582963943481},{"name":"contents","salience":0.0678040087223053},{"name":"symbol symbol","salience":0.05741097033023834},{"name":"address","salience":0.05241069570183754},{"name":"kk","salience":0.04649147018790245},{"name":"register","salience":0.035772014409303665},{"name":"address","salience":0.023483460769057274},{"name":"symbol","salience":0.019513262435793877}],"text":" Format Address computation (register) address = *register = contents of register k address = k k(register) address = k + *register symbol address = &symbol = address of symbol symbol ± k address = &symbol ± k symbol ± k(register) address = &symbol ± (k + *register) "},{"tags":[{"name":"paragraph"},{"name":"value","salience":1}],"text":" where k is a literal constant value (e.g. 4 or 0x10000000) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"modes31","salience":1}],"text":" ... Addressing Modes31/114 "},{"tags":[{"name":"paragraph"},{"name":"examples","salience":0.7229015231132507},{"name":"load/store","salience":0.27709847688674927}],"text":" Examples of load/store and addressing: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"operand sizes32","salience":1}],"text":" Operand Sizes32/114 "},{"tags":[{"name":"paragraph"},{"name":"mips instructions","salience":0.7815695405006409},{"name":"operands","salience":0.21843047440052032}],"text":" MIPS instructions can manipulate different-sized operands "},{"tags":[{"name":"paragraph"},{"name":"leads","salience":0.573721170425415},{"name":"opcodes","salience":0.28032588958740234},{"name":"operation","salience":0.145952969789505}],"text":" Leads to many opcodes for a (conceptually) single operation, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set33","salience":1}],"text":" MIPS Instruction Set33/114 "},{"tags":[{"name":"paragraph"},{"name":"mips","salience":0.43265500664711},{"name":"processor","salience":0.29932543635368347},{"name":"base set","salience":0.1981475055217743},{"name":"instructions","salience":0.06987205892801285}],"text":" The MIPS processor implements a base set of instructions, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"note","salience":0.5132083296775818},{"name":"use","salience":0.24010717868804932},{"name":"register","salience":0.1589461863040924},{"name":"results","salience":0.0877382829785347}],"text":" Note: use of $at register for intermediate results "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set34","salience":1}],"text":" ... MIPS Instruction Set34/114 "},{"tags":[{"name":"paragraph"},{"name":"instructions","salience":1}],"text":" In describing instructions: "},{"tags":[{"name":"paragraph"},{"name":"addr","salience":0.27033358812332153},{"name":"reg","salience":0.11665035784244537},{"name":"source","salience":0.06809759140014648},{"name":"content","salience":0.06809759140014648},{"name":"register","salience":0.06809759140014648},{"name":"reg","salience":0.055663999170064926},{"name":"syntaxsemantics","salience":0.036298658698797226},{"name":"reg","salience":0.036203522235155106},{"name":"value","salience":0.03127344697713852},{"name":"destination","salience":0.026656417176127434},{"name":"address","salience":0.022924009710550308},{"name":"reg","salience":0.021647682413458824},{"name":"value","salience":0.021262548863887787},{"name":"label","salience":0.018322035670280457},{"name":"register","salience":0.0181010439991951},{"name":"label","salience":0.016829192638397217},{"name":"c terms","salience":0.016120152547955513},{"name":"expression","salience":0.01480451226234436},{"name":"memory cell memory","salience":0.013933973386883736},{"name":"destination","salience":0.012720263563096523},{"name":"value","salience":0.010500309057533741},{"name":"value","salience":0.010500309057533741},{"name":"memory","salience":0.009781865403056145},{"name":"&label","salience":0.009573879651725292},{"name":"source","salience":0.005605452693998814}],"text":" SyntaxSemantics $Reg as source, the content of the register, reg[Reg] $Reg as destination, value is stored in register, reg[Reg] = value Label references the associated address (in C terms, &Label) Addr any expression that yields an address (e.g. Label($Reg)) Addr as source, the content of memory cell memory[Addr] Addr as destination, value is stored in memory[Addr] = value "},{"tags":[{"name":"paragraph"}],"text":" Effectively ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set35","salience":1}],"text":" ... MIPS Instruction Set35/114 "},{"tags":[{"name":"paragraph"},{"name":"examples","salience":0.8837491273880005},{"name":"data movement instructions","salience":0.11625086516141891}],"text":" Examples of data movement instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"examples","salience":0.8837491273880005},{"name":"bit manipulation instructions","salience":0.11625086516141891}],"text":" Examples of bit manipulation instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set36","salience":1}],"text":" ... MIPS Instruction Set36/114 "},{"tags":[{"name":"paragraph"},{"name":"examples","salience":0.7371235489845276},{"name":"arithmetic instructions","salience":0.2628764510154724}],"text":" Examples of arithmetic instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set37","salience":1}],"text":" ... MIPS Instruction Set37/114 "},{"tags":[{"name":"paragraph"},{"name":"examples","salience":0.6815314292907715},{"name":"testing","salience":0.2383394092321396},{"name":"instructions","salience":0.08012917637825012}],"text":" Examples of testing and branching instructions: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"execution","salience":0.4783741533756256},{"name":"branch instruction","salience":0.342385470867157},{"name":"pc location","salience":0.1792403757572174}],"text":" After each branch instruction, execution continues at new PC location "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set38","salience":1}],"text":" ... MIPS Instruction Set38/114 "},{"tags":[{"name":"paragraph"},{"name":"jump instruction","salience":0.5758325457572937},{"name":"functions","salience":0.4241674542427063}],"text":" Special jump instruction for invoking functions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set39","salience":1}],"text":" ... MIPS Instruction Set39/114 "},{"tags":[{"name":"paragraph"},{"name":"spim","salience":0.4346257746219635},{"name":"stdin","salience":0.21275664865970612},{"name":"stdout","salience":0.19905006885528564},{"name":"syscalls","salience":0.15356750786304474}],"text":" SPIM interacts with stdin/stdout via syscalls "},{"tags":[{"name":"paragraph"},{"name":"integer","salience":0.2570497393608093},{"name":"float","salience":0.18375757336616516},{"name":"servicecodeargumentsresult","salience":0.16228845715522766},{"name":"float","salience":0.0849357321858406},{"name":"integer","salience":0.07506734132766724},{"name":"char","salience":0.07419004291296005},{"name":"buffer","salience":0.059652671217918396},{"name":"lengthstring","salience":0.05262206122279167},{"name":"buffer","salience":0.033572182059288025},{"name":"\\n\\0","salience":0.016864191740751266}],"text":" ServiceCodeArgumentsResult print_int1$a0 = integer print_float2$f12 = float print_double3$f12 = double print_string4$a0 = char * read_int5 integer in $v0 read_float6 float in $f0 read_double7 double in $f0 read_string8$a0 = buffer, $a1 = lengthstring in buffer (including \"\\n\\0\") "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips instruction set40","salience":1}],"text":" ... MIPS Instruction Set40/114 "},{"tags":[{"name":"paragraph"},{"name":"directives","salience":0.470302015542984},{"name":"instructions","salience":0.24561959505081177},{"name":"assembler","salience":0.15741761028766632},{"name":"mips instructions","salience":0.1266607940196991}],"text":" Directives (instructions to assembler, not MIPS instructions) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips programming41","salience":1}],"text":" MIPS Programming41/114 "},{"tags":[{"name":"paragraph"},{"name":"mips assembler","salience":1}],"text":" Writing directly in MIPS assembler is difficult (impossible?) "},{"tags":[{"name":"paragraph"},{"name":"strategy","salience":0.7187902927398682},{"name":"mips code","salience":0.2812097370624542}],"text":" Strategy for producing likely correct MIPS code "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips programming42","salience":1}],"text":" ... MIPS Programming42/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.6815314292907715},{"name":"c","salience":0.2383394092321396},{"name":"mips","salience":0.08012917637825012}],"text":" Example translating C to MIPS: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips programming43","salience":1}],"text":" ... MIPS Programming43/114 "},{"tags":[{"name":"paragraph"},{"name":"c","salience":0.8316866755485535},{"name":"use","salience":0.16831333935260773}],"text":" Simplified C makes extensive use of "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips programming44","salience":1}],"text":" ... MIPS Programming44/114 "},{"tags":[{"name":"paragraph"},{"name":"registers","salience":0.4563129246234894},{"name":"parts","salience":0.3061056435108185},{"name":"code","salience":0.23758143186569214}],"text":" Beware: registers are shared by all parts of the code. "},{"tags":[{"name":"paragraph"},{"name":"function","salience":0.6593352556228638},{"name":"value","salience":0.21502183377742767},{"name":"function","salience":0.12564292550086975}],"text":" One function can overwrite value set by another function "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"function","salience":1}],"text":" After the function, x == 6 and y == 120 "},{"tags":[{"name":"paragraph"},{"name":"coincidence","salience":0.7861767411231995},{"name":"value","salience":0.21382325887680054}],"text":" It is sheer coincidence that y has the correct value. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips programming45","salience":1}],"text":" ... MIPS Programming45/114 "},{"tags":[{"name":"paragraph"},{"name":"registers","salience":1}],"text":" Need to be careful managing registers "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"rendering c","salience":0.6815741658210754},{"name":"mips46","salience":0.31842583417892456}],"text":" Rendering C in MIPS46/114 "},{"tags":[{"name":"paragraph"},{"name":"c","salience":0.5352396965026855},{"name":"assignment","salience":0.2527196407318115},{"name":"expression evaluation","salience":0.21204064786434174}],"text":" C provides expression evaluation and assignment, e.g. "},{"tags":[{"name":"paragraph"},{"name":"sequence","salience":0.39896708726882935},{"name":"s2 → mips","salience":0.3618650734424591},{"name":"s1","salience":0.18660780787467957},{"name":"s2","salience":0.052560001611709595}],"text":" Sequence is easy S1 ; S2 → mips(S1) mips(S2) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"rendering c","salience":0.6364306211471558},{"name":"mips47","salience":0.3635694086551666}],"text":" ... Rendering C in MIPS47/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.5091436505317688},{"name":"assignment","salience":0.36834314465522766},{"name":"sequence","salience":0.12251318246126175}],"text":" Simple example of assignment and sequence: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arithmetic expressions48","salience":1}],"text":" Arithmetic Expressions48/114 "},{"tags":[{"name":"paragraph"},{"name":"expression evaluation","salience":1}],"text":" Expression evaluation involves "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"number","salience":0.4104994833469391},{"name":"registers","salience":0.37983283400535583},{"name":"evaluation","salience":0.20966768264770508}],"text":" It is useful to minimise the number of registers involved in the evaluation "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements49","salience":1}],"text":" Conditional Statements49/114 "},{"tags":[{"name":"paragraph"},{"name":"statements","salience":1}],"text":" Conditional statements (e.g. if) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements50","salience":1}],"text":" ... Conditional Statements50/114 "},{"tags":[{"name":"paragraph"},{"name":"statements","salience":1}],"text":" Conditional statements (e.g. if) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements51","salience":1}],"text":" ... Conditional Statements51/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":1}],"text":" Example of if-then-else: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements52","salience":1}],"text":" ... Conditional Statements52/114 "},{"tags":[{"name":"paragraph"},{"name":"switch","salience":1}],"text":" Could make switch by first converting to if "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements53","salience":1}],"text":" ... Conditional Statements53/114 "},{"tags":[{"name":"paragraph"},{"name":"jump table","salience":0.6320440173149109},{"name":"implementation","salience":0.2071658819913864},{"name":"switch","salience":0.16079013049602509}],"text":" Jump table: an alternative implementation of switch "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"expressions54","salience":1}],"text":" Boolean Expressions54/114 "},{"tags":[{"name":"paragraph"},{"name":"expressions","salience":0.4177604615688324},{"name":"c","salience":0.3084281384944916},{"name":"short circuit","salience":0.273811399936676}],"text":" Boolean expressions in C are short circuit "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Evaluates by "},{"tags":[{"name":"paragraph"},{"name":"c99 standard","salience":0.5961312651634216},{"name":"return value","salience":0.20847399532794952},{"name":"expressions","salience":0.19539472460746765}],"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"expressions55","salience":1}],"text":" ... Boolean Expressions55/114 "},{"tags":[{"name":"paragraph"},{"name":"disjunctions","salience":1}],"text":" Similarly for disjunctions "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Evaluates by "},{"tags":[{"name":"paragraph"},{"name":"c99 standard","salience":0.5961312651634216},{"name":"return value","salience":0.20847399532794952},{"name":"expressions","salience":0.19539472460746765}],"text":" C99 standard defines return value for booleans expressions as 0 or 1 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements56","salience":1}],"text":" Iteration Statements56/114 "},{"tags":[{"name":"paragraph"},{"name":"iteration","salience":1}],"text":" Iteration (e.g. while) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"case","salience":1}],"text":" Treat for as a special case of while "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"statements57","salience":1}],"text":" ... Iteration Statements57/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.6815314292907715},{"name":"iteration","salience":0.2383394092321396},{"name":"array","salience":0.08012917637825012}],"text":" Example of iteration over an array: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"functions58","salience":1}],"text":" Functions58/114 "},{"tags":[{"name":"paragraph"},{"name":"function","salience":1}],"text":" When we call a function: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"functions59","salience":1}],"text":" ... Functions59/114 "},{"tags":[{"name":"paragraph"},{"name":"data","salience":0.6114726066589355},{"name":"function calls","salience":0.20242036879062653},{"name":"stack","salience":0.1461068093776703},{"name":"mips","salience":0.04000018909573555}],"text":" Data associated with function calls is placed on the MIPS stack. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"functions60","salience":1}],"text":" ... Functions60/114 "},{"tags":[{"name":"paragraph"},{"name":"function","salience":0.6317074298858643},{"name":"section","salience":0.139549121260643},{"name":"stack","salience":0.1291240155696869},{"name":"frame","salience":0.09961942583322525}],"text":" Each function allocates a small section of the stack (a frame) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"functions61","salience":1}],"text":" ... Functions61/114 "},{"tags":[{"name":"paragraph"},{"name":"stack changes","salience":0.44561079144477844},{"name":"functions","salience":0.3223798871040344},{"name":"return","salience":0.23200932145118713}],"text":" How stack changes as functions are called and return: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"functions62","salience":1}],"text":" ... Functions62/114 "},{"tags":[{"name":"paragraph"},{"name":"usage conventions","salience":0.578466534614563},{"name":"f","salience":0.4215334355831146}],"text":" Register usage conventions when f() calls g(): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"functions63","salience":1}],"text":" ... Functions63/114 "},{"tags":[{"name":"paragraph"},{"name":"contents","salience":0.8837491273880005},{"name":"stack frame","salience":0.11625086516141891}],"text":" Contents of a typical stack frame: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mips branch delay slots64","salience":1}],"text":" Aside: MIPS Branch Delay Slots64/114 "},{"tags":[{"name":"paragraph"},{"name":"mips architecture","salience":0.6514027118682861},{"name":"efficiency","salience":0.34859731793403625}],"text":" The real MIPS architecture is \"pipelined\" to improve efficiency "},{"tags":[{"name":"paragraph"},{"name":"problem scenario","salience":0.6298776268959045},{"name":"solution","salience":0.21595753729343414},{"name":"branch delay slot","salience":0.15416482090950012}],"text":" A problem scenario, and its solution (branch delay slot): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"spim","salience":0.8565239310264587},{"name":"nop","salience":0.14347608387470245}],"text":" Since SPIM is not pipelined, the nop is not required "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"aside","salience":1}],"text":" Aside: Why do we need both $fp and $sp?65/114 "},{"tags":[{"name":"paragraph"},{"name":"execution","salience":0.6507119536399841},{"name":"function","salience":0.34928804636001587}],"text":" During execution of a function "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol66","salience":1}],"text":" Function Calling Protocol66/114 "},{"tags":[{"name":"paragraph"},{"name":"function","salience":0.5802294015884399},{"name":"another","salience":0.41977056860923767}],"text":" Before one function calls another, it needs to "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol67","salience":1}],"text":" ... Function Calling Protocol67/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.7815695405006409},{"name":"function call","salience":0.21843047440052032}],"text":" Example: simple function call "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol68","salience":1}],"text":" ... Function Calling Protocol68/114 "},{"tags":[{"name":"paragraph"},{"name":"function call","salience":1}],"text":" Simple function call: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol69","salience":1}],"text":" ... Function Calling Protocol69/114 "},{"tags":[{"name":"paragraph"},{"name":"execution","salience":0.6815314292907715},{"name":"sum","salience":0.2383394092321396},{"name":"function","salience":0.08012917637825012}],"text":" Execution of sum() function: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol70","salience":1}],"text":" ... Function Calling Protocol70/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.42856845259666443},{"name":"function f","salience":0.21298955380916595},{"name":"function","salience":0.1492970883846283},{"name":"b","salience":0.12364453822374344},{"name":"c","salience":0.04275018349289894},{"name":"d","salience":0.04275018349289894}],"text":" Example: function f() calls function g(a,b,c,d,e,f) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol71","salience":1}],"text":" ... Function Calling Protocol71/114 "},{"tags":[{"name":"paragraph"},{"name":"function call","salience":0.5934883952140808},{"name":"mips","salience":0.4065115749835968}],"text":" Function call in MIPS: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"calling protocol72","salience":1}],"text":" ... Function Calling Protocol72/114 "},{"tags":[{"name":"paragraph"},{"name":"execution","salience":0.8837491273880005},{"name":"function","salience":0.11625086516141891}],"text":" Execution of g() function: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structure","salience":0.804345965385437},{"name":"functions73","salience":0.195654034614563}],"text":" Structure of Functions73/114 "},{"tags":[{"name":"paragraph"},{"name":"functions","salience":0.6343809962272644},{"name":"mips","salience":0.20220941305160522},{"name":"structure","salience":0.16340959072113037}],"text":" Functions in MIPS have the following general structure: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"aim","salience":0.4734216332435608},{"name":"prologue","salience":0.22149275243282318},{"name":"environment","salience":0.1584618091583252},{"name":"function","salience":0.14662380516529083}],"text":" Aim of prologue: create environment for function to execute in. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"prologue74","salience":1}],"text":" Function Prologue74/114 "},{"tags":[{"name":"paragraph"},{"name":"function","salience":1}],"text":" Before a function starts working, it needs to ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"prologue75","salience":1}],"text":" ... Function Prologue75/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.5257642269134521},{"name":"function fx","salience":0.47423580288887024}],"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"prologue76","salience":1}],"text":" ... Function Prologue76/114 "},{"tags":[{"name":"paragraph"},{"name":"push","salience":1}],"text":" Alternatively ... (more explicit push) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"prologue77","salience":1}],"text":" ... Function Prologue77/114 "},{"tags":[{"name":"paragraph"}],"text":" Alternatively ... (relative to new $fp) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"epilogue78","salience":1}],"text":" Function Epilogue78/114 "},{"tags":[{"name":"paragraph"},{"name":"function","salience":1}],"text":" Before a function returns, it needs to ... "},{"tags":[{"name":"paragraph"},{"name":"sp","salience":1}],"text":" Changing $fp and $sp ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"epilogue79","salience":1}],"text":" ... Function Epilogue79/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.5257642269134521},{"name":"function fx","salience":0.47423580288887024}],"text":" Example of function fx(), which uses $s0, $s1, $s2 "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"data structures","salience":0.6815741658210754},{"name":"mips80","salience":0.31842583417892456}],"text":" Data Structures and MIPS80/114 "},{"tags":[{"name":"paragraph"},{"name":"data structures","salience":0.8926950693130493},{"name":"mips representations","salience":0.10730495303869247}],"text":" C data structures and their MIPS representations: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"dynamic allocation81","salience":1}],"text":" Static vs Dynamic Allocation81/114 "},{"tags":[{"name":"paragraph"},{"name":"allocation","salience":1}],"text":" Static allocation: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"dynamic allocation82","salience":1}],"text":" ... Static vs Dynamic Allocation82/114 "},{"tags":[{"name":"paragraph"},{"name":"allocation","salience":1}],"text":" Dynamic allocation (i): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"dynamic allocation83","salience":1}],"text":" ... Static vs Dynamic Allocation83/114 "},{"tags":[{"name":"paragraph"},{"name":"example","salience":0.6815314292907715},{"name":"variables","salience":0.2383394092321396},{"name":"stack","salience":0.08012917637825012}],"text":" Example of local variables on the stack: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"dynamic allocation84","salience":1}],"text":" ... Static vs Dynamic Allocation84/114 "},{"tags":[{"name":"paragraph"},{"name":"allocation","salience":1}],"text":" Dynamic allocation (ii): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"dynamic allocation85","salience":1}],"text":" ... Static vs Dynamic Allocation85/114 "},{"tags":[{"name":"paragraph"},{"name":"spim","salience":0.7684609293937683},{"name":"malloc","salience":0.2315390557050705}],"text":" SPIM doesn't provide malloc()/free() functions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"access","salience":0.4780457317829132},{"name":"cannot","salience":0.20283319056034088},{"name":"data","salience":0.1386278122663498},{"name":"name","salience":0.09841672331094742},{"name":"address","salience":0.0820765271782875}],"text":" Cannot access allocated data by name; need to retain address. "},{"tags":[{"name":"paragraph"},{"name":"way","salience":0.5880916714668274},{"name":"data","salience":0.2001838982105255},{"name":"data","salience":0.1450570523738861},{"name":"way","salience":0.06666740775108337}],"text":" No way to free allocated data, and no way to align data appropriately "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"dynamic allocation86","salience":1}],"text":" ... Static vs Dynamic Allocation86/114 "},{"tags":[{"name":"paragraph"},{"name":"malloc","salience":0.6857648491859436},{"name":"mips","salience":0.314235121011734}],"text":" Implementing C-like malloc() and free() in MIPS requires "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.6275835633277893},{"name":"mips87","salience":0.3724164664745331}],"text":" 1-d Arrays in MIPS87/114 "},{"tags":[{"name":"paragraph"}],"text":" Can be named/initialised as noted above: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"elements","salience":0.34624531865119934},{"name":"index","salience":0.247713103890419},{"name":"cursor","salience":0.22920753061771393},{"name":"pointer","salience":0.17683404684066772}],"text":" Can access elements via index or cursor (pointer) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips88","salience":0.16170717775821686}],"text":" ... 1-d Arrays in MIPS88/114 "},{"tags":[{"name":"paragraph"},{"name":"array","salience":0.5359765887260437},{"name":"index","salience":0.28382930159568787},{"name":"elements","salience":0.18019412457942963}],"text":" Scanning across an array of N elements using index "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"existence","salience":0.3998737037181854},{"name":"print","salience":0.20302267372608185},{"name":"printf","salience":0.17845739424228668},{"name":"function","salience":0.12726882100105286},{"name":"d\\n","salience":0.09137740731239319}],"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips89","salience":0.16170717775821686}],"text":" ... 1-d Arrays in MIPS89/114 "},{"tags":[{"name":"paragraph"},{"name":"array","salience":0.5359765887260437},{"name":"cursor","salience":0.28382930159568787},{"name":"elements","salience":0.18019412457942963}],"text":" Scanning across an array of N elements using cursor "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"existence","salience":0.3998737037181854},{"name":"print","salience":0.20302267372608185},{"name":"printf","salience":0.17845739424228668},{"name":"function","salience":0.12726882100105286},{"name":"d\\n","salience":0.09137740731239319}],"text":" Assumes the existence of a print() function to do printf(\"%d\\n\",x) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips90","salience":0.16170717775821686}],"text":" ... 1-d Arrays in MIPS90/114 "},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.7517251968383789},{"name":"functions","salience":0.1358117163181305},{"name":"stack","salience":0.06871873140335083},{"name":"space","salience":0.04374436289072037}],"text":" Arrays that are local to functions are allocated space on the stack "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.6275835633277893},{"name":"mips91","salience":0.3724164664745331}],"text":" 2-d Arrays in MIPS91/114 "},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.7264972925186157},{"name":"ways","salience":0.2735027074813843}],"text":" 2-d arrays could be represented two ways: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips92","salience":0.16170717775821686}],"text":" ... 2-d Arrays in MIPS92/114 "},{"tags":[{"name":"paragraph"},{"name":"representations","salience":0.7249495983123779},{"name":"int matrix","salience":0.27505040168762207}],"text":" Representations of int matrix[4][4] ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"elements","salience":1}],"text":" Now consider summing all elements "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips93","salience":0.16170717775821686}],"text":" ... 2-d Arrays in MIPS93/114 "},{"tags":[{"name":"paragraph"},{"name":"elements","salience":1}],"text":" Accessing elements: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips94","salience":0.16170717775821686}],"text":" ... 2-d Arrays in MIPS94/114 "},{"tags":[{"name":"paragraph"},{"name":"computing sum","salience":0.4742475152015686},{"name":"elements","salience":0.22187915444374084},{"name":"strategy","salience":0.15699371695518494},{"name":"int matrix","salience":0.14687959849834442}],"text":" Computing sum of all elements for strategy (a) int matrix[4][4] "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"arrays","salience":0.8382928371429443},{"name":"mips95","salience":0.16170717775821686}],"text":" ... 2-d Arrays in MIPS95/114 "},{"tags":[{"name":"paragraph"},{"name":"computing sum","salience":0.4742475152015686},{"name":"elements","salience":0.22187915444374084},{"name":"strategy","salience":0.15699371695518494},{"name":"int matrix","salience":0.14687959849834442}],"text":" Computing sum of all elements for strategy (b) int matrix[4][4] "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.7476610541343689},{"name":"mips96","salience":0.2523389458656311}],"text":" Structs in MIPS96/114 "},{"tags":[{"name":"paragraph"},{"name":"c structs","salience":0.4707146883010864},{"name":"collection","salience":0.25687509775161743},{"name":"values","salience":0.17552204430103302},{"name":"name","salience":0.09688815474510193}],"text":" C structs hold a collection of values accessed by name "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.5882814526557922},{"name":"mips97","salience":0.41171854734420776}],"text":" ... Structs in MIPS97/114 "},{"tags":[{"name":"paragraph"},{"name":"definitions","salience":0.6507119536399841},{"name":"type","salience":0.34928804636001587}],"text":" C struct definitions effectively define a new type. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"instances","salience":0.5560528039932251},{"name":"structures","salience":0.29194480180740356},{"name":"space","salience":0.15200240910053253}],"text":" Instances of structures can be created by allocating space: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.5882814526557922},{"name":"mips98","salience":0.41171854734420776}],"text":" ... Structs in MIPS98/114 "},{"tags":[{"name":"paragraph"},{"name":"structure components","salience":0.7466727495193481},{"name":"name","salience":0.25332725048065186}],"text":" Accessing structure components is by offset, not name "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.5882814526557922},{"name":"mips99","salience":0.41171854734420776}],"text":" ... Structs in MIPS99/114 "},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.7517251968383789},{"name":"functions","salience":0.1358117163181305},{"name":"stack","salience":0.06871873140335083},{"name":"space","salience":0.04374436289072037}],"text":" Structs that are local to functions are allocated space on the stack "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.5882814526557922},{"name":"mips100","salience":0.41171854734420776}],"text":" ... Structs in MIPS100/114 "},{"tags":[{"name":"paragraph"},{"name":"c","salience":0.6691409349441528},{"name":"structures","salience":0.25218668580055237},{"name":"functions","salience":0.07867240160703659}],"text":" C can pass whole structures to functions, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":0.5882814526557922},{"name":"mips101","salience":0.41171854734420776}],"text":" ... Structs in MIPS101/114 "},{"tags":[{"name":"paragraph"},{"name":"struct","salience":0.5934883952140808},{"name":"function","salience":0.4065115749835968}],"text":" Accessing struct within function ... "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"structs","salience":1}],"text":" ... Structs in MIPS102/114 "},{"tags":[{"name":"paragraph"},{"name":"pointer","salience":0.5931417942047119},{"name":"struct","salience":0.4068582355976105}],"text":" Can also pass a pointer to a struct "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"way","salience":0.6383917927742004},{"name":"struct","salience":0.36160823702812195}],"text":" Clearly a more efficient way to pass a large struct "},{"tags":[{"name":"paragraph"},{"name":"function","salience":0.6537261009216309},{"name":"struct","salience":0.34627392888069153}],"text":" Also, required if the function needs to update the original struct "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"c","salience":1}],"text":" Compiling C to MIPS103/114 "},{"tags":[{"name":"paragraph"},{"name":"c","salience":0.5783335566520691},{"name":"language","salience":0.4216664433479309}],"text":" Using simplified C as an intermediate language "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"c pre-processor104","salience":1}],"text":" C Pre-processor104/114 "},{"tags":[{"name":"paragraph"},{"name":"substitutions","salience":1}],"text":" Maps C→C, performing various substitutions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"c pre-processor105","salience":1}],"text":" ... C Pre-processor105/114 "},{"tags":[{"name":"paragraph"},{"name":"c pre-processor substitions","salience":1}],"text":" More C pre-processor substitions "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"c parser106","salience":1}],"text":" C Parser106/114 "},{"tags":[{"name":"paragraph"},{"name":"syntax","salience":0.5808253884315491},{"name":"c language","salience":0.4191746115684509}],"text":" Understands syntax of C language "},{"tags":[{"name":"paragraph"},{"name":"attempts","salience":0.6219350099563599},{"name":"c program","salience":0.21984653174877167},{"name":"tree","salience":0.15821844339370728}],"text":" Attempts to convert C program into parse tree "},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"symbol table management107","salience":1}],"text":" Symbol Table Management107/114 "},{"tags":[{"name":"paragraph"},{"name":"compiler","salience":0.6028552651405334},{"name":"track","salience":0.22253826260566711},{"name":"names","salience":0.17460647225379944}],"text":" Compiler keeps track of names "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"variables108","salience":1}],"text":" Local Variables108/114 "},{"tags":[{"name":"paragraph"},{"name":"choices","salience":0.6507119536399841},{"name":"variables","salience":0.34928804636001587}],"text":" Two choices for local variables "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"expression evaluation109","salience":1}],"text":" Expression Evaluation109/114 "},{"tags":[{"name":"paragraph"},{"name":"registers","salience":1}],"text":" Uses temporary ($t?) registers "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"expressions","salience":0.6507119536399841},{"name":"short-circuit evaluation","salience":0.34928804636001587}],"text":" Complex boolean expressions handled by short-circuit evaluation. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mapping control structures110","salience":1}],"text":" Mapping Control Structures110/114 "},{"tags":[{"name":"paragraph"},{"name":"use templates","salience":1}],"text":" Use templates, e.g. "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"mapping control structures111","salience":1}],"text":" ... Mapping Control Structures111/114 "},{"tags":[{"name":"paragraph"},{"name":"template","salience":1}],"text":" Template for if...else if... else "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"argc","salience":0.7476610541343689},{"name":"argv112","salience":0.2523389458656311}],"text":" Argc and Argv112/114 "},{"tags":[{"name":"paragraph"},{"name":"mips machine","salience":0.4741525948047638},{"name":"idea","salience":0.38702186942100525},{"name":"argc","salience":0.13882553577423096}],"text":" The real MIPS machine has no idea about argc and argv "},{"tags":[{"name":"paragraph"},{"name":"spim","salience":0.6338462233543396},{"name":"linux","salience":0.19899313151836395},{"name":"environment","salience":0.16716067492961884}],"text":" SPIM runs under Linux, and needs to interact with environment "},{"tags":[{"name":"paragraph"},{"name":"initialisation code","salience":1}],"text":" So, the initialisation code (that invokes main) sets them up: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"},{"name":"note","salience":0.6354618668556213},{"name":"envp","salience":0.2126992642879486},{"name":"environment pointer","salience":0.15183885395526886}],"text":" Note: we are ignoring envp (environment pointer) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"argc","salience":0.5882814526557922},{"name":"argv113","salience":0.41171854734420776}],"text":" ... Argc and Argv113/114 "},{"tags":[{"name":"paragraph"},{"name":"program","salience":1}],"text":" What the main program receives: "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"argc","salience":0.5882814526557922},{"name":"argv114","salience":0.41171854734420776}],"text":" ... Argc and Argv114/114 "},{"tags":[{"name":"paragraph"},{"name":"code","salience":0.5351265072822571},{"name":"name","salience":0.27773353457450867},{"name":"program","salience":0.18713992834091187}],"text":" Code to print the program's name (argv[0]): "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"},{"name":"code","salience":0.6597478985786438},{"name":"cmd-line arg","salience":0.3402521312236786}],"text":" Code to print the first cmd-line arg (argv[1]) "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" "},{"tags":[{"name":"paragraph"}],"text":""},{"tags":[{"name":"paragraph"}],"text":" Produced: 2 Apr 2018 "}]}