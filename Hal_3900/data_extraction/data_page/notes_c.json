{"grouped":[{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction set architectures"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"cpu architecture 2 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"why study assembler 3 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction sets 4 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction sets 5 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction sets 6 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction sets 7 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction sets 8 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"fetch execute cycle 9 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"fetch execute cycle 10 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"assembly language 11 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"assembly language 12 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips architecture 13 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips vs spim 14 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"using spim 15 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"using spim 16 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"using spim 17 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips machine archtecture 18 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips machine archtecture 19 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"reg name notes"},{"tags":[],"text":"0 zero the value 0 not changeable"},{"tags":[],"text":"1 at assembler temporary used to implement pseudo ops"},{"tags":[],"text":"2 v0 value from expression evaluation or function return"},{"tags":[],"text":"3 v1 value from expression evaluation or function return"},{"tags":[],"text":"4 a0 first argument to a function subroutine if needed"},{"tags":[],"text":"5 a1 second argument to a function subroutine if needed"},{"tags":[],"text":"6 a2 third argument to a function subroutine if needed"},{"tags":[],"text":"7 a3 fourth argument to a function subroutine if needed"},{"tags":[],"text":"8 15 t0 t7 temporary must be saved by caller to subroutine subroutine can overwrite"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips machine archtecture 20 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"reg name notes"},{"tags":[],"text":"16 23 s0 s7 safe function variable must not be overwritten by called subroutine"},{"tags":[],"text":"24 25 t8 t9 temporary must be saved by caller to subroutine subroutine can overwrite"},{"tags":[],"text":"26 27 k0 k1 for kernel use may change unexpectedly"},{"tags":[],"text":"28 gp global pointer"},{"tags":[],"text":"29 sp stack pointer"},{"tags":[],"text":"30 fp frame pointer"},{"tags":[],"text":"31 ra return address of most recent caller"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips machine archtecture 21 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"reg notes"},{"tags":[],"text":""},{"tags":[],"text":"f0 f2 hold floating point function results"},{"tags":[],"text":"f4 f10 temporary registers not preserved across function calls"},{"tags":[],"text":"f12 f14 used for first two double precision function arguments"},{"tags":[],"text":"f16 f18 temporary registers used for expression evaluation"},{"tags":[],"text":"f20 f30 saved registers value is preserved across function calls"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips assembly language 22 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips assembly language 23 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips assembly language 24 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips assembly language 25 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips assembly language 26 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"region address notes"},{"tags":[],"text":"text 0x00400000 contains only instructions read only cannot expand"},{"tags":[],"text":"data 0x10000000 data objects readable writeable can be expanded"},{"tags":[],"text":"stack 0x7fffefff grows down from that address readable writeable"},{"tags":[],"text":"k text 0x80000000 kernel code read only only accessible kernel mode"},{"tags":[],"text":"k data 0x90000000 kernel data read write only accessible kernel mode"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instructions 27 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instructions 28 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"addressing modes 29 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"addressing modes 30 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"format address computation"},{"tags":[],"text":"register address register contents of register"},{"tags":[],"text":"k address k"},{"tags":[],"text":"k register address k register"},{"tags":[],"text":"symbol address symbol address of symbol"},{"tags":[],"text":"symbol k address symbol k"},{"tags":[],"text":"symbol k register address symbol k register"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"addressing modes 31 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"operand sizes 32 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 33 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 34 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"syntax semantics"},{"tags":[],"text":"reg as source the content of the register reg reg"},{"tags":[],"text":"reg as destination value is stored in register reg reg value"},{"tags":[],"text":"label references the associated address in c terms label"},{"tags":[],"text":"addr any expression that yields an address e g label reg"},{"tags":[],"text":"addr as source the content of memory cell memory addr"},{"tags":[],"text":"addr as destination value is stored in memory addr value"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 35 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 36 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 37 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 38 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 39 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"service code arguments result"},{"tags":[],"text":"print int 1 a0 integer"},{"tags":[],"text":"print float 2 f12 float"},{"tags":[],"text":"print double 3 f12 double"},{"tags":[],"text":"print string 4 a0 char"},{"tags":[],"text":"read int 5 integer in v0"},{"tags":[],"text":"read float 6 float in f0"},{"tags":[],"text":"read double 7 double in f0"},{"tags":[],"text":"read string 8 a0 buffer a1 length string in buffer including n 0"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips instruction set 40 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips programming 41 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips programming 42 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips programming 43 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips programming 44 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mips programming 45 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"rendering c in mips 46 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"rendering c in mips 47 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"arithmetic expressions 48 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"conditional statements 49 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"conditional statements 50 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"conditional statements 51 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"conditional statements 52 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"conditional statements 53 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"boolean expressions 54 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"boolean expressions 55 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"iteration statements 56 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"iteration statements 57 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"functions 58 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"functions 59 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"functions 60 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"functions 61 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"functions 62 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"functions 63 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"aside mips branch delay slots 64 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"aside why do we need both fp and sp 65 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 66 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 67 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 68 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 69 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 70 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 71 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function calling protocol 72 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structure of functions 73 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function prologue 74 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function prologue 75 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function prologue 76 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function prologue 77 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function epilogue 78 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function epilogue 79 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"data structures and mips 80 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"static vs dynamic allocation 81 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"static vs dynamic allocation 82 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"static vs dynamic allocation 83 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"static vs dynamic allocation 84 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"static vs dynamic allocation 85 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"static vs dynamic allocation 86 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"1 d arrays in mips 87 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"1 d arrays in mips 88 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"1 d arrays in mips 89 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"1 d arrays in mips 90 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"2 d arrays in mips 91 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"2 d arrays in mips 92 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"2 d arrays in mips 93 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"2 d arrays in mips 94 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"2 d arrays in mips 95 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 96 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 97 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 98 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 99 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 100 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 101 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"structs in mips 102 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"compiling c to mips 103 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"c pre processor 104 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"c pre processor 105 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"c parser 106 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"symbol table management 107 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"local variables 108 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"expression evaluation 109 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mapping control structures 110 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"mapping control structures 111 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"argc and argv 112 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"argc and argv 113 114"}]},{"tags":[{"name":"table","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"argc and argv 114 114"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"a set of data registers"},{"tags":[],"text":"a set of control registers incl pc"},{"tags":[],"text":"an arithmetic logic unit alu"},{"tags":[],"text":"access to random access memory ram"},{"tags":[],"text":"a set of simple instructions transfer data between memory and registers push values through the alu to compute results make tests and transfer control of execution"},{"tags":[],"text":"transfer data between memory and registers"},{"tags":[],"text":"push values through the alu to compute results"},{"tags":[],"text":"make tests and transfer control of execution"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"transfer data between memory and registers"},{"tags":[],"text":"push values through the alu to compute results"},{"tags":[],"text":"make tests and transfer control of execution"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"e g different registers different sized registers different instructions"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"sometimes you are required to use it e g device handlers"},{"tags":[],"text":"improves your understanding of how c programs execute very helpful when debugging able to avoid using known inefficient constructs"},{"tags":[],"text":"very helpful when debugging"},{"tags":[],"text":"able to avoid using known inefficient constructs"},{"tags":[],"text":"uber nerdy performance tweaking squeezing out last nano s re write that critical frequently used function in assembler"},{"tags":[],"text":"re write that critical frequently used function in assembler"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"very helpful when debugging"},{"tags":[],"text":"able to avoid using known inefficient constructs"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"re write that critical frequently used function in assembler"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"small ish set of simple general instructions"},{"tags":[],"text":"separate computation data transfer instructions"},{"tags":[],"text":"leading to simpler processor hardware"},{"tags":[],"text":"e g mips risc alpha sparc powerpc arm"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"large r set of powerful instructions"},{"tags":[],"text":"each instruction has multiple actions comp store"},{"tags":[],"text":"more circuitry to decode process instructions"},{"tags":[],"text":"e g pdp vax z80 motorola 68xxx intel x86"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"typically have 1 2 32 bit words per instruction"},{"tags":[],"text":"partition bits in each word into operator operands"},{"tags":[],"text":"bits for each depends on instructions registers"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"load register memoryaddress copy value stored in memory at address into named register"},{"tags":[],"text":"copy value stored in memory at address into named register"},{"tags":[],"text":"loadc register constantvalue copy value into named register"},{"tags":[],"text":"copy value into named register"},{"tags":[],"text":"store register memoryaddress copy value stored in named register into memory at address"},{"tags":[],"text":"copy value stored in named register into memory at address"},{"tags":[],"text":"jump memoryaddress transfer execution of program to instruction at address"},{"tags":[],"text":"transfer execution of program to instruction at address"},{"tags":[],"text":"jumpif register memoryaddress transfer execution of program if e g register holds zero value"},{"tags":[],"text":"transfer execution of program if e g register holds zero value"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"copy value stored in memory at address into named register"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"copy value into named register"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"copy value stored in named register into memory at address"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"transfer execution of program to instruction at address"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"transfer execution of program if e g register holds zero value"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"add register1 register2 register3 similarly for sub mul div register3 register1 register2"},{"tags":[],"text":"register3 register1 register2"},{"tags":[],"text":"and register1 register2 register3 similarly for or xor register3 register1 register2"},{"tags":[],"text":"register3 register1 register2"},{"tags":[],"text":"neg register1 register2 register2 register1"},{"tags":[],"text":"register2 register1"},{"tags":[],"text":"shiftl register1 value register2 similarly for shiftr register2 register1 value"},{"tags":[],"text":"register2 register1 value"},{"tags":[],"text":"syscall value invoke a system service which service determined by value"},{"tags":[],"text":"invoke a system service which service determined by value"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"register3 register1 register2"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"register3 register1 register2"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"register2 register1"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"register2 register1 value"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"invoke a system service which service determined by value"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"determine what the operator is"},{"tags":[],"text":"determine which registers if any are involved"},{"tags":[],"text":"determine which memory location if any is involved"},{"tags":[],"text":"carry out the operation with the relevant operands"},{"tags":[],"text":"store result if any in appropriate register"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"write instructions using mnemonics rather than hex codes"},{"tags":[],"text":"reference registers using either numbers or names"},{"tags":[],"text":"can associate names to memory addresses"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"need to use fine grained control of memory usage"},{"tags":[],"text":"required to manipulate data in registers"},{"tags":[],"text":"control structures programmed via explicit jumps"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"very popular in a range of computing devices in the 1990 s"},{"tags":[],"text":"e g silicon graphics nec nintendo64 playstation supercomputers"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"using two variants of the open source spim emulator"},{"tags":[],"text":"qtspim provides a gui front end useful for debugging"},{"tags":[],"text":"spim command line based version useful for testing"},{"tags":[],"text":"xspim gui front end useful for debugging only in cse labs"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"reads text files containing instruction directives"},{"tags":[],"text":"converts to machine code and loads into memory"},{"tags":[],"text":"provides debugging capabilities single step breakpoints view registers memory"},{"tags":[],"text":"single step breakpoints view registers memory"},{"tags":[],"text":"provides mechanism to interact with operating system syscall"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"single step breakpoints view registers memory"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"provide convenient mnemonic ways to do common operations"},{"tags":[],"text":"e g move s0 v0 rather than addu s0 0 v0"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"spim command line tool load programs using file option interact using stdin stdout via login terminal"},{"tags":[],"text":"load programs using file option"},{"tags":[],"text":"interact using stdin stdout via login terminal"},{"tags":[],"text":"qtspim gui environment load programs via a load button interact via a pop up stdin stdout terminal"},{"tags":[],"text":"load programs via a load button"},{"tags":[],"text":"interact via a pop up stdin stdout terminal"},{"tags":[],"text":"xspim gui environment similar to qtspim but not as pretty requires x windows server"},{"tags":[],"text":"similar to qtspim but not as pretty"},{"tags":[],"text":"requires x windows server"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"load programs using file option"},{"tags":[],"text":"interact using stdin stdout via login terminal"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"load programs via a load button"},{"tags":[],"text":"interact via a pop up stdin stdout terminal"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"similar to qtspim but not as pretty"},{"tags":[],"text":"requires x windows server"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"32 32 bit general purpose registers"},{"tags":[],"text":"16 64 bit double precision registers"},{"tags":[],"text":"pc 32 bit register always aligned on 4 byte boundary"},{"tags":[],"text":"hi lo for storing results of multiplication and division"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"register 0 always has value 0 cannot be written"},{"tags":[],"text":"registers 1 26 27 reserved for use by system"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"registers come in pairs of 2 32 bits"},{"tags":[],"text":"only even registers are addressed for double precision"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"comments introduced by"},{"tags":[],"text":"labels appended with"},{"tags":[],"text":"directives symbol beginning with"},{"tags":[],"text":"assembly language instructions"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"data objects that live in the data region"},{"tags":[],"text":"functions instruction sequences that live in the code text region"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"load and store transfer data between registers and memory"},{"tags":[],"text":"computational perform arithmetic logical operations"},{"tags":[],"text":"jump and branch transfer control of program execution"},{"tags":[],"text":"coprocessor standard interface to various co processors"},{"tags":[],"text":"special miscellaneous tasks e g syscall"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"between memory and register direct indirect"},{"tags":[],"text":"constant to register immediate"},{"tags":[],"text":"register register destination register"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"an operation e g load store add branch"},{"tags":[],"text":"one or more operands e g registers memory addresses constants"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"symbolic name label effectively a constant"},{"tags":[],"text":"indirectly via a register effectively pointer dereferencing"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"computed address for a is 0x100000008"},{"tags":[],"text":"computed address for b is 0x100000000"},{"tags":[],"text":"computed address for c is 0x100000004"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"single bytes two bytes halfword four bytes word"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"lb load one byte from specified address"},{"tags":[],"text":"lbu load unsigned byte from specified address"},{"tags":[],"text":"lh load two bytes from specified address"},{"tags":[],"text":"lhu load unsigned 2 bytes from specified address"},{"tags":[],"text":"lw load four bytes one word from specified address"},{"tags":[],"text":"la load the specified address"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"lw sw add sub and or sll slt beq j jal"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"move rem la li blt"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"treat registers as unsigned int reg 32"},{"tags":[],"text":"treat memory as unsigned char mem 232"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"develop the solution in c"},{"tags":[],"text":"map to simplified c"},{"tags":[],"text":"translate each simplified c statement to mips instructions"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"does not have while switch complex expressions"},{"tags":[],"text":"does have simple if goto one operator expressions"},{"tags":[],"text":"does not have function calls and auto local variables"},{"tags":[],"text":"does have jump and remember where you came from"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"labels symbolic name for c statement"},{"tags":[],"text":"goto transfer control to labelled statement"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"follow the conventions implied by register names"},{"tags":[],"text":"preserve values that need to be saved across function calls"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"you manage register usage as you like"},{"tags":[],"text":"typically making use of t registers"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"you transfer control to a separate piece of code"},{"tags":[],"text":"which may change the value of any non preserved register"},{"tags":[],"text":"s registers must be preserved by function"},{"tags":[],"text":"a v t registers may be modified by function"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"x 1 y y 2 z 1 0 2"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"move rd rs li rd const add div and"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"sequence if while for break continue"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"seq slti sltu beq bgtz bgezal j jr jal"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"describing the process as a sequence of binary operations"},{"tags":[],"text":"managing data flow between the operations"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"works best for small dense range of case values e g 1 10"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"evaluate cond1 if 0 then return 0 for whole expression"},{"tags":[],"text":"evaluate cond2 if 0 then return 0 for whole expression"},{"tags":[],"text":""},{"tags":[],"text":"evaluate condn if 0 then return 0 for whole expression"},{"tags":[],"text":"otherwise return 1"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"evaluate cond1 if 0 then return 1 for whole expression"},{"tags":[],"text":"evaluate cond2 if 0 then return 1 for whole expression"},{"tags":[],"text":""},{"tags":[],"text":"evaluate condn if 0 then return 1 for whole expression"},{"tags":[],"text":"otherwise return 1"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"the arguments are evaluated and set up for function"},{"tags":[],"text":"control is transferred to the code for the function"},{"tags":[],"text":"local variables are created"},{"tags":[],"text":"the function code is executed in this environment"},{"tags":[],"text":"the return value is set up"},{"tags":[],"text":"control transfers back to where the function was called from"},{"tags":[],"text":"the caller receives the return value"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"used for saved registers local variables parameters to callees"},{"tags":[],"text":"created in the function prologue pushed"},{"tags":[],"text":"removed in the function epilogue popped"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"function f calls g which calls h"},{"tags":[],"text":"h runs then finishes and returns to g"},{"tags":[],"text":"g continues then finishes and returns to f"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"caller saved registers saved by f f tells g if there is anything i want to preserve in these registers i have already saved it before calling you g tells f don t assume that these registers will be unchanged when i return to you e g t0 t9 a0 a3 ra"},{"tags":[],"text":"f tells g if there is anything i want to preserve in these registers i have already saved it before calling you"},{"tags":[],"text":"g tells f don t assume that these registers will be unchanged when i return to you"},{"tags":[],"text":"e g t0 t9 a0 a3 ra"},{"tags":[],"text":"callee saved registers saved by g f tells g i assume the values of these registers will be unchanged when you return g tells f if i need to use these registers i will save them first and restore them before returning e g s0 s7 sp fp"},{"tags":[],"text":"f tells g i assume the values of these registers will be unchanged when you return"},{"tags":[],"text":"g tells f if i need to use these registers i will save them first and restore them before returning"},{"tags":[],"text":"e g s0 s7 sp fp"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"f tells g if there is anything i want to preserve in these registers i have already saved it before calling you"},{"tags":[],"text":"g tells f don t assume that these registers will be unchanged when i return to you"},{"tags":[],"text":"e g t0 t9 a0 a3 ra"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"f tells g i assume the values of these registers will be unchanged when you return"},{"tags":[],"text":"g tells f if i need to use these registers i will save them first and restore them before returning"},{"tags":[],"text":"e g s0 s7 sp fp"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"one instruction can start before the previous one finishes"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"instruction following branch is executed before branch completes"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"sp can change e g pushing params adding local vars"},{"tags":[],"text":"may need to reference local vars on the stack"},{"tags":[],"text":"useful if they can be defined by an offset relative to fixed point"},{"tags":[],"text":"fp provides a fixed point during function code execution"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"place 64 bit double args in f12 and f14"},{"tags":[],"text":"place 32 bit arguments in the a0 a3"},{"tags":[],"text":"if more than 4 args or args larger than 32 bits push value of all such args onto stack"},{"tags":[],"text":"push value of all such args onto stack"},{"tags":[],"text":"save any non s registers that need to be preserved push value of all such registers onto stack"},{"tags":[],"text":"push value of all such registers onto stack"},{"tags":[],"text":"jal address of function usually given by a label"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"push value of all such args onto stack"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"push value of all such registers onto stack"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"create a stack frame for itself change fp and sp"},{"tags":[],"text":"save the return address ra in the stack frame"},{"tags":[],"text":"save any s registers that it plans to change"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"4 bytes for saved fp 4 bytes for saved ra"},{"tags":[],"text":"4 bytes for each saved s"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"new fp old sp 4"},{"tags":[],"text":"new sp old sp size of frame in bytes"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"place the return value in v0 and maybe v1"},{"tags":[],"text":"pop any pushed arguments off the stack"},{"tags":[],"text":"restore the values of any saved s registers"},{"tags":[],"text":"restore the saved value of ra return address"},{"tags":[],"text":"remove its stack frame change fp and sp"},{"tags":[],"text":"return to the calling function jr ra"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"new sp old fp 4"},{"tags":[],"text":"new fp memory old fp"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"char as byte in memory or low order byte in register"},{"tags":[],"text":"int as word in memory or whole register"},{"tags":[],"text":"double as two words in memory or f register"},{"tags":[],"text":"arrays sequence of memory bytes words accessed by index"},{"tags":[],"text":"structs chunk of memory accessed by fields offsets"},{"tags":[],"text":"linked structures struct containing address of another struct"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"could be implemented in register if used in small scope"},{"tags":[],"text":"could be implemented on stack if local to function"},{"tags":[],"text":"could be implemented in data if need longer persistence"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"uninitialised memory allocated at compile assemble time e g int val val space 4 char str 20 str space 20 int vec 20 vec space 80"},{"tags":[],"text":"initialised memory allocated at compile assemble time e g int val 5 val word 5 int arr 4 9 8 7 6 arr word 9 8 7 6 char msg hello n msg asciiz hello n"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"variables local to a function"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"use space allocated on stack during function prologue"},{"tags":[],"text":"referenced during function relative to fp"},{"tags":[],"text":"space reclaimed from stack in function epilogue"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"uninitialised block of memory allocated at run time int ptr malloc sizeof int char str malloc 20 sizeof char int vec malloc 20 sizeof int ptr 5 strcpy str a string vec 0 1 or vec 1 vec 1 6"},{"tags":[],"text":"initialised block of memory allocated at run time int vec calloc 20 sizeof int vec i 0 for i in 0 19"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"but provides syscall 9 to extend data"},{"tags":[],"text":"before syscall set a0 to the number of bytes requested"},{"tags":[],"text":"after syscall v0 holds start address of allocated chunk"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"a complete implementation of c s heap management i e"},{"tags":[],"text":"a large region of memory to manage syscall 9"},{"tags":[],"text":"ability to mark chunks of this region as in use with size"},{"tags":[],"text":"ability to maintain list of free chunks"},{"tags":[],"text":"ability to merge free chunks to prevent fragmentation"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"either approach needs to account for size of elements"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"must also pass array size since not available elsewhere"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"makes things easier for a human to prodcue mips code"},{"tags":[],"text":"does not provide an automatic way of translating"},{"tags":[],"text":"this is provided by a compiler e g dcc"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"convert include and define"},{"tags":[],"text":"parse code to check syntactically valid"},{"tags":[],"text":"manage a list of symbols used in program"},{"tags":[],"text":"decide how to represent data structures"},{"tags":[],"text":"allocate local variables to registers or stack"},{"tags":[],"text":"map control structures to mips instructions"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"include file replace include by contents of file name h uses named file h uses file h in usr include"},{"tags":[],"text":"replace include by contents of file"},{"tags":[],"text":"name h uses named file h"},{"tags":[],"text":"uses file h in usr include"},{"tags":[],"text":"define name constant replace all occurences of symbol name by constant e g define max 5 char array max char array 5"},{"tags":[],"text":"replace all occurences of symbol name by constant"},{"tags":[],"text":"e g define max 5 char array max char array 5"},{"tags":[],"text":"define name params expression replace name params by substitutedexpression e g define max x y x y x y a max b c a b c b c"},{"tags":[],"text":"replace name params by substitutedexpression"},{"tags":[],"text":"e g define max x y x y x y a max b c a b c b c"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"replace include by contents of file"},{"tags":[],"text":"name h uses named file h"},{"tags":[],"text":"uses file h in usr include"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"replace all occurences of symbol name by constant"},{"tags":[],"text":"e g define max 5 char array max char array 5"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"replace name params by substitutedexpression"},{"tags":[],"text":"e g define max x y x y x y a max b c a b c b c"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"scope lifetime locally externally defined"},{"tags":[],"text":"disambiguates e g x in main vs x in fun"},{"tags":[],"text":"resolves symbols to specific locations data stack registers"},{"tags":[],"text":"external symbols may remain unresolved until linking"},{"tags":[],"text":"however need to have a type for each external symbol"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"on the stack persist for whole function lw sw needed in mips"},{"tags":[],"text":"in a register efficient not many useful if var used in small scope if need to persist across function calls use s register if used in very localised scope can use t register"},{"tags":[],"text":"if need to persist across function calls use s register"},{"tags":[],"text":"if used in very localised scope can use t register"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"if need to persist across function calls use s register"},{"tags":[],"text":"if used in very localised scope can use t register"}]},{"tags":[{"name":"list","salience":0.5,"theta":1}],"items":[{"tags":[],"text":"even complex expressions don t generally need 3 4 registers"}]}],"block":[{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c assembly language mips"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instruction set architectures"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"cpu architecture2 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"a typical modern cpu has"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"why study assembler 3 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"useful to know assembly language because"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instruction sets4 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"two broad families of instruction set architectures"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"risc reduced instruction set computer"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instruction sets5 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"machine level instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"operands and destination are typically registers"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instruction sets6 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"common kinds of instructions not from any real machine"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instruction sets7 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"other common kinds of instructions not from any real machine"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instruction sets8 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"fetch execute cycle9 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"all cpus have program execution logic like"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"pc program counter a cpu register which keeps track of execution"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"note that some instructions may modify pc further e g jump"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"fetch execute cycle10 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"executing an instruction involves"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"assembly language11 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instructions are simply bit patterns within a 32 bit bit string"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"could describe machine programs as a sequence of hex digits e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"often call assembly language as assembler"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"slight notational abuse because assembler also refers to a program that translates assembly language to machine code"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"assembly language12 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"assembler symbolic language for writing machine code"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips architecture13 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips is a well known and relatively simple architecture"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"source code for browsing under home cs1521 spim spim"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips vs spim14 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips is a machine architecture including instruction set"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"spim is an emulator for the mips instruction set"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"using spim15 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"three ways to execute mips code with spim"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"using spim16 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"command line tool"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"using spim17 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"gui tool"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips machine archtecture18 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips cpu has"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"some registers have special uses e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips machine archtecture19 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"registers and their usage"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"reg name notes 0 zero the value 0 not changeable 1 at assembler temporary used to implement pseudo ops 2 v0 value from expression evaluation or function return 3 v1 value from expression evaluation or function return 4 a0 first argument to a function subroutine if needed 5 a1 second argument to a function subroutine if needed 6 a2 third argument to a function subroutine if needed 7 a3 fourth argument to a function subroutine if needed 8 15 t0 t7 temporary must be saved by caller to subroutine subroutine can overwrite"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips machine archtecture20 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"more register usage"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"reg name notes 16 23 s0 s7 safe function variable must not be overwritten by called subroutine 24 25 t8 t9 temporary must be saved by caller to subroutine subroutine can overwrite 26 27 k0 k1 for kernel use may change unexpectedly 28 gp global pointer 29 sp stack pointer 30 fp frame pointer 31 ra return address of most recent caller"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips machine archtecture21 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"floating point register usage"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"reg notes f0 f2 hold floating point function results f4 f10 temporary registers not preserved across function calls f12 f14 used for first two double precision function arguments f16 f18 temporary registers used for expression evaluation f20 f30 saved registers value is preserved across function calls"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"notes"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips assembly language22 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips assembly language programs contain"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips assembly language23 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example mips assembler program"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"color coding label directive comment"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips assembly language24 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"generic structure of mips programs"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips assembly language25 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"another example mips assembler program"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips assembly language26 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips programs assume the following memory layout"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"region address notes text 0x00400000 contains only instructions read only cannot expand data 0x10000000 data objects readable writeable can be expanded stack 0x7fffefff grows down from that address readable writeable k text 0x80000000 kernel code read only only accessible kernel mode k data 0x90000000 kernel data read write only accessible kernel mode"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instructions27 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips has several classes of instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instructions28 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instructions are 32 bits long and specify"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"addressing modes29 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"memory addresses can be given by"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"if s0 contains 0x10000000 and var 0x100000008"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"addressing modes30 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"addressing modes in mips"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"format address computation register address register contents of register k address k k register address k register symbol address symbol address of symbol symbol k address symbol k symbol k register address symbol k register"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"where k is a literal constant value e g 4 or 0x10000000"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"addressing modes31 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"examples of load store and addressing"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"operand sizes32 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instructions can manipulate different sized operands"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"leads to many opcodes for a conceptually single operation e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set33 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"the mips processor implements a base set of instructions e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"note use of at register for intermediate results"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set34 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"in describing instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"syntaxsemantics reg as source the content of the register reg reg reg as destination value is stored in register reg reg value label references the associated address in c terms label addr any expression that yields an address e g label reg addr as source the content of memory cell memory addr addr as destination value is stored in memory addr value"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"effectively"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set35 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"examples of data movement instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"examples of bit manipulation instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set36 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"examples of arithmetic instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set37 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"examples of testing and branching instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"after each branch instruction execution continues at new pc location"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set38 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"special jump instruction for invoking functions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set39 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"spim interacts with stdin stdout via syscalls"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"servicecodeargumentsresult print int1 a0 integer print float2 f12 float print double3 f12 double print string4 a0 char read int5 integer in v0 read float6 float in f0 read double7 double in f0 read string8 a0 buffer a1 lengthstring in buffer including n 0"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips instruction set40 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"directives instructions to assembler not mips instructions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips programming41 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"writing directly in mips assembler is difficult impossible"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"strategy for producing likely correct mips code"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips programming42 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example translating c to mips"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips programming43 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"simplified c makes extensive use of"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips programming44 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"beware registers are shared by all parts of the code"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"one function can overwrite value set by another function"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"after the function x 6 and y 120"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"it is sheer coincidence that y has the correct value"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mips programming45 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"need to be careful managing registers"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"rendering c in mips46 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c provides expression evaluation and assignment e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"sequence is easy s1 s2 mips s1 mips s2"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"rendering c in mips47 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"simple example of assignment and sequence"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"arithmetic expressions48 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"expression evaluation involves"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"it is useful to minimise the number of registers involved in the evaluation"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements49 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements e g if"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements50 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements e g if"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements51 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example of if then else"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements52 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"could make switch by first converting to if"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"conditional statements53 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"jump table an alternative implementation of switch"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"boolean expressions54 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"boolean expressions in c are short circuit"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"evaluates by"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c99 standard defines return value for booleans expressions as 0 or 1"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"boolean expressions55 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"similarly for disjunctions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"evaluates by"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c99 standard defines return value for booleans expressions as 0 or 1"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"iteration statements56 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"iteration e g while"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"treat for as a special case of while"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"iteration statements57 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example of iteration over an array"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions58 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"when we call a function"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions59 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"data associated with function calls is placed on the mips stack"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions60 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"each function allocates a small section of the stack a frame"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions61 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"how stack changes as functions are called and return"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions62 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"register usage conventions when f calls g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions63 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"contents of a typical stack frame"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"aside mips branch delay slots64 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"the real mips architecture is pipelined to improve efficiency"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"a problem scenario and its solution branch delay slot"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"since spim is not pipelined the nop is not required"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"aside why do we need both fp and sp 65 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"during execution of a function"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol66 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"before one function calls another it needs to"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol67 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example simple function call"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol68 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"simple function call"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol69 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"execution of sum function"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol70 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example function f calls function g a b c d e f"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol71 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function call in mips"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function calling protocol72 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"execution of g function"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structure of functions73 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"functions in mips have the following general structure"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"aim of prologue create environment for function to execute in"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function prologue74 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"before a function starts working it needs to"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function prologue75 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example of function fx which uses s0 s1 s2"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function prologue76 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"alternatively more explicit push"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function prologue77 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"alternatively relative to new fp"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function epilogue78 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"before a function returns it needs to"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"changing fp and sp"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"function epilogue79 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example of function fx which uses s0 s1 s2"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"data structures and mips80 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c data structures and their mips representations"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static vs dynamic allocation81 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static allocation"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static vs dynamic allocation82 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"dynamic allocation i"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static vs dynamic allocation83 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"example of local variables on the stack"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static vs dynamic allocation84 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"dynamic allocation ii"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static vs dynamic allocation85 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"spim doesn t provide malloc free functions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"cannot access allocated data by name need to retain address"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"no way to free allocated data and no way to align data appropriately"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"static vs dynamic allocation86 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"implementing c like malloc and free in mips requires"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"1 d arrays in mips87 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"can be named initialised as noted above"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"can access elements via index or cursor pointer"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"1 d arrays in mips88 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"scanning across an array of n elements using index"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"assumes the existence of a print function to do printf d n x"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"1 d arrays in mips89 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"scanning across an array of n elements using cursor"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"assumes the existence of a print function to do printf d n x"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"1 d arrays in mips90 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"arrays that are local to functions are allocated space on the stack"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"2 d arrays in mips91 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"2 d arrays could be represented two ways"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"2 d arrays in mips92 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"representations of int matrix 4 4"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"now consider summing all elements"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"2 d arrays in mips93 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"accessing elements"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"2 d arrays in mips94 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"computing sum of all elements for strategy a int matrix 4 4"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"2 d arrays in mips95 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"computing sum of all elements for strategy b int matrix 4 4"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips96 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c structs hold a collection of values accessed by name"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips97 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c struct definitions effectively define a new type"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"instances of structures can be created by allocating space"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips98 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"accessing structure components is by offset not name"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips99 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs that are local to functions are allocated space on the stack"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips100 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c can pass whole structures to functions e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips101 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"accessing struct within function"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"structs in mips102 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"can also pass a pointer to a struct"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"clearly a more efficient way to pass a large struct"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"also required if the function needs to update the original struct"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"compiling c to mips103 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"using simplified c as an intermediate language"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c pre processor104 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"maps c c performing various substitutions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c pre processor105 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"more c pre processor substitions"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"c parser106 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"understands syntax of c language"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"attempts to convert c program into parse tree"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"symbol table management107 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"compiler keeps track of names"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"local variables108 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"two choices for local variables"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"expression evaluation109 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"uses temporary t registers"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"complex boolean expressions handled by short circuit evaluation"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mapping control structures110 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"use templates e g"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"mapping control structures111 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"template for if else if else"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"argc and argv112 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"the real mips machine has no idea about argc and argv"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"spim runs under linux and needs to interact with environment"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"so the initialisation code that invokes main sets them up"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"note we are ignoring envp environment pointer"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"argc and argv113 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"what the main program receives"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"argc and argv114 114"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"code to print the program s name argv 0"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"code to print the first cmd line arg argv 1"},{"tags":[{"name":"paragraph","salience":0.5,"theta":1}],"text":"produced 2 apr 2018"}]}